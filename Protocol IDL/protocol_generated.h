// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOL_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_PROTOCOL_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace protocol {

struct Vec2;

struct Vec3;

struct Notify_UnauthedAccess;
struct Notify_UnauthedAccessT;

namespace login {

struct Character;
struct CharacterT;

struct Request_Login;
struct Request_LoginT;

struct Reply_LoginFailed;
struct Reply_LoginFailedT;

struct Reply_LoginSuccess;
struct Reply_LoginSuccessT;

struct Request_Join;
struct Request_JoinT;

struct Reply_JoinFailed;
struct Reply_JoinFailedT;

struct Reply_JoinSuccess;
struct Reply_JoinSuccessT;

struct Request_CharacterList;
struct Request_CharacterListT;

struct Reply_CharacterList;
struct Reply_CharacterListT;

struct Request_CreateCharacter;
struct Request_CreateCharacterT;

struct Reply_CreateCharacterFailed;
struct Reply_CreateCharacterFailedT;

struct Reply_CreateCharacterSuccess;
struct Reply_CreateCharacterSuccessT;

struct Request_DeleteCharacter;
struct Request_DeleteCharacterT;

struct Reply_DeleteCharacterFailed;
struct Reply_DeleteCharacterFailedT;

struct Reply_DeleteCharacterSuccess;
struct Reply_DeleteCharacterSuccessT;

}  // namespace login

namespace world {

struct PlayerCharacter;
struct PlayerCharacterT;

struct RemotePC;
struct RemotePCT;

struct Monster;
struct MonsterT;

struct MoveInfo;

struct HittingInfo;
struct HittingInfoT;

struct Request_EnterWorld;
struct Request_EnterWorldT;

struct Reply_EnterWorldFailed;
struct Reply_EnterWorldFailedT;

struct Reply_EnterWorldSuccess;
struct Reply_EnterWorldSuccessT;

struct Notify_WorldLogicError;
struct Notify_WorldLogicErrorT;

struct Request_EnterWorldNext;
struct Request_EnterWorldNextT;

struct Reply_EnterWorldNextSuccess;
struct Reply_EnterWorldNextSuccessT;

struct Reply_EnterWorldNextFailed;
struct Reply_EnterWorldNextFailedT;

struct Notify_EnterZone;
struct Notify_EnterZoneT;

struct Request_Move;
struct Request_MoveT;

struct Request_Attack;
struct Request_AttackT;

struct Notify_Move;
struct Notify_MoveT;

struct Notify_Attack;
struct Notify_AttackT;

struct Notify_Hit;
struct Notify_HitT;

struct Notify_AppearActor;
struct Notify_AppearActorT;

struct Notify_DisappearActor;
struct Notify_DisappearActorT;

}  // namespace world

struct NetMessage;
struct NetMessageT;

enum class ErrorCode : int32_t {
  OK = 0,
  UNEXPECTED = 1,
  DATABASE_FAILED = 2,
  INVALID_SESSION = 10,
  INVALID_STRING = 20,
  LOGIN_INCORRECT_ACC_NAME = 100,
  LOGIN_INCORRECT_ACC_PASSWORD = 101,
  LOGIN_DUPLICATION = 102,
  JOIN_ACC_NAME_ALREADY = 200,
  JOIN_CANNOT_ACC_CREATE = 201,
  CREATE_CHARACTER_NAME_ALREADY = 300,
  CREATE_CHARACTER_CANNOT_CREATE = 301,
  CREATE_CHARACTER_ATTRIBUTE_NOT_EXIST = 302,
  DELETE_CHARACTER_NOT_EXIST = 400,
  DELETE_CHARACTER_CANNOT_DELETE = 401,
  ENTER_WORLD_INVALID_CHARACTER = 500,
  ENTER_WORLD_INVALID_STATE = 501,
  ENTER_WORLD_CANNOT_ENTER_ZONE = 502,
  ENTER_WORLD_NEXT_INVALID_STATE = 510,
  ENTER_WORLD_NEXT_CHARACTER_NOT_LOADED = 511,
  ENTER_WORLD_NEXT_CANNOT_FIND_ZONE = 512,
  WORLD_LOGIC_INVALID_STATE = 600,
  WORLD_LOGIC_ENTER_ZONE_FAILED = 603,
  MIN = OK,
  MAX = WORLD_LOGIC_ENTER_ZONE_FAILED
};

enum class ClassType : int32_t {
  NONE = 0,
  Knight = 1,
  Archer = 2,
  Mage = 3,
  MIN = NONE,
  MAX = Mage
};

inline const char **EnumNamesClassType() {
  static const char *names[] = {
    "NONE",
    "Knight",
    "Archer",
    "Mage",
    nullptr
  };
  return names;
}

inline const char *EnumNameClassType(ClassType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesClassType()[index];
}

enum class MapType : int32_t {
  NONE = 0,
  FIELD = 1,
  DUNGEON = 2,
  MIN = NONE,
  MAX = DUNGEON
};

inline const char **EnumNamesMapType() {
  static const char *names[] = {
    "NONE",
    "FIELD",
    "DUNGEON",
    nullptr
  };
  return names;
}

inline const char *EnumNameMapType(MapType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMapType()[index];
}

enum class MessageT : uint8_t {
  NONE = 0,
  Notify_UnauthedAccess = 1,
  login_Request_Login = 2,
  login_Reply_LoginFailed = 3,
  login_Reply_LoginSuccess = 4,
  login_Request_Join = 5,
  login_Reply_JoinFailed = 6,
  login_Reply_JoinSuccess = 7,
  login_Request_CharacterList = 8,
  login_Reply_CharacterList = 9,
  login_Request_CreateCharacter = 10,
  login_Reply_CreateCharacterFailed = 11,
  login_Reply_CreateCharacterSuccess = 12,
  login_Request_DeleteCharacter = 13,
  login_Reply_DeleteCharacterFailed = 14,
  login_Reply_DeleteCharacterSuccess = 15,
  world_Request_EnterWorld = 16,
  world_Reply_EnterWorldFailed = 17,
  world_Reply_EnterWorldSuccess = 18,
  world_Request_EnterWorldNext = 19,
  world_Reply_EnterWorldNextFailed = 20,
  world_Reply_EnterWorldNextSuccess = 21,
  world_Notify_WorldLogicError = 22,
  world_Notify_EnterZone = 23,
  world_Notify_AppearActor = 24,
  world_Notify_DisappearActor = 25,
  world_Request_Move = 26,
  world_Request_Attack = 27,
  world_Notify_Move = 28,
  world_Notify_Attack = 29,
  world_Notify_Hit = 30,
  MIN = NONE,
  MAX = world_Notify_Hit
};

inline const char **EnumNamesMessageT() {
  static const char *names[] = {
    "NONE",
    "Notify_UnauthedAccess",
    "login_Request_Login",
    "login_Reply_LoginFailed",
    "login_Reply_LoginSuccess",
    "login_Request_Join",
    "login_Reply_JoinFailed",
    "login_Reply_JoinSuccess",
    "login_Request_CharacterList",
    "login_Reply_CharacterList",
    "login_Request_CreateCharacter",
    "login_Reply_CreateCharacterFailed",
    "login_Reply_CreateCharacterSuccess",
    "login_Request_DeleteCharacter",
    "login_Reply_DeleteCharacterFailed",
    "login_Reply_DeleteCharacterSuccess",
    "world_Request_EnterWorld",
    "world_Reply_EnterWorldFailed",
    "world_Reply_EnterWorldSuccess",
    "world_Request_EnterWorldNext",
    "world_Reply_EnterWorldNextFailed",
    "world_Reply_EnterWorldNextSuccess",
    "world_Notify_WorldLogicError",
    "world_Notify_EnterZone",
    "world_Notify_AppearActor",
    "world_Notify_DisappearActor",
    "world_Request_Move",
    "world_Request_Attack",
    "world_Notify_Move",
    "world_Notify_Attack",
    "world_Notify_Hit",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageT(MessageT e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageT()[index];
}

template<typename T> struct MessageTTraits {
  static const MessageT enum_value = MessageT::NONE;
};

template<> struct MessageTTraits<protocol::Notify_UnauthedAccess> {
  static const MessageT enum_value = MessageT::Notify_UnauthedAccess;
};

template<> struct MessageTTraits<protocol::login::Request_Login> {
  static const MessageT enum_value = MessageT::login_Request_Login;
};

template<> struct MessageTTraits<protocol::login::Reply_LoginFailed> {
  static const MessageT enum_value = MessageT::login_Reply_LoginFailed;
};

template<> struct MessageTTraits<protocol::login::Reply_LoginSuccess> {
  static const MessageT enum_value = MessageT::login_Reply_LoginSuccess;
};

template<> struct MessageTTraits<protocol::login::Request_Join> {
  static const MessageT enum_value = MessageT::login_Request_Join;
};

template<> struct MessageTTraits<protocol::login::Reply_JoinFailed> {
  static const MessageT enum_value = MessageT::login_Reply_JoinFailed;
};

template<> struct MessageTTraits<protocol::login::Reply_JoinSuccess> {
  static const MessageT enum_value = MessageT::login_Reply_JoinSuccess;
};

template<> struct MessageTTraits<protocol::login::Request_CharacterList> {
  static const MessageT enum_value = MessageT::login_Request_CharacterList;
};

template<> struct MessageTTraits<protocol::login::Reply_CharacterList> {
  static const MessageT enum_value = MessageT::login_Reply_CharacterList;
};

template<> struct MessageTTraits<protocol::login::Request_CreateCharacter> {
  static const MessageT enum_value = MessageT::login_Request_CreateCharacter;
};

template<> struct MessageTTraits<protocol::login::Reply_CreateCharacterFailed> {
  static const MessageT enum_value = MessageT::login_Reply_CreateCharacterFailed;
};

template<> struct MessageTTraits<protocol::login::Reply_CreateCharacterSuccess> {
  static const MessageT enum_value = MessageT::login_Reply_CreateCharacterSuccess;
};

template<> struct MessageTTraits<protocol::login::Request_DeleteCharacter> {
  static const MessageT enum_value = MessageT::login_Request_DeleteCharacter;
};

template<> struct MessageTTraits<protocol::login::Reply_DeleteCharacterFailed> {
  static const MessageT enum_value = MessageT::login_Reply_DeleteCharacterFailed;
};

template<> struct MessageTTraits<protocol::login::Reply_DeleteCharacterSuccess> {
  static const MessageT enum_value = MessageT::login_Reply_DeleteCharacterSuccess;
};

template<> struct MessageTTraits<protocol::world::Request_EnterWorld> {
  static const MessageT enum_value = MessageT::world_Request_EnterWorld;
};

template<> struct MessageTTraits<protocol::world::Reply_EnterWorldFailed> {
  static const MessageT enum_value = MessageT::world_Reply_EnterWorldFailed;
};

template<> struct MessageTTraits<protocol::world::Reply_EnterWorldSuccess> {
  static const MessageT enum_value = MessageT::world_Reply_EnterWorldSuccess;
};

template<> struct MessageTTraits<protocol::world::Request_EnterWorldNext> {
  static const MessageT enum_value = MessageT::world_Request_EnterWorldNext;
};

template<> struct MessageTTraits<protocol::world::Reply_EnterWorldNextFailed> {
  static const MessageT enum_value = MessageT::world_Reply_EnterWorldNextFailed;
};

template<> struct MessageTTraits<protocol::world::Reply_EnterWorldNextSuccess> {
  static const MessageT enum_value = MessageT::world_Reply_EnterWorldNextSuccess;
};

template<> struct MessageTTraits<protocol::world::Notify_WorldLogicError> {
  static const MessageT enum_value = MessageT::world_Notify_WorldLogicError;
};

template<> struct MessageTTraits<protocol::world::Notify_EnterZone> {
  static const MessageT enum_value = MessageT::world_Notify_EnterZone;
};

template<> struct MessageTTraits<protocol::world::Notify_AppearActor> {
  static const MessageT enum_value = MessageT::world_Notify_AppearActor;
};

template<> struct MessageTTraits<protocol::world::Notify_DisappearActor> {
  static const MessageT enum_value = MessageT::world_Notify_DisappearActor;
};

template<> struct MessageTTraits<protocol::world::Request_Move> {
  static const MessageT enum_value = MessageT::world_Request_Move;
};

template<> struct MessageTTraits<protocol::world::Request_Attack> {
  static const MessageT enum_value = MessageT::world_Request_Attack;
};

template<> struct MessageTTraits<protocol::world::Notify_Move> {
  static const MessageT enum_value = MessageT::world_Notify_Move;
};

template<> struct MessageTTraits<protocol::world::Notify_Attack> {
  static const MessageT enum_value = MessageT::world_Notify_Attack;
};

template<> struct MessageTTraits<protocol::world::Notify_Hit> {
  static const MessageT enum_value = MessageT::world_Notify_Hit;
};

struct MessageTUnion {
  MessageT type;
  void *value;

  MessageTUnion() : type(MessageT::NONE), value(nullptr) {}
  MessageTUnion(MessageTUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MessageT::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageTUnion(const MessageTUnion &) FLATBUFFERS_NOEXCEPT;
  MessageTUnion &operator=(const MessageTUnion &u) FLATBUFFERS_NOEXCEPT
    { MessageTUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageTUnion &operator=(MessageTUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageTUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    Reset();
    type = MessageTTraits<typename T::TableType>::enum_value;
    if (type != MessageT::NONE) {
      value = new T(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, MessageT type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  protocol::Notify_UnauthedAccessT *AsNotify_UnauthedAccess() {
    return type == MessageT::Notify_UnauthedAccess ?
      reinterpret_cast<protocol::Notify_UnauthedAccessT *>(value) : nullptr;
  }
  protocol::login::Request_LoginT *Aslogin_Request_Login() {
    return type == MessageT::login_Request_Login ?
      reinterpret_cast<protocol::login::Request_LoginT *>(value) : nullptr;
  }
  protocol::login::Reply_LoginFailedT *Aslogin_Reply_LoginFailed() {
    return type == MessageT::login_Reply_LoginFailed ?
      reinterpret_cast<protocol::login::Reply_LoginFailedT *>(value) : nullptr;
  }
  protocol::login::Reply_LoginSuccessT *Aslogin_Reply_LoginSuccess() {
    return type == MessageT::login_Reply_LoginSuccess ?
      reinterpret_cast<protocol::login::Reply_LoginSuccessT *>(value) : nullptr;
  }
  protocol::login::Request_JoinT *Aslogin_Request_Join() {
    return type == MessageT::login_Request_Join ?
      reinterpret_cast<protocol::login::Request_JoinT *>(value) : nullptr;
  }
  protocol::login::Reply_JoinFailedT *Aslogin_Reply_JoinFailed() {
    return type == MessageT::login_Reply_JoinFailed ?
      reinterpret_cast<protocol::login::Reply_JoinFailedT *>(value) : nullptr;
  }
  protocol::login::Reply_JoinSuccessT *Aslogin_Reply_JoinSuccess() {
    return type == MessageT::login_Reply_JoinSuccess ?
      reinterpret_cast<protocol::login::Reply_JoinSuccessT *>(value) : nullptr;
  }
  protocol::login::Request_CharacterListT *Aslogin_Request_CharacterList() {
    return type == MessageT::login_Request_CharacterList ?
      reinterpret_cast<protocol::login::Request_CharacterListT *>(value) : nullptr;
  }
  protocol::login::Reply_CharacterListT *Aslogin_Reply_CharacterList() {
    return type == MessageT::login_Reply_CharacterList ?
      reinterpret_cast<protocol::login::Reply_CharacterListT *>(value) : nullptr;
  }
  protocol::login::Request_CreateCharacterT *Aslogin_Request_CreateCharacter() {
    return type == MessageT::login_Request_CreateCharacter ?
      reinterpret_cast<protocol::login::Request_CreateCharacterT *>(value) : nullptr;
  }
  protocol::login::Reply_CreateCharacterFailedT *Aslogin_Reply_CreateCharacterFailed() {
    return type == MessageT::login_Reply_CreateCharacterFailed ?
      reinterpret_cast<protocol::login::Reply_CreateCharacterFailedT *>(value) : nullptr;
  }
  protocol::login::Reply_CreateCharacterSuccessT *Aslogin_Reply_CreateCharacterSuccess() {
    return type == MessageT::login_Reply_CreateCharacterSuccess ?
      reinterpret_cast<protocol::login::Reply_CreateCharacterSuccessT *>(value) : nullptr;
  }
  protocol::login::Request_DeleteCharacterT *Aslogin_Request_DeleteCharacter() {
    return type == MessageT::login_Request_DeleteCharacter ?
      reinterpret_cast<protocol::login::Request_DeleteCharacterT *>(value) : nullptr;
  }
  protocol::login::Reply_DeleteCharacterFailedT *Aslogin_Reply_DeleteCharacterFailed() {
    return type == MessageT::login_Reply_DeleteCharacterFailed ?
      reinterpret_cast<protocol::login::Reply_DeleteCharacterFailedT *>(value) : nullptr;
  }
  protocol::login::Reply_DeleteCharacterSuccessT *Aslogin_Reply_DeleteCharacterSuccess() {
    return type == MessageT::login_Reply_DeleteCharacterSuccess ?
      reinterpret_cast<protocol::login::Reply_DeleteCharacterSuccessT *>(value) : nullptr;
  }
  protocol::world::Request_EnterWorldT *Asworld_Request_EnterWorld() {
    return type == MessageT::world_Request_EnterWorld ?
      reinterpret_cast<protocol::world::Request_EnterWorldT *>(value) : nullptr;
  }
  protocol::world::Reply_EnterWorldFailedT *Asworld_Reply_EnterWorldFailed() {
    return type == MessageT::world_Reply_EnterWorldFailed ?
      reinterpret_cast<protocol::world::Reply_EnterWorldFailedT *>(value) : nullptr;
  }
  protocol::world::Reply_EnterWorldSuccessT *Asworld_Reply_EnterWorldSuccess() {
    return type == MessageT::world_Reply_EnterWorldSuccess ?
      reinterpret_cast<protocol::world::Reply_EnterWorldSuccessT *>(value) : nullptr;
  }
  protocol::world::Request_EnterWorldNextT *Asworld_Request_EnterWorldNext() {
    return type == MessageT::world_Request_EnterWorldNext ?
      reinterpret_cast<protocol::world::Request_EnterWorldNextT *>(value) : nullptr;
  }
  protocol::world::Reply_EnterWorldNextFailedT *Asworld_Reply_EnterWorldNextFailed() {
    return type == MessageT::world_Reply_EnterWorldNextFailed ?
      reinterpret_cast<protocol::world::Reply_EnterWorldNextFailedT *>(value) : nullptr;
  }
  protocol::world::Reply_EnterWorldNextSuccessT *Asworld_Reply_EnterWorldNextSuccess() {
    return type == MessageT::world_Reply_EnterWorldNextSuccess ?
      reinterpret_cast<protocol::world::Reply_EnterWorldNextSuccessT *>(value) : nullptr;
  }
  protocol::world::Notify_WorldLogicErrorT *Asworld_Notify_WorldLogicError() {
    return type == MessageT::world_Notify_WorldLogicError ?
      reinterpret_cast<protocol::world::Notify_WorldLogicErrorT *>(value) : nullptr;
  }
  protocol::world::Notify_EnterZoneT *Asworld_Notify_EnterZone() {
    return type == MessageT::world_Notify_EnterZone ?
      reinterpret_cast<protocol::world::Notify_EnterZoneT *>(value) : nullptr;
  }
  protocol::world::Notify_AppearActorT *Asworld_Notify_AppearActor() {
    return type == MessageT::world_Notify_AppearActor ?
      reinterpret_cast<protocol::world::Notify_AppearActorT *>(value) : nullptr;
  }
  protocol::world::Notify_DisappearActorT *Asworld_Notify_DisappearActor() {
    return type == MessageT::world_Notify_DisappearActor ?
      reinterpret_cast<protocol::world::Notify_DisappearActorT *>(value) : nullptr;
  }
  protocol::world::Request_MoveT *Asworld_Request_Move() {
    return type == MessageT::world_Request_Move ?
      reinterpret_cast<protocol::world::Request_MoveT *>(value) : nullptr;
  }
  protocol::world::Request_AttackT *Asworld_Request_Attack() {
    return type == MessageT::world_Request_Attack ?
      reinterpret_cast<protocol::world::Request_AttackT *>(value) : nullptr;
  }
  protocol::world::Notify_MoveT *Asworld_Notify_Move() {
    return type == MessageT::world_Notify_Move ?
      reinterpret_cast<protocol::world::Notify_MoveT *>(value) : nullptr;
  }
  protocol::world::Notify_AttackT *Asworld_Notify_Attack() {
    return type == MessageT::world_Notify_Attack ?
      reinterpret_cast<protocol::world::Notify_AttackT *>(value) : nullptr;
  }
  protocol::world::Notify_HitT *Asworld_Notify_Hit() {
    return type == MessageT::world_Notify_Hit ?
      reinterpret_cast<protocol::world::Notify_HitT *>(value) : nullptr;
  }
};

bool VerifyMessageT(flatbuffers::Verifier &verifier, const void *obj, MessageT type);
bool VerifyMessageTVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(this, 0, sizeof(Vec2));
  }
  Vec2(const Vec2 &_o) {
    memcpy(this, &_o, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(const Vec3 &_o) {
    memcpy(this, &_o, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vec3, 12);

namespace world {

MANUALLY_ALIGNED_STRUCT(4) MoveInfo FLATBUFFERS_FINAL_CLASS {
 private:
  float rotation_;
  protocol::Vec3 pos_;
  protocol::Vec3 velocity_;

 public:
  MoveInfo() {
    memset(this, 0, sizeof(MoveInfo));
  }
  MoveInfo(const MoveInfo &_o) {
    memcpy(this, &_o, sizeof(MoveInfo));
  }
  MoveInfo(float _rotation, const protocol::Vec3 &_pos, const protocol::Vec3 &_velocity)
      : rotation_(flatbuffers::EndianScalar(_rotation)),
        pos_(_pos),
        velocity_(_velocity) {
  }
  float rotation() const {
    return flatbuffers::EndianScalar(rotation_);
  }
  const protocol::Vec3 &pos() const {
    return pos_;
  }
  const protocol::Vec3 &velocity() const {
    return velocity_;
  }
};
STRUCT_END(MoveInfo, 28);

}  // namespace world

struct Notify_UnauthedAccessT : public flatbuffers::NativeTable {
  typedef Notify_UnauthedAccess TableType;
  Notify_UnauthedAccessT() {
  }
};

struct Notify_UnauthedAccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_UnauthedAccessT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Notify_UnauthedAccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_UnauthedAccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_UnauthedAccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_UnauthedAccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Notify_UnauthedAccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_UnauthedAccessBuilder &operator=(const Notify_UnauthedAccessBuilder &);
  flatbuffers::Offset<Notify_UnauthedAccess> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Notify_UnauthedAccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_UnauthedAccess> CreateNotify_UnauthedAccess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Notify_UnauthedAccessBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Notify_UnauthedAccess> CreateNotify_UnauthedAccess(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace login {

struct CharacterT : public flatbuffers::NativeTable {
  typedef Character TableType;
  int32_t id;
  std::string name;
  protocol::ClassType class_type;
  int32_t level;
  CharacterT()
      : id(0),
        class_type(protocol::ClassType::NONE),
        level(0) {
  }
};

struct Character FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CharacterT NativeTableType;
  enum {
    VT_ID = 4,
    VT_NAME = 6,
    VT_CLASS_TYPE = 8,
    VT_LEVEL = 10
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  protocol::ClassType class_type() const {
    return static_cast<protocol::ClassType>(GetField<int32_t>(VT_CLASS_TYPE, 0));
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
  CharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Character> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Character::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Character::VT_NAME, name);
  }
  void add_class_type(protocol::ClassType class_type) {
    fbb_.AddElement<int32_t>(Character::VT_CLASS_TYPE, static_cast<int32_t>(class_type), 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(Character::VT_LEVEL, level, 0);
  }
  CharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CharacterBuilder &operator=(const CharacterBuilder &);
  flatbuffers::Offset<Character> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Character>(end);
    return o;
  }
};

inline flatbuffers::Offset<Character> CreateCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    protocol::ClassType class_type = protocol::ClassType::NONE,
    int32_t level = 0) {
  CharacterBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Character> CreateCharacterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    protocol::ClassType class_type = protocol::ClassType::NONE,
    int32_t level = 0) {
  return protocol::login::CreateCharacter(
      _fbb,
      id,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      level);
}

flatbuffers::Offset<Character> CreateCharacter(flatbuffers::FlatBufferBuilder &_fbb, const CharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_LoginT : public flatbuffers::NativeTable {
  typedef Request_Login TableType;
  std::string acc_name;
  std::string password;
  Request_LoginT() {
  }
};

struct Request_Login FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_LoginT NativeTableType;
  enum {
    VT_ACC_NAME = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *acc_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ACC_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC_NAME) &&
           verifier.Verify(acc_name()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
  Request_LoginT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_LoginT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Login> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_LoginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc_name(flatbuffers::Offset<flatbuffers::String> acc_name) {
    fbb_.AddOffset(Request_Login::VT_ACC_NAME, acc_name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(Request_Login::VT_PASSWORD, password);
  }
  Request_LoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_LoginBuilder &operator=(const Request_LoginBuilder &);
  flatbuffers::Offset<Request_Login> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_Login>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Login> CreateRequest_Login(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> acc_name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  Request_LoginBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_acc_name(acc_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Login> CreateRequest_LoginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *acc_name = nullptr,
    const char *password = nullptr) {
  return protocol::login::CreateRequest_Login(
      _fbb,
      acc_name ? _fbb.CreateString(acc_name) : 0,
      password ? _fbb.CreateString(password) : 0);
}

flatbuffers::Offset<Request_Login> CreateRequest_Login(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_LoginFailedT : public flatbuffers::NativeTable {
  typedef Reply_LoginFailed TableType;
  protocol::ErrorCode error_code;
  Reply_LoginFailedT()
      : error_code(protocol::ErrorCode::OK) {
  }
};

struct Reply_LoginFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_LoginFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  protocol::ErrorCode error_code() const {
    return static_cast<protocol::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_LoginFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_LoginFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_LoginFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_LoginFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(protocol::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_LoginFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_LoginFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_LoginFailedBuilder &operator=(const Reply_LoginFailedBuilder &);
  flatbuffers::Offset<Reply_LoginFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_LoginFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_LoginFailed> CreateReply_LoginFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    protocol::ErrorCode error_code = protocol::ErrorCode::OK) {
  Reply_LoginFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_LoginFailed> CreateReply_LoginFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_LoginSuccessT : public flatbuffers::NativeTable {
  typedef Reply_LoginSuccess TableType;
  std::string auth_key;
  Reply_LoginSuccessT() {
  }
};

struct Reply_LoginSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_LoginSuccessT NativeTableType;
  enum {
    VT_AUTH_KEY = 4
  };
  const flatbuffers::String *auth_key() const {
    return GetPointer<const flatbuffers::String *>(VT_AUTH_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AUTH_KEY) &&
           verifier.Verify(auth_key()) &&
           verifier.EndTable();
  }
  Reply_LoginSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_LoginSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_LoginSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_LoginSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_auth_key(flatbuffers::Offset<flatbuffers::String> auth_key) {
    fbb_.AddOffset(Reply_LoginSuccess::VT_AUTH_KEY, auth_key);
  }
  Reply_LoginSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_LoginSuccessBuilder &operator=(const Reply_LoginSuccessBuilder &);
  flatbuffers::Offset<Reply_LoginSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_LoginSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> auth_key = 0) {
  Reply_LoginSuccessBuilder builder_(_fbb);
  builder_.add_auth_key(auth_key);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccessDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *auth_key = nullptr) {
  return protocol::login::CreateReply_LoginSuccess(
      _fbb,
      auth_key ? _fbb.CreateString(auth_key) : 0);
}

flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_JoinT : public flatbuffers::NativeTable {
  typedef Request_Join TableType;
  std::string acc_name;
  std::string password;
  Request_JoinT() {
  }
};

struct Request_Join FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_JoinT NativeTableType;
  enum {
    VT_ACC_NAME = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *acc_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ACC_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACC_NAME) &&
           verifier.Verify(acc_name()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
  Request_JoinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_JoinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Join> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_JoinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_JoinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc_name(flatbuffers::Offset<flatbuffers::String> acc_name) {
    fbb_.AddOffset(Request_Join::VT_ACC_NAME, acc_name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(Request_Join::VT_PASSWORD, password);
  }
  Request_JoinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_JoinBuilder &operator=(const Request_JoinBuilder &);
  flatbuffers::Offset<Request_Join> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_Join>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Join> CreateRequest_Join(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> acc_name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  Request_JoinBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_acc_name(acc_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Join> CreateRequest_JoinDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *acc_name = nullptr,
    const char *password = nullptr) {
  return protocol::login::CreateRequest_Join(
      _fbb,
      acc_name ? _fbb.CreateString(acc_name) : 0,
      password ? _fbb.CreateString(password) : 0);
}

flatbuffers::Offset<Request_Join> CreateRequest_Join(flatbuffers::FlatBufferBuilder &_fbb, const Request_JoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_JoinFailedT : public flatbuffers::NativeTable {
  typedef Reply_JoinFailed TableType;
  protocol::ErrorCode error_code;
  Reply_JoinFailedT()
      : error_code(protocol::ErrorCode::OK) {
  }
};

struct Reply_JoinFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_JoinFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  protocol::ErrorCode error_code() const {
    return static_cast<protocol::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_JoinFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_JoinFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_JoinFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_JoinFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(protocol::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_JoinFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_JoinFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_JoinFailedBuilder &operator=(const Reply_JoinFailedBuilder &);
  flatbuffers::Offset<Reply_JoinFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_JoinFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_JoinFailed> CreateReply_JoinFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    protocol::ErrorCode error_code = protocol::ErrorCode::OK) {
  Reply_JoinFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_JoinFailed> CreateReply_JoinFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_JoinSuccessT : public flatbuffers::NativeTable {
  typedef Reply_JoinSuccess TableType;
  Reply_JoinSuccessT() {
  }
};

struct Reply_JoinSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_JoinSuccessT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Reply_JoinSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_JoinSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_JoinSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_JoinSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Reply_JoinSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_JoinSuccessBuilder &operator=(const Reply_JoinSuccessBuilder &);
  flatbuffers::Offset<Reply_JoinSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Reply_JoinSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_JoinSuccess> CreateReply_JoinSuccess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Reply_JoinSuccessBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_JoinSuccess> CreateReply_JoinSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_CharacterListT : public flatbuffers::NativeTable {
  typedef Request_CharacterList TableType;
  Request_CharacterListT() {
  }
};

struct Request_CharacterList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_CharacterListT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_CharacterListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_CharacterListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_CharacterList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_CharacterListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_CharacterListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Request_CharacterListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_CharacterListBuilder &operator=(const Request_CharacterListBuilder &);
  flatbuffers::Offset<Request_CharacterList> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Request_CharacterList>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_CharacterList> CreateRequest_CharacterList(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Request_CharacterListBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Request_CharacterList> CreateRequest_CharacterList(flatbuffers::FlatBufferBuilder &_fbb, const Request_CharacterListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_CharacterListT : public flatbuffers::NativeTable {
  typedef Reply_CharacterList TableType;
  std::vector<std::unique_ptr<CharacterT>> list;
  Reply_CharacterListT() {
  }
};

struct Reply_CharacterList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_CharacterListT NativeTableType;
  enum {
    VT_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Character>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Character>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.Verify(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
  Reply_CharacterListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_CharacterListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_CharacterList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CharacterListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_CharacterListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Character>>> list) {
    fbb_.AddOffset(Reply_CharacterList::VT_LIST, list);
  }
  Reply_CharacterListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_CharacterListBuilder &operator=(const Reply_CharacterListBuilder &);
  flatbuffers::Offset<Reply_CharacterList> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_CharacterList>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_CharacterList> CreateReply_CharacterList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Character>>> list = 0) {
  Reply_CharacterListBuilder builder_(_fbb);
  builder_.add_list(list);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reply_CharacterList> CreateReply_CharacterListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Character>> *list = nullptr) {
  return protocol::login::CreateReply_CharacterList(
      _fbb,
      list ? _fbb.CreateVector<flatbuffers::Offset<Character>>(*list) : 0);
}

flatbuffers::Offset<Reply_CharacterList> CreateReply_CharacterList(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CharacterListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_CreateCharacterT : public flatbuffers::NativeTable {
  typedef Request_CreateCharacter TableType;
  std::string name;
  protocol::ClassType class_type;
  Request_CreateCharacterT()
      : class_type(protocol::ClassType::NONE) {
  }
};

struct Request_CreateCharacter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_CreateCharacterT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_CLASS_TYPE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  protocol::ClassType class_type() const {
    return static_cast<protocol::ClassType>(GetField<int32_t>(VT_CLASS_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           verifier.EndTable();
  }
  Request_CreateCharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_CreateCharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_CreateCharacter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_CreateCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_CreateCharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Request_CreateCharacter::VT_NAME, name);
  }
  void add_class_type(protocol::ClassType class_type) {
    fbb_.AddElement<int32_t>(Request_CreateCharacter::VT_CLASS_TYPE, static_cast<int32_t>(class_type), 0);
  }
  Request_CreateCharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_CreateCharacterBuilder &operator=(const Request_CreateCharacterBuilder &);
  flatbuffers::Offset<Request_CreateCharacter> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_CreateCharacter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_CreateCharacter> CreateRequest_CreateCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    protocol::ClassType class_type = protocol::ClassType::NONE) {
  Request_CreateCharacterBuilder builder_(_fbb);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_CreateCharacter> CreateRequest_CreateCharacterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    protocol::ClassType class_type = protocol::ClassType::NONE) {
  return protocol::login::CreateRequest_CreateCharacter(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      class_type);
}

flatbuffers::Offset<Request_CreateCharacter> CreateRequest_CreateCharacter(flatbuffers::FlatBufferBuilder &_fbb, const Request_CreateCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_CreateCharacterFailedT : public flatbuffers::NativeTable {
  typedef Reply_CreateCharacterFailed TableType;
  protocol::ErrorCode error_code;
  Reply_CreateCharacterFailedT()
      : error_code(protocol::ErrorCode::OK) {
  }
};

struct Reply_CreateCharacterFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_CreateCharacterFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  protocol::ErrorCode error_code() const {
    return static_cast<protocol::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_CreateCharacterFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_CreateCharacterFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_CreateCharacterFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_CreateCharacterFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(protocol::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_CreateCharacterFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_CreateCharacterFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_CreateCharacterFailedBuilder &operator=(const Reply_CreateCharacterFailedBuilder &);
  flatbuffers::Offset<Reply_CreateCharacterFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_CreateCharacterFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_CreateCharacterFailed> CreateReply_CreateCharacterFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    protocol::ErrorCode error_code = protocol::ErrorCode::OK) {
  Reply_CreateCharacterFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_CreateCharacterFailed> CreateReply_CreateCharacterFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_CreateCharacterSuccessT : public flatbuffers::NativeTable {
  typedef Reply_CreateCharacterSuccess TableType;
  std::unique_ptr<CharacterT> character;
  Reply_CreateCharacterSuccessT() {
  }
};

struct Reply_CreateCharacterSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_CreateCharacterSuccessT NativeTableType;
  enum {
    VT_CHARACTER = 4
  };
  const Character *character() const {
    return GetPointer<const Character *>(VT_CHARACTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHARACTER) &&
           verifier.VerifyTable(character()) &&
           verifier.EndTable();
  }
  Reply_CreateCharacterSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_CreateCharacterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_CreateCharacterSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_CreateCharacterSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character(flatbuffers::Offset<Character> character) {
    fbb_.AddOffset(Reply_CreateCharacterSuccess::VT_CHARACTER, character);
  }
  Reply_CreateCharacterSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_CreateCharacterSuccessBuilder &operator=(const Reply_CreateCharacterSuccessBuilder &);
  flatbuffers::Offset<Reply_CreateCharacterSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_CreateCharacterSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_CreateCharacterSuccess> CreateReply_CreateCharacterSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Character> character = 0) {
  Reply_CreateCharacterSuccessBuilder builder_(_fbb);
  builder_.add_character(character);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_CreateCharacterSuccess> CreateReply_CreateCharacterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_DeleteCharacterT : public flatbuffers::NativeTable {
  typedef Request_DeleteCharacter TableType;
  int32_t character_id;
  Request_DeleteCharacterT()
      : character_id(0) {
  }
};

struct Request_DeleteCharacter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_DeleteCharacterT NativeTableType;
  enum {
    VT_CHARACTER_ID = 4
  };
  int32_t character_id() const {
    return GetField<int32_t>(VT_CHARACTER_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARACTER_ID) &&
           verifier.EndTable();
  }
  Request_DeleteCharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_DeleteCharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_DeleteCharacter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_DeleteCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_DeleteCharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character_id(int32_t character_id) {
    fbb_.AddElement<int32_t>(Request_DeleteCharacter::VT_CHARACTER_ID, character_id, 0);
  }
  Request_DeleteCharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_DeleteCharacterBuilder &operator=(const Request_DeleteCharacterBuilder &);
  flatbuffers::Offset<Request_DeleteCharacter> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Request_DeleteCharacter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_DeleteCharacter> CreateRequest_DeleteCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_id = 0) {
  Request_DeleteCharacterBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

flatbuffers::Offset<Request_DeleteCharacter> CreateRequest_DeleteCharacter(flatbuffers::FlatBufferBuilder &_fbb, const Request_DeleteCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_DeleteCharacterFailedT : public flatbuffers::NativeTable {
  typedef Reply_DeleteCharacterFailed TableType;
  protocol::ErrorCode error_code;
  Reply_DeleteCharacterFailedT()
      : error_code(protocol::ErrorCode::OK) {
  }
};

struct Reply_DeleteCharacterFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_DeleteCharacterFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  protocol::ErrorCode error_code() const {
    return static_cast<protocol::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_DeleteCharacterFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_DeleteCharacterFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_DeleteCharacterFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_DeleteCharacterFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(protocol::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_DeleteCharacterFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_DeleteCharacterFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_DeleteCharacterFailedBuilder &operator=(const Reply_DeleteCharacterFailedBuilder &);
  flatbuffers::Offset<Reply_DeleteCharacterFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_DeleteCharacterFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_DeleteCharacterFailed> CreateReply_DeleteCharacterFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    protocol::ErrorCode error_code = protocol::ErrorCode::OK) {
  Reply_DeleteCharacterFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_DeleteCharacterFailed> CreateReply_DeleteCharacterFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_DeleteCharacterSuccessT : public flatbuffers::NativeTable {
  typedef Reply_DeleteCharacterSuccess TableType;
  int32_t character_id;
  Reply_DeleteCharacterSuccessT()
      : character_id(0) {
  }
};

struct Reply_DeleteCharacterSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_DeleteCharacterSuccessT NativeTableType;
  enum {
    VT_CHARACTER_ID = 4
  };
  int32_t character_id() const {
    return GetField<int32_t>(VT_CHARACTER_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARACTER_ID) &&
           verifier.EndTable();
  }
  Reply_DeleteCharacterSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_DeleteCharacterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_DeleteCharacterSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_DeleteCharacterSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character_id(int32_t character_id) {
    fbb_.AddElement<int32_t>(Reply_DeleteCharacterSuccess::VT_CHARACTER_ID, character_id, 0);
  }
  Reply_DeleteCharacterSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_DeleteCharacterSuccessBuilder &operator=(const Reply_DeleteCharacterSuccessBuilder &);
  flatbuffers::Offset<Reply_DeleteCharacterSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_DeleteCharacterSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_DeleteCharacterSuccess> CreateReply_DeleteCharacterSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_id = 0) {
  Reply_DeleteCharacterSuccessBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_DeleteCharacterSuccess> CreateReply_DeleteCharacterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace login

namespace world {

struct PlayerCharacterT : public flatbuffers::NativeTable {
  typedef PlayerCharacter TableType;
  std::string uuid;
  std::string name;
  protocol::ClassType class_type;
  int32_t exp;
  int32_t level;
  int32_t max_hp;
  int32_t hp;
  int32_t max_mp;
  int32_t mp;
  int32_t att;
  int32_t def;
  std::unique_ptr<protocol::Vec3> pos;
  float rotation_y;
  PlayerCharacterT()
      : class_type(protocol::ClassType::NONE),
        exp(0),
        level(0),
        max_hp(0),
        hp(0),
        max_mp(0),
        mp(0),
        att(0),
        def(0),
        rotation_y(0.0f) {
  }
};

struct PlayerCharacter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerCharacterT NativeTableType;
  enum {
    VT_UUID = 4,
    VT_NAME = 6,
    VT_CLASS_TYPE = 8,
    VT_EXP = 10,
    VT_LEVEL = 12,
    VT_MAX_HP = 14,
    VT_HP = 16,
    VT_MAX_MP = 18,
    VT_MP = 20,
    VT_ATT = 22,
    VT_DEF = 24,
    VT_POS = 26,
    VT_ROTATION_Y = 28
  };
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  protocol::ClassType class_type() const {
    return static_cast<protocol::ClassType>(GetField<int32_t>(VT_CLASS_TYPE, 0));
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t max_hp() const {
    return GetField<int32_t>(VT_MAX_HP, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t max_mp() const {
    return GetField<int32_t>(VT_MAX_MP, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  int32_t att() const {
    return GetField<int32_t>(VT_ATT, 0);
  }
  int32_t def() const {
    return GetField<int32_t>(VT_DEF, 0);
  }
  const protocol::Vec3 *pos() const {
    return GetStruct<const protocol::Vec3 *>(VT_POS);
  }
  float rotation_y() const {
    return GetField<float>(VT_ROTATION_Y, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_MAX_HP) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MAX_MP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<int32_t>(verifier, VT_ATT) &&
           VerifyField<int32_t>(verifier, VT_DEF) &&
           VerifyField<protocol::Vec3>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_ROTATION_Y) &&
           verifier.EndTable();
  }
  PlayerCharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerCharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PlayerCharacter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerCharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(PlayerCharacter::VT_UUID, uuid);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PlayerCharacter::VT_NAME, name);
  }
  void add_class_type(protocol::ClassType class_type) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_CLASS_TYPE, static_cast<int32_t>(class_type), 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_EXP, exp, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_LEVEL, level, 0);
  }
  void add_max_hp(int32_t max_hp) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_MAX_HP, max_hp, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_HP, hp, 0);
  }
  void add_max_mp(int32_t max_mp) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_MAX_MP, max_mp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_MP, mp, 0);
  }
  void add_att(int32_t att) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_ATT, att, 0);
  }
  void add_def(int32_t def) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_DEF, def, 0);
  }
  void add_pos(const protocol::Vec3 *pos) {
    fbb_.AddStruct(PlayerCharacter::VT_POS, pos);
  }
  void add_rotation_y(float rotation_y) {
    fbb_.AddElement<float>(PlayerCharacter::VT_ROTATION_Y, rotation_y, 0.0f);
  }
  PlayerCharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerCharacterBuilder &operator=(const PlayerCharacterBuilder &);
  flatbuffers::Offset<PlayerCharacter> Finish() {
    const auto end = fbb_.EndTable(start_, 13);
    auto o = flatbuffers::Offset<PlayerCharacter>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerCharacter> CreatePlayerCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    protocol::ClassType class_type = protocol::ClassType::NONE,
    int32_t exp = 0,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    int32_t att = 0,
    int32_t def = 0,
    const protocol::Vec3 *pos = 0,
    float rotation_y = 0.0f) {
  PlayerCharacterBuilder builder_(_fbb);
  builder_.add_rotation_y(rotation_y);
  builder_.add_pos(pos);
  builder_.add_def(def);
  builder_.add_att(att);
  builder_.add_mp(mp);
  builder_.add_max_mp(max_mp);
  builder_.add_hp(hp);
  builder_.add_max_hp(max_hp);
  builder_.add_level(level);
  builder_.add_exp(exp);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerCharacter> CreatePlayerCharacterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uuid = nullptr,
    const char *name = nullptr,
    protocol::ClassType class_type = protocol::ClassType::NONE,
    int32_t exp = 0,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    int32_t att = 0,
    int32_t def = 0,
    const protocol::Vec3 *pos = 0,
    float rotation_y = 0.0f) {
  return protocol::world::CreatePlayerCharacter(
      _fbb,
      uuid ? _fbb.CreateString(uuid) : 0,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      exp,
      level,
      max_hp,
      hp,
      max_mp,
      mp,
      att,
      def,
      pos,
      rotation_y);
}

flatbuffers::Offset<PlayerCharacter> CreatePlayerCharacter(flatbuffers::FlatBufferBuilder &_fbb, const PlayerCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RemotePCT : public flatbuffers::NativeTable {
  typedef RemotePC TableType;
  std::string uuid;
  std::string name;
  protocol::ClassType class_type;
  int32_t level;
  int32_t max_hp;
  int32_t hp;
  int32_t max_mp;
  int32_t mp;
  std::unique_ptr<protocol::Vec3> pos;
  float rotation_y;
  RemotePCT()
      : class_type(protocol::ClassType::NONE),
        level(0),
        max_hp(0),
        hp(0),
        max_mp(0),
        mp(0),
        rotation_y(0.0f) {
  }
};

struct RemotePC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RemotePCT NativeTableType;
  enum {
    VT_UUID = 4,
    VT_NAME = 6,
    VT_CLASS_TYPE = 8,
    VT_LEVEL = 10,
    VT_MAX_HP = 12,
    VT_HP = 14,
    VT_MAX_MP = 16,
    VT_MP = 18,
    VT_POS = 20,
    VT_ROTATION_Y = 22
  };
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  protocol::ClassType class_type() const {
    return static_cast<protocol::ClassType>(GetField<int32_t>(VT_CLASS_TYPE, 0));
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t max_hp() const {
    return GetField<int32_t>(VT_MAX_HP, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t max_mp() const {
    return GetField<int32_t>(VT_MAX_MP, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  const protocol::Vec3 *pos() const {
    return GetStruct<const protocol::Vec3 *>(VT_POS);
  }
  float rotation_y() const {
    return GetField<float>(VT_ROTATION_Y, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_MAX_HP) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MAX_MP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<protocol::Vec3>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_ROTATION_Y) &&
           verifier.EndTable();
  }
  RemotePCT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RemotePCT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RemotePC> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemotePCT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RemotePCBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(RemotePC::VT_UUID, uuid);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RemotePC::VT_NAME, name);
  }
  void add_class_type(protocol::ClassType class_type) {
    fbb_.AddElement<int32_t>(RemotePC::VT_CLASS_TYPE, static_cast<int32_t>(class_type), 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(RemotePC::VT_LEVEL, level, 0);
  }
  void add_max_hp(int32_t max_hp) {
    fbb_.AddElement<int32_t>(RemotePC::VT_MAX_HP, max_hp, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(RemotePC::VT_HP, hp, 0);
  }
  void add_max_mp(int32_t max_mp) {
    fbb_.AddElement<int32_t>(RemotePC::VT_MAX_MP, max_mp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(RemotePC::VT_MP, mp, 0);
  }
  void add_pos(const protocol::Vec3 *pos) {
    fbb_.AddStruct(RemotePC::VT_POS, pos);
  }
  void add_rotation_y(float rotation_y) {
    fbb_.AddElement<float>(RemotePC::VT_ROTATION_Y, rotation_y, 0.0f);
  }
  RemotePCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemotePCBuilder &operator=(const RemotePCBuilder &);
  flatbuffers::Offset<RemotePC> Finish() {
    const auto end = fbb_.EndTable(start_, 10);
    auto o = flatbuffers::Offset<RemotePC>(end);
    return o;
  }
};

inline flatbuffers::Offset<RemotePC> CreateRemotePC(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    protocol::ClassType class_type = protocol::ClassType::NONE,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    const protocol::Vec3 *pos = 0,
    float rotation_y = 0.0f) {
  RemotePCBuilder builder_(_fbb);
  builder_.add_rotation_y(rotation_y);
  builder_.add_pos(pos);
  builder_.add_mp(mp);
  builder_.add_max_mp(max_mp);
  builder_.add_hp(hp);
  builder_.add_max_hp(max_hp);
  builder_.add_level(level);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

inline flatbuffers::Offset<RemotePC> CreateRemotePCDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uuid = nullptr,
    const char *name = nullptr,
    protocol::ClassType class_type = protocol::ClassType::NONE,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    const protocol::Vec3 *pos = 0,
    float rotation_y = 0.0f) {
  return protocol::world::CreateRemotePC(
      _fbb,
      uuid ? _fbb.CreateString(uuid) : 0,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      level,
      max_hp,
      hp,
      max_mp,
      mp,
      pos,
      rotation_y);
}

flatbuffers::Offset<RemotePC> CreateRemotePC(flatbuffers::FlatBufferBuilder &_fbb, const RemotePCT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MonsterT : public flatbuffers::NativeTable {
  typedef Monster TableType;
  std::string uuid;
  int32_t type_id;
  std::string name;
  int32_t level;
  int32_t max_hp;
  int32_t hp;
  int32_t max_mp;
  int32_t mp;
  std::unique_ptr<protocol::Vec3> pos;
  float rotation_y;
  MonsterT()
      : type_id(0),
        level(0),
        max_hp(0),
        hp(0),
        max_mp(0),
        mp(0),
        rotation_y(0.0f) {
  }
};

struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MonsterT NativeTableType;
  enum {
    VT_UUID = 4,
    VT_TYPE_ID = 6,
    VT_NAME = 8,
    VT_LEVEL = 10,
    VT_MAX_HP = 12,
    VT_HP = 14,
    VT_MAX_MP = 16,
    VT_MP = 18,
    VT_POS = 20,
    VT_ROTATION_Y = 22
  };
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  int32_t type_id() const {
    return GetField<int32_t>(VT_TYPE_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t max_hp() const {
    return GetField<int32_t>(VT_MAX_HP, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t max_mp() const {
    return GetField<int32_t>(VT_MAX_MP, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  const protocol::Vec3 *pos() const {
    return GetStruct<const protocol::Vec3 *>(VT_POS);
  }
  float rotation_y() const {
    return GetField<float>(VT_ROTATION_Y, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyField<int32_t>(verifier, VT_TYPE_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_MAX_HP) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MAX_MP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<protocol::Vec3>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_ROTATION_Y) &&
           verifier.EndTable();
  }
  MonsterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MonsterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Monster> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MonsterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Monster::VT_UUID, uuid);
  }
  void add_type_id(int32_t type_id) {
    fbb_.AddElement<int32_t>(Monster::VT_TYPE_ID, type_id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Monster::VT_NAME, name);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(Monster::VT_LEVEL, level, 0);
  }
  void add_max_hp(int32_t max_hp) {
    fbb_.AddElement<int32_t>(Monster::VT_MAX_HP, max_hp, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(Monster::VT_HP, hp, 0);
  }
  void add_max_mp(int32_t max_mp) {
    fbb_.AddElement<int32_t>(Monster::VT_MAX_MP, max_mp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(Monster::VT_MP, mp, 0);
  }
  void add_pos(const protocol::Vec3 *pos) {
    fbb_.AddStruct(Monster::VT_POS, pos);
  }
  void add_rotation_y(float rotation_y) {
    fbb_.AddElement<float>(Monster::VT_ROTATION_Y, rotation_y, 0.0f);
  }
  MonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MonsterBuilder &operator=(const MonsterBuilder &);
  flatbuffers::Offset<Monster> Finish() {
    const auto end = fbb_.EndTable(start_, 10);
    auto o = flatbuffers::Offset<Monster>(end);
    return o;
  }
};

inline flatbuffers::Offset<Monster> CreateMonster(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    int32_t type_id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    const protocol::Vec3 *pos = 0,
    float rotation_y = 0.0f) {
  MonsterBuilder builder_(_fbb);
  builder_.add_rotation_y(rotation_y);
  builder_.add_pos(pos);
  builder_.add_mp(mp);
  builder_.add_max_mp(max_mp);
  builder_.add_hp(hp);
  builder_.add_max_hp(max_hp);
  builder_.add_level(level);
  builder_.add_name(name);
  builder_.add_type_id(type_id);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Monster> CreateMonsterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uuid = nullptr,
    int32_t type_id = 0,
    const char *name = nullptr,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    const protocol::Vec3 *pos = 0,
    float rotation_y = 0.0f) {
  return protocol::world::CreateMonster(
      _fbb,
      uuid ? _fbb.CreateString(uuid) : 0,
      type_id,
      name ? _fbb.CreateString(name) : 0,
      level,
      max_hp,
      hp,
      max_mp,
      mp,
      pos,
      rotation_y);
}

flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HittingInfoT : public flatbuffers::NativeTable {
  typedef HittingInfo TableType;
  std::string uuid;
  int32_t damage;
  HittingInfoT()
      : damage(0) {
  }
};

struct HittingInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HittingInfoT NativeTableType;
  enum {
    VT_UUID = 4,
    VT_DAMAGE = 6
  };
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  int32_t damage() const {
    return GetField<int32_t>(VT_DAMAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyField<int32_t>(verifier, VT_DAMAGE) &&
           verifier.EndTable();
  }
  HittingInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HittingInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HittingInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HittingInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HittingInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(HittingInfo::VT_UUID, uuid);
  }
  void add_damage(int32_t damage) {
    fbb_.AddElement<int32_t>(HittingInfo::VT_DAMAGE, damage, 0);
  }
  HittingInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HittingInfoBuilder &operator=(const HittingInfoBuilder &);
  flatbuffers::Offset<HittingInfo> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<HittingInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<HittingInfo> CreateHittingInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    int32_t damage = 0) {
  HittingInfoBuilder builder_(_fbb);
  builder_.add_damage(damage);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

inline flatbuffers::Offset<HittingInfo> CreateHittingInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uuid = nullptr,
    int32_t damage = 0) {
  return protocol::world::CreateHittingInfo(
      _fbb,
      uuid ? _fbb.CreateString(uuid) : 0,
      damage);
}

flatbuffers::Offset<HittingInfo> CreateHittingInfo(flatbuffers::FlatBufferBuilder &_fbb, const HittingInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_EnterWorldT : public flatbuffers::NativeTable {
  typedef Request_EnterWorld TableType;
  int32_t character_id;
  Request_EnterWorldT()
      : character_id(0) {
  }
};

struct Request_EnterWorld FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_EnterWorldT NativeTableType;
  enum {
    VT_CHARACTER_ID = 4
  };
  int32_t character_id() const {
    return GetField<int32_t>(VT_CHARACTER_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARACTER_ID) &&
           verifier.EndTable();
  }
  Request_EnterWorldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_EnterWorldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_EnterWorld> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_EnterWorldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character_id(int32_t character_id) {
    fbb_.AddElement<int32_t>(Request_EnterWorld::VT_CHARACTER_ID, character_id, 0);
  }
  Request_EnterWorldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_EnterWorldBuilder &operator=(const Request_EnterWorldBuilder &);
  flatbuffers::Offset<Request_EnterWorld> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Request_EnterWorld>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_EnterWorld> CreateRequest_EnterWorld(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_id = 0) {
  Request_EnterWorldBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

flatbuffers::Offset<Request_EnterWorld> CreateRequest_EnterWorld(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_EnterWorldFailedT : public flatbuffers::NativeTable {
  typedef Reply_EnterWorldFailed TableType;
  protocol::ErrorCode error_code;
  Reply_EnterWorldFailedT()
      : error_code(protocol::ErrorCode::OK) {
  }
};

struct Reply_EnterWorldFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_EnterWorldFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  protocol::ErrorCode error_code() const {
    return static_cast<protocol::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_EnterWorldFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_EnterWorldFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_EnterWorldFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_EnterWorldFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(protocol::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_EnterWorldFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_EnterWorldFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_EnterWorldFailedBuilder &operator=(const Reply_EnterWorldFailedBuilder &);
  flatbuffers::Offset<Reply_EnterWorldFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_EnterWorldFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_EnterWorldFailed> CreateReply_EnterWorldFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    protocol::ErrorCode error_code = protocol::ErrorCode::OK) {
  Reply_EnterWorldFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_EnterWorldFailed> CreateReply_EnterWorldFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_EnterWorldSuccessT : public flatbuffers::NativeTable {
  typedef Reply_EnterWorldSuccess TableType;
  Reply_EnterWorldSuccessT() {
  }
};

struct Reply_EnterWorldSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_EnterWorldSuccessT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Reply_EnterWorldSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_EnterWorldSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_EnterWorldSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_EnterWorldSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Reply_EnterWorldSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_EnterWorldSuccessBuilder &operator=(const Reply_EnterWorldSuccessBuilder &);
  flatbuffers::Offset<Reply_EnterWorldSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Reply_EnterWorldSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_EnterWorldSuccess> CreateReply_EnterWorldSuccess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Reply_EnterWorldSuccessBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_EnterWorldSuccess> CreateReply_EnterWorldSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_WorldLogicErrorT : public flatbuffers::NativeTable {
  typedef Notify_WorldLogicError TableType;
  protocol::ErrorCode error_code;
  Notify_WorldLogicErrorT()
      : error_code(protocol::ErrorCode::OK) {
  }
};

struct Notify_WorldLogicError FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_WorldLogicErrorT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  protocol::ErrorCode error_code() const {
    return static_cast<protocol::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Notify_WorldLogicErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_WorldLogicErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_WorldLogicError> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_WorldLogicErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_WorldLogicErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(protocol::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Notify_WorldLogicError::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Notify_WorldLogicErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_WorldLogicErrorBuilder &operator=(const Notify_WorldLogicErrorBuilder &);
  flatbuffers::Offset<Notify_WorldLogicError> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Notify_WorldLogicError>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_WorldLogicError> CreateNotify_WorldLogicError(
    flatbuffers::FlatBufferBuilder &_fbb,
    protocol::ErrorCode error_code = protocol::ErrorCode::OK) {
  Notify_WorldLogicErrorBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Notify_WorldLogicError> CreateNotify_WorldLogicError(flatbuffers::FlatBufferBuilder &_fbb, const Notify_WorldLogicErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_EnterWorldNextT : public flatbuffers::NativeTable {
  typedef Request_EnterWorldNext TableType;
  Request_EnterWorldNextT() {
  }
};

struct Request_EnterWorldNext FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_EnterWorldNextT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_EnterWorldNextT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_EnterWorldNextT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_EnterWorldNext> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldNextT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_EnterWorldNextBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Request_EnterWorldNextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_EnterWorldNextBuilder &operator=(const Request_EnterWorldNextBuilder &);
  flatbuffers::Offset<Request_EnterWorldNext> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Request_EnterWorldNext>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_EnterWorldNext> CreateRequest_EnterWorldNext(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Request_EnterWorldNextBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Request_EnterWorldNext> CreateRequest_EnterWorldNext(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldNextT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_EnterWorldNextSuccessT : public flatbuffers::NativeTable {
  typedef Reply_EnterWorldNextSuccess TableType;
  std::unique_ptr<PlayerCharacterT> player_character;
  Reply_EnterWorldNextSuccessT() {
  }
};

struct Reply_EnterWorldNextSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_EnterWorldNextSuccessT NativeTableType;
  enum {
    VT_PLAYER_CHARACTER = 4
  };
  const PlayerCharacter *player_character() const {
    return GetPointer<const PlayerCharacter *>(VT_PLAYER_CHARACTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER_CHARACTER) &&
           verifier.VerifyTable(player_character()) &&
           verifier.EndTable();
  }
  Reply_EnterWorldNextSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_EnterWorldNextSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_EnterWorldNextSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_EnterWorldNextSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_character(flatbuffers::Offset<PlayerCharacter> player_character) {
    fbb_.AddOffset(Reply_EnterWorldNextSuccess::VT_PLAYER_CHARACTER, player_character);
  }
  Reply_EnterWorldNextSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_EnterWorldNextSuccessBuilder &operator=(const Reply_EnterWorldNextSuccessBuilder &);
  flatbuffers::Offset<Reply_EnterWorldNextSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_EnterWorldNextSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_EnterWorldNextSuccess> CreateReply_EnterWorldNextSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PlayerCharacter> player_character = 0) {
  Reply_EnterWorldNextSuccessBuilder builder_(_fbb);
  builder_.add_player_character(player_character);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_EnterWorldNextSuccess> CreateReply_EnterWorldNextSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_EnterWorldNextFailedT : public flatbuffers::NativeTable {
  typedef Reply_EnterWorldNextFailed TableType;
  protocol::ErrorCode error_code;
  Reply_EnterWorldNextFailedT()
      : error_code(protocol::ErrorCode::OK) {
  }
};

struct Reply_EnterWorldNextFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_EnterWorldNextFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  protocol::ErrorCode error_code() const {
    return static_cast<protocol::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_EnterWorldNextFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_EnterWorldNextFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_EnterWorldNextFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_EnterWorldNextFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(protocol::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_EnterWorldNextFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_EnterWorldNextFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_EnterWorldNextFailedBuilder &operator=(const Reply_EnterWorldNextFailedBuilder &);
  flatbuffers::Offset<Reply_EnterWorldNextFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_EnterWorldNextFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_EnterWorldNextFailed> CreateReply_EnterWorldNextFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    protocol::ErrorCode error_code = protocol::ErrorCode::OK) {
  Reply_EnterWorldNextFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_EnterWorldNextFailed> CreateReply_EnterWorldNextFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_EnterZoneT : public flatbuffers::NativeTable {
  typedef Notify_EnterZone TableType;
  int32_t map_id;
  std::unique_ptr<MoveInfo> move;
  Notify_EnterZoneT()
      : map_id(0) {
  }
};

struct Notify_EnterZone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_EnterZoneT NativeTableType;
  enum {
    VT_MAP_ID = 4,
    VT_MOVE = 6
  };
  int32_t map_id() const {
    return GetField<int32_t>(VT_MAP_ID, 0);
  }
  const MoveInfo *move() const {
    return GetStruct<const MoveInfo *>(VT_MOVE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAP_ID) &&
           VerifyField<MoveInfo>(verifier, VT_MOVE) &&
           verifier.EndTable();
  }
  Notify_EnterZoneT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_EnterZoneT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_EnterZone> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterZoneT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_EnterZoneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_map_id(int32_t map_id) {
    fbb_.AddElement<int32_t>(Notify_EnterZone::VT_MAP_ID, map_id, 0);
  }
  void add_move(const MoveInfo *move) {
    fbb_.AddStruct(Notify_EnterZone::VT_MOVE, move);
  }
  Notify_EnterZoneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_EnterZoneBuilder &operator=(const Notify_EnterZoneBuilder &);
  flatbuffers::Offset<Notify_EnterZone> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Notify_EnterZone>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_EnterZone> CreateNotify_EnterZone(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t map_id = 0,
    const MoveInfo *move = 0) {
  Notify_EnterZoneBuilder builder_(_fbb);
  builder_.add_move(move);
  builder_.add_map_id(map_id);
  return builder_.Finish();
}

flatbuffers::Offset<Notify_EnterZone> CreateNotify_EnterZone(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterZoneT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_MoveT : public flatbuffers::NativeTable {
  typedef Request_Move TableType;
  std::unique_ptr<MoveInfo> move;
  Request_MoveT() {
  }
};

struct Request_Move FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_MoveT NativeTableType;
  enum {
    VT_MOVE = 4
  };
  const MoveInfo *move() const {
    return GetStruct<const MoveInfo *>(VT_MOVE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<MoveInfo>(verifier, VT_MOVE) &&
           verifier.EndTable();
  }
  Request_MoveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_MoveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Move> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_MoveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_MoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_move(const MoveInfo *move) {
    fbb_.AddStruct(Request_Move::VT_MOVE, move);
  }
  Request_MoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_MoveBuilder &operator=(const Request_MoveBuilder &);
  flatbuffers::Offset<Request_Move> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Request_Move>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Move> CreateRequest_Move(
    flatbuffers::FlatBufferBuilder &_fbb,
    const MoveInfo *move = 0) {
  Request_MoveBuilder builder_(_fbb);
  builder_.add_move(move);
  return builder_.Finish();
}

flatbuffers::Offset<Request_Move> CreateRequest_Move(flatbuffers::FlatBufferBuilder &_fbb, const Request_MoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_AttackT : public flatbuffers::NativeTable {
  typedef Request_Attack TableType;
  float rotation;
  Request_AttackT()
      : rotation(0.0f) {
  }
};

struct Request_Attack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_AttackT NativeTableType;
  enum {
    VT_ROTATION = 4
  };
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  Request_AttackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_AttackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Attack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_AttackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_AttackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(Request_Attack::VT_ROTATION, rotation, 0.0f);
  }
  Request_AttackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_AttackBuilder &operator=(const Request_AttackBuilder &);
  flatbuffers::Offset<Request_Attack> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Request_Attack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Attack> CreateRequest_Attack(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rotation = 0.0f) {
  Request_AttackBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  return builder_.Finish();
}

flatbuffers::Offset<Request_Attack> CreateRequest_Attack(flatbuffers::FlatBufferBuilder &_fbb, const Request_AttackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_MoveT : public flatbuffers::NativeTable {
  typedef Notify_Move TableType;
  std::string uuid;
  std::unique_ptr<MoveInfo> move;
  Notify_MoveT() {
  }
};

struct Notify_Move FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_MoveT NativeTableType;
  enum {
    VT_UUID = 4,
    VT_MOVE = 6
  };
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  const MoveInfo *move() const {
    return GetStruct<const MoveInfo *>(VT_MOVE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyField<MoveInfo>(verifier, VT_MOVE) &&
           verifier.EndTable();
  }
  Notify_MoveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_MoveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_Move> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_MoveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_MoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Notify_Move::VT_UUID, uuid);
  }
  void add_move(const MoveInfo *move) {
    fbb_.AddStruct(Notify_Move::VT_MOVE, move);
  }
  Notify_MoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_MoveBuilder &operator=(const Notify_MoveBuilder &);
  flatbuffers::Offset<Notify_Move> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Notify_Move>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_Move> CreateNotify_Move(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    const MoveInfo *move = 0) {
  Notify_MoveBuilder builder_(_fbb);
  builder_.add_move(move);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_Move> CreateNotify_MoveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uuid = nullptr,
    const MoveInfo *move = 0) {
  return protocol::world::CreateNotify_Move(
      _fbb,
      uuid ? _fbb.CreateString(uuid) : 0,
      move);
}

flatbuffers::Offset<Notify_Move> CreateNotify_Move(flatbuffers::FlatBufferBuilder &_fbb, const Notify_MoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_AttackT : public flatbuffers::NativeTable {
  typedef Notify_Attack TableType;
  std::string uuid;
  float rotation;
  Notify_AttackT()
      : rotation(0.0f) {
  }
};

struct Notify_Attack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_AttackT NativeTableType;
  enum {
    VT_UUID = 4,
    VT_ROTATION = 6
  };
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  Notify_AttackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_AttackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_Attack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AttackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_AttackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Notify_Attack::VT_UUID, uuid);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(Notify_Attack::VT_ROTATION, rotation, 0.0f);
  }
  Notify_AttackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_AttackBuilder &operator=(const Notify_AttackBuilder &);
  flatbuffers::Offset<Notify_Attack> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Notify_Attack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_Attack> CreateNotify_Attack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    float rotation = 0.0f) {
  Notify_AttackBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_Attack> CreateNotify_AttackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uuid = nullptr,
    float rotation = 0.0f) {
  return protocol::world::CreateNotify_Attack(
      _fbb,
      uuid ? _fbb.CreateString(uuid) : 0,
      rotation);
}

flatbuffers::Offset<Notify_Attack> CreateNotify_Attack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AttackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_HitT : public flatbuffers::NativeTable {
  typedef Notify_Hit TableType;
  std::vector<std::unique_ptr<HittingInfoT>> hit_list;
  Notify_HitT() {
  }
};

struct Notify_Hit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_HitT NativeTableType;
  enum {
    VT_HIT_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<HittingInfo>> *hit_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HittingInfo>> *>(VT_HIT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HIT_LIST) &&
           verifier.Verify(hit_list()) &&
           verifier.VerifyVectorOfTables(hit_list()) &&
           verifier.EndTable();
  }
  Notify_HitT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_HitT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_Hit> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_HitT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_HitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hit_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HittingInfo>>> hit_list) {
    fbb_.AddOffset(Notify_Hit::VT_HIT_LIST, hit_list);
  }
  Notify_HitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_HitBuilder &operator=(const Notify_HitBuilder &);
  flatbuffers::Offset<Notify_Hit> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Notify_Hit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_Hit> CreateNotify_Hit(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HittingInfo>>> hit_list = 0) {
  Notify_HitBuilder builder_(_fbb);
  builder_.add_hit_list(hit_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_Hit> CreateNotify_HitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<HittingInfo>> *hit_list = nullptr) {
  return protocol::world::CreateNotify_Hit(
      _fbb,
      hit_list ? _fbb.CreateVector<flatbuffers::Offset<HittingInfo>>(*hit_list) : 0);
}

flatbuffers::Offset<Notify_Hit> CreateNotify_Hit(flatbuffers::FlatBufferBuilder &_fbb, const Notify_HitT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_AppearActorT : public flatbuffers::NativeTable {
  typedef Notify_AppearActor TableType;
  std::vector<std::unique_ptr<RemotePCT>> remote_pc;
  std::vector<std::unique_ptr<MonsterT>> monster;
  Notify_AppearActorT() {
  }
};

struct Notify_AppearActor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_AppearActorT NativeTableType;
  enum {
    VT_REMOTE_PC = 4,
    VT_MONSTER = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<RemotePC>> *remote_pc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RemotePC>> *>(VT_REMOTE_PC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Monster>> *monster() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Monster>> *>(VT_MONSTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REMOTE_PC) &&
           verifier.Verify(remote_pc()) &&
           verifier.VerifyVectorOfTables(remote_pc()) &&
           VerifyOffset(verifier, VT_MONSTER) &&
           verifier.Verify(monster()) &&
           verifier.VerifyVectorOfTables(monster()) &&
           verifier.EndTable();
  }
  Notify_AppearActorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_AppearActorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_AppearActor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AppearActorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_AppearActorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remote_pc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RemotePC>>> remote_pc) {
    fbb_.AddOffset(Notify_AppearActor::VT_REMOTE_PC, remote_pc);
  }
  void add_monster(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Monster>>> monster) {
    fbb_.AddOffset(Notify_AppearActor::VT_MONSTER, monster);
  }
  Notify_AppearActorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_AppearActorBuilder &operator=(const Notify_AppearActorBuilder &);
  flatbuffers::Offset<Notify_AppearActor> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Notify_AppearActor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_AppearActor> CreateNotify_AppearActor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RemotePC>>> remote_pc = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Monster>>> monster = 0) {
  Notify_AppearActorBuilder builder_(_fbb);
  builder_.add_monster(monster);
  builder_.add_remote_pc(remote_pc);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_AppearActor> CreateNotify_AppearActorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<RemotePC>> *remote_pc = nullptr,
    const std::vector<flatbuffers::Offset<Monster>> *monster = nullptr) {
  return protocol::world::CreateNotify_AppearActor(
      _fbb,
      remote_pc ? _fbb.CreateVector<flatbuffers::Offset<RemotePC>>(*remote_pc) : 0,
      monster ? _fbb.CreateVector<flatbuffers::Offset<Monster>>(*monster) : 0);
}

flatbuffers::Offset<Notify_AppearActor> CreateNotify_AppearActor(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AppearActorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_DisappearActorT : public flatbuffers::NativeTable {
  typedef Notify_DisappearActor TableType;
  std::vector<std::string> uuids;
  Notify_DisappearActorT() {
  }
};

struct Notify_DisappearActor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_DisappearActorT NativeTableType;
  enum {
    VT_UUIDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *uuids() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_UUIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUIDS) &&
           verifier.Verify(uuids()) &&
           verifier.VerifyVectorOfStrings(uuids()) &&
           verifier.EndTable();
  }
  Notify_DisappearActorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_DisappearActorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_DisappearActor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DisappearActorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_DisappearActorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> uuids) {
    fbb_.AddOffset(Notify_DisappearActor::VT_UUIDS, uuids);
  }
  Notify_DisappearActorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_DisappearActorBuilder &operator=(const Notify_DisappearActorBuilder &);
  flatbuffers::Offset<Notify_DisappearActor> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Notify_DisappearActor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_DisappearActor> CreateNotify_DisappearActor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> uuids = 0) {
  Notify_DisappearActorBuilder builder_(_fbb);
  builder_.add_uuids(uuids);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_DisappearActor> CreateNotify_DisappearActorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *uuids = nullptr) {
  return protocol::world::CreateNotify_DisappearActor(
      _fbb,
      uuids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*uuids) : 0);
}

flatbuffers::Offset<Notify_DisappearActor> CreateNotify_DisappearActor(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DisappearActorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace world

struct NetMessageT : public flatbuffers::NativeTable {
  typedef NetMessage TableType;
  MessageTUnion message;
  NetMessageT() {
  }
};

struct NetMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NetMessageT NativeTableType;
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  MessageT message_type() const {
    return static_cast<MessageT>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const protocol::Notify_UnauthedAccess *message_as_Notify_UnauthedAccess() const {
    return message_type() == MessageT::Notify_UnauthedAccess ? static_cast<const protocol::Notify_UnauthedAccess *>(message()) : nullptr;
  }
  const protocol::login::Request_Login *message_as_login_Request_Login() const {
    return message_type() == MessageT::login_Request_Login ? static_cast<const protocol::login::Request_Login *>(message()) : nullptr;
  }
  const protocol::login::Reply_LoginFailed *message_as_login_Reply_LoginFailed() const {
    return message_type() == MessageT::login_Reply_LoginFailed ? static_cast<const protocol::login::Reply_LoginFailed *>(message()) : nullptr;
  }
  const protocol::login::Reply_LoginSuccess *message_as_login_Reply_LoginSuccess() const {
    return message_type() == MessageT::login_Reply_LoginSuccess ? static_cast<const protocol::login::Reply_LoginSuccess *>(message()) : nullptr;
  }
  const protocol::login::Request_Join *message_as_login_Request_Join() const {
    return message_type() == MessageT::login_Request_Join ? static_cast<const protocol::login::Request_Join *>(message()) : nullptr;
  }
  const protocol::login::Reply_JoinFailed *message_as_login_Reply_JoinFailed() const {
    return message_type() == MessageT::login_Reply_JoinFailed ? static_cast<const protocol::login::Reply_JoinFailed *>(message()) : nullptr;
  }
  const protocol::login::Reply_JoinSuccess *message_as_login_Reply_JoinSuccess() const {
    return message_type() == MessageT::login_Reply_JoinSuccess ? static_cast<const protocol::login::Reply_JoinSuccess *>(message()) : nullptr;
  }
  const protocol::login::Request_CharacterList *message_as_login_Request_CharacterList() const {
    return message_type() == MessageT::login_Request_CharacterList ? static_cast<const protocol::login::Request_CharacterList *>(message()) : nullptr;
  }
  const protocol::login::Reply_CharacterList *message_as_login_Reply_CharacterList() const {
    return message_type() == MessageT::login_Reply_CharacterList ? static_cast<const protocol::login::Reply_CharacterList *>(message()) : nullptr;
  }
  const protocol::login::Request_CreateCharacter *message_as_login_Request_CreateCharacter() const {
    return message_type() == MessageT::login_Request_CreateCharacter ? static_cast<const protocol::login::Request_CreateCharacter *>(message()) : nullptr;
  }
  const protocol::login::Reply_CreateCharacterFailed *message_as_login_Reply_CreateCharacterFailed() const {
    return message_type() == MessageT::login_Reply_CreateCharacterFailed ? static_cast<const protocol::login::Reply_CreateCharacterFailed *>(message()) : nullptr;
  }
  const protocol::login::Reply_CreateCharacterSuccess *message_as_login_Reply_CreateCharacterSuccess() const {
    return message_type() == MessageT::login_Reply_CreateCharacterSuccess ? static_cast<const protocol::login::Reply_CreateCharacterSuccess *>(message()) : nullptr;
  }
  const protocol::login::Request_DeleteCharacter *message_as_login_Request_DeleteCharacter() const {
    return message_type() == MessageT::login_Request_DeleteCharacter ? static_cast<const protocol::login::Request_DeleteCharacter *>(message()) : nullptr;
  }
  const protocol::login::Reply_DeleteCharacterFailed *message_as_login_Reply_DeleteCharacterFailed() const {
    return message_type() == MessageT::login_Reply_DeleteCharacterFailed ? static_cast<const protocol::login::Reply_DeleteCharacterFailed *>(message()) : nullptr;
  }
  const protocol::login::Reply_DeleteCharacterSuccess *message_as_login_Reply_DeleteCharacterSuccess() const {
    return message_type() == MessageT::login_Reply_DeleteCharacterSuccess ? static_cast<const protocol::login::Reply_DeleteCharacterSuccess *>(message()) : nullptr;
  }
  const protocol::world::Request_EnterWorld *message_as_world_Request_EnterWorld() const {
    return message_type() == MessageT::world_Request_EnterWorld ? static_cast<const protocol::world::Request_EnterWorld *>(message()) : nullptr;
  }
  const protocol::world::Reply_EnterWorldFailed *message_as_world_Reply_EnterWorldFailed() const {
    return message_type() == MessageT::world_Reply_EnterWorldFailed ? static_cast<const protocol::world::Reply_EnterWorldFailed *>(message()) : nullptr;
  }
  const protocol::world::Reply_EnterWorldSuccess *message_as_world_Reply_EnterWorldSuccess() const {
    return message_type() == MessageT::world_Reply_EnterWorldSuccess ? static_cast<const protocol::world::Reply_EnterWorldSuccess *>(message()) : nullptr;
  }
  const protocol::world::Request_EnterWorldNext *message_as_world_Request_EnterWorldNext() const {
    return message_type() == MessageT::world_Request_EnterWorldNext ? static_cast<const protocol::world::Request_EnterWorldNext *>(message()) : nullptr;
  }
  const protocol::world::Reply_EnterWorldNextFailed *message_as_world_Reply_EnterWorldNextFailed() const {
    return message_type() == MessageT::world_Reply_EnterWorldNextFailed ? static_cast<const protocol::world::Reply_EnterWorldNextFailed *>(message()) : nullptr;
  }
  const protocol::world::Reply_EnterWorldNextSuccess *message_as_world_Reply_EnterWorldNextSuccess() const {
    return message_type() == MessageT::world_Reply_EnterWorldNextSuccess ? static_cast<const protocol::world::Reply_EnterWorldNextSuccess *>(message()) : nullptr;
  }
  const protocol::world::Notify_WorldLogicError *message_as_world_Notify_WorldLogicError() const {
    return message_type() == MessageT::world_Notify_WorldLogicError ? static_cast<const protocol::world::Notify_WorldLogicError *>(message()) : nullptr;
  }
  const protocol::world::Notify_EnterZone *message_as_world_Notify_EnterZone() const {
    return message_type() == MessageT::world_Notify_EnterZone ? static_cast<const protocol::world::Notify_EnterZone *>(message()) : nullptr;
  }
  const protocol::world::Notify_AppearActor *message_as_world_Notify_AppearActor() const {
    return message_type() == MessageT::world_Notify_AppearActor ? static_cast<const protocol::world::Notify_AppearActor *>(message()) : nullptr;
  }
  const protocol::world::Notify_DisappearActor *message_as_world_Notify_DisappearActor() const {
    return message_type() == MessageT::world_Notify_DisappearActor ? static_cast<const protocol::world::Notify_DisappearActor *>(message()) : nullptr;
  }
  const protocol::world::Request_Move *message_as_world_Request_Move() const {
    return message_type() == MessageT::world_Request_Move ? static_cast<const protocol::world::Request_Move *>(message()) : nullptr;
  }
  const protocol::world::Request_Attack *message_as_world_Request_Attack() const {
    return message_type() == MessageT::world_Request_Attack ? static_cast<const protocol::world::Request_Attack *>(message()) : nullptr;
  }
  const protocol::world::Notify_Move *message_as_world_Notify_Move() const {
    return message_type() == MessageT::world_Notify_Move ? static_cast<const protocol::world::Notify_Move *>(message()) : nullptr;
  }
  const protocol::world::Notify_Attack *message_as_world_Notify_Attack() const {
    return message_type() == MessageT::world_Notify_Attack ? static_cast<const protocol::world::Notify_Attack *>(message()) : nullptr;
  }
  const protocol::world::Notify_Hit *message_as_world_Notify_Hit() const {
    return message_type() == MessageT::world_Notify_Hit ? static_cast<const protocol::world::Notify_Hit *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessageT(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
  NetMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NetMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NetMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const protocol::Notify_UnauthedAccess *NetMessage::message_as<protocol::Notify_UnauthedAccess>() const {
  return message_as_Notify_UnauthedAccess();
}

template<> inline const protocol::login::Request_Login *NetMessage::message_as<protocol::login::Request_Login>() const {
  return message_as_login_Request_Login();
}

template<> inline const protocol::login::Reply_LoginFailed *NetMessage::message_as<protocol::login::Reply_LoginFailed>() const {
  return message_as_login_Reply_LoginFailed();
}

template<> inline const protocol::login::Reply_LoginSuccess *NetMessage::message_as<protocol::login::Reply_LoginSuccess>() const {
  return message_as_login_Reply_LoginSuccess();
}

template<> inline const protocol::login::Request_Join *NetMessage::message_as<protocol::login::Request_Join>() const {
  return message_as_login_Request_Join();
}

template<> inline const protocol::login::Reply_JoinFailed *NetMessage::message_as<protocol::login::Reply_JoinFailed>() const {
  return message_as_login_Reply_JoinFailed();
}

template<> inline const protocol::login::Reply_JoinSuccess *NetMessage::message_as<protocol::login::Reply_JoinSuccess>() const {
  return message_as_login_Reply_JoinSuccess();
}

template<> inline const protocol::login::Request_CharacterList *NetMessage::message_as<protocol::login::Request_CharacterList>() const {
  return message_as_login_Request_CharacterList();
}

template<> inline const protocol::login::Reply_CharacterList *NetMessage::message_as<protocol::login::Reply_CharacterList>() const {
  return message_as_login_Reply_CharacterList();
}

template<> inline const protocol::login::Request_CreateCharacter *NetMessage::message_as<protocol::login::Request_CreateCharacter>() const {
  return message_as_login_Request_CreateCharacter();
}

template<> inline const protocol::login::Reply_CreateCharacterFailed *NetMessage::message_as<protocol::login::Reply_CreateCharacterFailed>() const {
  return message_as_login_Reply_CreateCharacterFailed();
}

template<> inline const protocol::login::Reply_CreateCharacterSuccess *NetMessage::message_as<protocol::login::Reply_CreateCharacterSuccess>() const {
  return message_as_login_Reply_CreateCharacterSuccess();
}

template<> inline const protocol::login::Request_DeleteCharacter *NetMessage::message_as<protocol::login::Request_DeleteCharacter>() const {
  return message_as_login_Request_DeleteCharacter();
}

template<> inline const protocol::login::Reply_DeleteCharacterFailed *NetMessage::message_as<protocol::login::Reply_DeleteCharacterFailed>() const {
  return message_as_login_Reply_DeleteCharacterFailed();
}

template<> inline const protocol::login::Reply_DeleteCharacterSuccess *NetMessage::message_as<protocol::login::Reply_DeleteCharacterSuccess>() const {
  return message_as_login_Reply_DeleteCharacterSuccess();
}

template<> inline const protocol::world::Request_EnterWorld *NetMessage::message_as<protocol::world::Request_EnterWorld>() const {
  return message_as_world_Request_EnterWorld();
}

template<> inline const protocol::world::Reply_EnterWorldFailed *NetMessage::message_as<protocol::world::Reply_EnterWorldFailed>() const {
  return message_as_world_Reply_EnterWorldFailed();
}

template<> inline const protocol::world::Reply_EnterWorldSuccess *NetMessage::message_as<protocol::world::Reply_EnterWorldSuccess>() const {
  return message_as_world_Reply_EnterWorldSuccess();
}

template<> inline const protocol::world::Request_EnterWorldNext *NetMessage::message_as<protocol::world::Request_EnterWorldNext>() const {
  return message_as_world_Request_EnterWorldNext();
}

template<> inline const protocol::world::Reply_EnterWorldNextFailed *NetMessage::message_as<protocol::world::Reply_EnterWorldNextFailed>() const {
  return message_as_world_Reply_EnterWorldNextFailed();
}

template<> inline const protocol::world::Reply_EnterWorldNextSuccess *NetMessage::message_as<protocol::world::Reply_EnterWorldNextSuccess>() const {
  return message_as_world_Reply_EnterWorldNextSuccess();
}

template<> inline const protocol::world::Notify_WorldLogicError *NetMessage::message_as<protocol::world::Notify_WorldLogicError>() const {
  return message_as_world_Notify_WorldLogicError();
}

template<> inline const protocol::world::Notify_EnterZone *NetMessage::message_as<protocol::world::Notify_EnterZone>() const {
  return message_as_world_Notify_EnterZone();
}

template<> inline const protocol::world::Notify_AppearActor *NetMessage::message_as<protocol::world::Notify_AppearActor>() const {
  return message_as_world_Notify_AppearActor();
}

template<> inline const protocol::world::Notify_DisappearActor *NetMessage::message_as<protocol::world::Notify_DisappearActor>() const {
  return message_as_world_Notify_DisappearActor();
}

template<> inline const protocol::world::Request_Move *NetMessage::message_as<protocol::world::Request_Move>() const {
  return message_as_world_Request_Move();
}

template<> inline const protocol::world::Request_Attack *NetMessage::message_as<protocol::world::Request_Attack>() const {
  return message_as_world_Request_Attack();
}

template<> inline const protocol::world::Notify_Move *NetMessage::message_as<protocol::world::Notify_Move>() const {
  return message_as_world_Notify_Move();
}

template<> inline const protocol::world::Notify_Attack *NetMessage::message_as<protocol::world::Notify_Attack>() const {
  return message_as_world_Notify_Attack();
}

template<> inline const protocol::world::Notify_Hit *NetMessage::message_as<protocol::world::Notify_Hit>() const {
  return message_as_world_Notify_Hit();
}

struct NetMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(MessageT message_type) {
    fbb_.AddElement<uint8_t>(NetMessage::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(NetMessage::VT_MESSAGE, message);
  }
  NetMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NetMessageBuilder &operator=(const NetMessageBuilder &);
  flatbuffers::Offset<NetMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<NetMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetMessage> CreateNetMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    MessageT message_type = MessageT::NONE,
    flatbuffers::Offset<void> message = 0) {
  NetMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

flatbuffers::Offset<NetMessage> CreateNetMessage(flatbuffers::FlatBufferBuilder &_fbb, const NetMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Notify_UnauthedAccessT *Notify_UnauthedAccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_UnauthedAccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_UnauthedAccess::UnPackTo(Notify_UnauthedAccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Notify_UnauthedAccess> Notify_UnauthedAccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_UnauthedAccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_UnauthedAccess> CreateNotify_UnauthedAccess(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return protocol::CreateNotify_UnauthedAccess(
      _fbb);
}

namespace login {

inline CharacterT *Character::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Character::UnPackTo(CharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = level(); _o->level = _e; };
}

inline flatbuffers::Offset<Character> Character::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Character> CreateCharacter(flatbuffers::FlatBufferBuilder &_fbb, const CharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _id = _o->id;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _level = _o->level;
  return protocol::login::CreateCharacter(
      _fbb,
      _id,
      _name,
      _class_type,
      _level);
}

inline Request_LoginT *Request_Login::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_LoginT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Login::UnPackTo(Request_LoginT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = acc_name(); if (_e) _o->acc_name = _e->str(); };
  { auto _e = password(); if (_e) _o->password = _e->str(); };
}

inline flatbuffers::Offset<Request_Login> Request_Login::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Login(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Login> CreateRequest_Login(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _acc_name = _o->acc_name.size() ? _fbb.CreateString(_o->acc_name) : 0;
  auto _password = _o->password.size() ? _fbb.CreateString(_o->password) : 0;
  return protocol::login::CreateRequest_Login(
      _fbb,
      _acc_name,
      _password);
}

inline Reply_LoginFailedT *Reply_LoginFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_LoginFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_LoginFailed::UnPackTo(Reply_LoginFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_LoginFailed> Reply_LoginFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_LoginFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_LoginFailed> CreateReply_LoginFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return protocol::login::CreateReply_LoginFailed(
      _fbb,
      _error_code);
}

inline Reply_LoginSuccessT *Reply_LoginSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_LoginSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_LoginSuccess::UnPackTo(Reply_LoginSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = auth_key(); if (_e) _o->auth_key = _e->str(); };
}

inline flatbuffers::Offset<Reply_LoginSuccess> Reply_LoginSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_LoginSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _auth_key = _o->auth_key.size() ? _fbb.CreateString(_o->auth_key) : 0;
  return protocol::login::CreateReply_LoginSuccess(
      _fbb,
      _auth_key);
}

inline Request_JoinT *Request_Join::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_JoinT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Join::UnPackTo(Request_JoinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = acc_name(); if (_e) _o->acc_name = _e->str(); };
  { auto _e = password(); if (_e) _o->password = _e->str(); };
}

inline flatbuffers::Offset<Request_Join> Request_Join::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_JoinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Join(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Join> CreateRequest_Join(flatbuffers::FlatBufferBuilder &_fbb, const Request_JoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _acc_name = _o->acc_name.size() ? _fbb.CreateString(_o->acc_name) : 0;
  auto _password = _o->password.size() ? _fbb.CreateString(_o->password) : 0;
  return protocol::login::CreateRequest_Join(
      _fbb,
      _acc_name,
      _password);
}

inline Reply_JoinFailedT *Reply_JoinFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_JoinFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_JoinFailed::UnPackTo(Reply_JoinFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_JoinFailed> Reply_JoinFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_JoinFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_JoinFailed> CreateReply_JoinFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return protocol::login::CreateReply_JoinFailed(
      _fbb,
      _error_code);
}

inline Reply_JoinSuccessT *Reply_JoinSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_JoinSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_JoinSuccess::UnPackTo(Reply_JoinSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Reply_JoinSuccess> Reply_JoinSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_JoinSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_JoinSuccess> CreateReply_JoinSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return protocol::login::CreateReply_JoinSuccess(
      _fbb);
}

inline Request_CharacterListT *Request_CharacterList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_CharacterListT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_CharacterList::UnPackTo(Request_CharacterListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Request_CharacterList> Request_CharacterList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_CharacterListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_CharacterList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_CharacterList> CreateRequest_CharacterList(flatbuffers::FlatBufferBuilder &_fbb, const Request_CharacterListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return protocol::login::CreateRequest_CharacterList(
      _fbb);
}

inline Reply_CharacterListT *Reply_CharacterList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_CharacterListT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_CharacterList::UnPackTo(Reply_CharacterListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = list(); if (_e) { _o->list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->list[_i] = std::unique_ptr<CharacterT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Reply_CharacterList> Reply_CharacterList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CharacterListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_CharacterList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_CharacterList> CreateReply_CharacterList(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CharacterListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _list = _o->list.size() ? _fbb.CreateVector<flatbuffers::Offset<Character>>(_o->list.size(), [&](size_t i) { return CreateCharacter(_fbb, _o->list[i].get(), _rehasher); }) : 0;
  return protocol::login::CreateReply_CharacterList(
      _fbb,
      _list);
}

inline Request_CreateCharacterT *Request_CreateCharacter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_CreateCharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_CreateCharacter::UnPackTo(Request_CreateCharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
}

inline flatbuffers::Offset<Request_CreateCharacter> Request_CreateCharacter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_CreateCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_CreateCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_CreateCharacter> CreateRequest_CreateCharacter(flatbuffers::FlatBufferBuilder &_fbb, const Request_CreateCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  return protocol::login::CreateRequest_CreateCharacter(
      _fbb,
      _name,
      _class_type);
}

inline Reply_CreateCharacterFailedT *Reply_CreateCharacterFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_CreateCharacterFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_CreateCharacterFailed::UnPackTo(Reply_CreateCharacterFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_CreateCharacterFailed> Reply_CreateCharacterFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_CreateCharacterFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_CreateCharacterFailed> CreateReply_CreateCharacterFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return protocol::login::CreateReply_CreateCharacterFailed(
      _fbb,
      _error_code);
}

inline Reply_CreateCharacterSuccessT *Reply_CreateCharacterSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_CreateCharacterSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_CreateCharacterSuccess::UnPackTo(Reply_CreateCharacterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character(); if (_e) _o->character = std::unique_ptr<CharacterT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Reply_CreateCharacterSuccess> Reply_CreateCharacterSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_CreateCharacterSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_CreateCharacterSuccess> CreateReply_CreateCharacterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character = _o->character ? CreateCharacter(_fbb, _o->character.get(), _rehasher) : 0;
  return protocol::login::CreateReply_CreateCharacterSuccess(
      _fbb,
      _character);
}

inline Request_DeleteCharacterT *Request_DeleteCharacter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_DeleteCharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_DeleteCharacter::UnPackTo(Request_DeleteCharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character_id(); _o->character_id = _e; };
}

inline flatbuffers::Offset<Request_DeleteCharacter> Request_DeleteCharacter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_DeleteCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_DeleteCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_DeleteCharacter> CreateRequest_DeleteCharacter(flatbuffers::FlatBufferBuilder &_fbb, const Request_DeleteCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character_id = _o->character_id;
  return protocol::login::CreateRequest_DeleteCharacter(
      _fbb,
      _character_id);
}

inline Reply_DeleteCharacterFailedT *Reply_DeleteCharacterFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_DeleteCharacterFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_DeleteCharacterFailed::UnPackTo(Reply_DeleteCharacterFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_DeleteCharacterFailed> Reply_DeleteCharacterFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_DeleteCharacterFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_DeleteCharacterFailed> CreateReply_DeleteCharacterFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return protocol::login::CreateReply_DeleteCharacterFailed(
      _fbb,
      _error_code);
}

inline Reply_DeleteCharacterSuccessT *Reply_DeleteCharacterSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_DeleteCharacterSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_DeleteCharacterSuccess::UnPackTo(Reply_DeleteCharacterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character_id(); _o->character_id = _e; };
}

inline flatbuffers::Offset<Reply_DeleteCharacterSuccess> Reply_DeleteCharacterSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_DeleteCharacterSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_DeleteCharacterSuccess> CreateReply_DeleteCharacterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character_id = _o->character_id;
  return protocol::login::CreateReply_DeleteCharacterSuccess(
      _fbb,
      _character_id);
}

}  // namespace login

namespace world {

inline PlayerCharacterT *PlayerCharacter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PlayerCharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PlayerCharacter::UnPackTo(PlayerCharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); if (_e) _o->uuid = _e->str(); };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = exp(); _o->exp = _e; };
  { auto _e = level(); _o->level = _e; };
  { auto _e = max_hp(); _o->max_hp = _e; };
  { auto _e = hp(); _o->hp = _e; };
  { auto _e = max_mp(); _o->max_mp = _e; };
  { auto _e = mp(); _o->mp = _e; };
  { auto _e = att(); _o->att = _e; };
  { auto _e = def(); _o->def = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<protocol::Vec3>(new protocol::Vec3(*_e)); };
  { auto _e = rotation_y(); _o->rotation_y = _e; };
}

inline flatbuffers::Offset<PlayerCharacter> PlayerCharacter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayerCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PlayerCharacter> CreatePlayerCharacter(flatbuffers::FlatBufferBuilder &_fbb, const PlayerCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uuid = _o->uuid.size() ? _fbb.CreateString(_o->uuid) : 0;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _exp = _o->exp;
  auto _level = _o->level;
  auto _max_hp = _o->max_hp;
  auto _hp = _o->hp;
  auto _max_mp = _o->max_mp;
  auto _mp = _o->mp;
  auto _att = _o->att;
  auto _def = _o->def;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _rotation_y = _o->rotation_y;
  return protocol::world::CreatePlayerCharacter(
      _fbb,
      _uuid,
      _name,
      _class_type,
      _exp,
      _level,
      _max_hp,
      _hp,
      _max_mp,
      _mp,
      _att,
      _def,
      _pos,
      _rotation_y);
}

inline RemotePCT *RemotePC::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RemotePCT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RemotePC::UnPackTo(RemotePCT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); if (_e) _o->uuid = _e->str(); };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = level(); _o->level = _e; };
  { auto _e = max_hp(); _o->max_hp = _e; };
  { auto _e = hp(); _o->hp = _e; };
  { auto _e = max_mp(); _o->max_mp = _e; };
  { auto _e = mp(); _o->mp = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<protocol::Vec3>(new protocol::Vec3(*_e)); };
  { auto _e = rotation_y(); _o->rotation_y = _e; };
}

inline flatbuffers::Offset<RemotePC> RemotePC::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemotePCT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRemotePC(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RemotePC> CreateRemotePC(flatbuffers::FlatBufferBuilder &_fbb, const RemotePCT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uuid = _o->uuid.size() ? _fbb.CreateString(_o->uuid) : 0;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _level = _o->level;
  auto _max_hp = _o->max_hp;
  auto _hp = _o->hp;
  auto _max_mp = _o->max_mp;
  auto _mp = _o->mp;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _rotation_y = _o->rotation_y;
  return protocol::world::CreateRemotePC(
      _fbb,
      _uuid,
      _name,
      _class_type,
      _level,
      _max_hp,
      _hp,
      _max_mp,
      _mp,
      _pos,
      _rotation_y);
}

inline MonsterT *Monster::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MonsterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Monster::UnPackTo(MonsterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); if (_e) _o->uuid = _e->str(); };
  { auto _e = type_id(); _o->type_id = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = max_hp(); _o->max_hp = _e; };
  { auto _e = hp(); _o->hp = _e; };
  { auto _e = max_mp(); _o->max_mp = _e; };
  { auto _e = mp(); _o->mp = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<protocol::Vec3>(new protocol::Vec3(*_e)); };
  { auto _e = rotation_y(); _o->rotation_y = _e; };
}

inline flatbuffers::Offset<Monster> Monster::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMonster(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uuid = _o->uuid.size() ? _fbb.CreateString(_o->uuid) : 0;
  auto _type_id = _o->type_id;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _level = _o->level;
  auto _max_hp = _o->max_hp;
  auto _hp = _o->hp;
  auto _max_mp = _o->max_mp;
  auto _mp = _o->mp;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _rotation_y = _o->rotation_y;
  return protocol::world::CreateMonster(
      _fbb,
      _uuid,
      _type_id,
      _name,
      _level,
      _max_hp,
      _hp,
      _max_mp,
      _mp,
      _pos,
      _rotation_y);
}

inline HittingInfoT *HittingInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HittingInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HittingInfo::UnPackTo(HittingInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); if (_e) _o->uuid = _e->str(); };
  { auto _e = damage(); _o->damage = _e; };
}

inline flatbuffers::Offset<HittingInfo> HittingInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HittingInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHittingInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HittingInfo> CreateHittingInfo(flatbuffers::FlatBufferBuilder &_fbb, const HittingInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uuid = _o->uuid.size() ? _fbb.CreateString(_o->uuid) : 0;
  auto _damage = _o->damage;
  return protocol::world::CreateHittingInfo(
      _fbb,
      _uuid,
      _damage);
}

inline Request_EnterWorldT *Request_EnterWorld::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_EnterWorldT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_EnterWorld::UnPackTo(Request_EnterWorldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character_id(); _o->character_id = _e; };
}

inline flatbuffers::Offset<Request_EnterWorld> Request_EnterWorld::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_EnterWorld(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_EnterWorld> CreateRequest_EnterWorld(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character_id = _o->character_id;
  return protocol::world::CreateRequest_EnterWorld(
      _fbb,
      _character_id);
}

inline Reply_EnterWorldFailedT *Reply_EnterWorldFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_EnterWorldFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_EnterWorldFailed::UnPackTo(Reply_EnterWorldFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_EnterWorldFailed> Reply_EnterWorldFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_EnterWorldFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_EnterWorldFailed> CreateReply_EnterWorldFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return protocol::world::CreateReply_EnterWorldFailed(
      _fbb,
      _error_code);
}

inline Reply_EnterWorldSuccessT *Reply_EnterWorldSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_EnterWorldSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_EnterWorldSuccess::UnPackTo(Reply_EnterWorldSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Reply_EnterWorldSuccess> Reply_EnterWorldSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_EnterWorldSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_EnterWorldSuccess> CreateReply_EnterWorldSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return protocol::world::CreateReply_EnterWorldSuccess(
      _fbb);
}

inline Notify_WorldLogicErrorT *Notify_WorldLogicError::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_WorldLogicErrorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_WorldLogicError::UnPackTo(Notify_WorldLogicErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Notify_WorldLogicError> Notify_WorldLogicError::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_WorldLogicErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_WorldLogicError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_WorldLogicError> CreateNotify_WorldLogicError(flatbuffers::FlatBufferBuilder &_fbb, const Notify_WorldLogicErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return protocol::world::CreateNotify_WorldLogicError(
      _fbb,
      _error_code);
}

inline Request_EnterWorldNextT *Request_EnterWorldNext::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_EnterWorldNextT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_EnterWorldNext::UnPackTo(Request_EnterWorldNextT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Request_EnterWorldNext> Request_EnterWorldNext::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldNextT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_EnterWorldNext(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_EnterWorldNext> CreateRequest_EnterWorldNext(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldNextT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return protocol::world::CreateRequest_EnterWorldNext(
      _fbb);
}

inline Reply_EnterWorldNextSuccessT *Reply_EnterWorldNextSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_EnterWorldNextSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_EnterWorldNextSuccess::UnPackTo(Reply_EnterWorldNextSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player_character(); if (_e) _o->player_character = std::unique_ptr<PlayerCharacterT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Reply_EnterWorldNextSuccess> Reply_EnterWorldNextSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_EnterWorldNextSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_EnterWorldNextSuccess> CreateReply_EnterWorldNextSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _player_character = _o->player_character ? CreatePlayerCharacter(_fbb, _o->player_character.get(), _rehasher) : 0;
  return protocol::world::CreateReply_EnterWorldNextSuccess(
      _fbb,
      _player_character);
}

inline Reply_EnterWorldNextFailedT *Reply_EnterWorldNextFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_EnterWorldNextFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_EnterWorldNextFailed::UnPackTo(Reply_EnterWorldNextFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_EnterWorldNextFailed> Reply_EnterWorldNextFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_EnterWorldNextFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_EnterWorldNextFailed> CreateReply_EnterWorldNextFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return protocol::world::CreateReply_EnterWorldNextFailed(
      _fbb,
      _error_code);
}

inline Notify_EnterZoneT *Notify_EnterZone::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_EnterZoneT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_EnterZone::UnPackTo(Notify_EnterZoneT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = map_id(); _o->map_id = _e; };
  { auto _e = move(); if (_e) _o->move = std::unique_ptr<MoveInfo>(new MoveInfo(*_e)); };
}

inline flatbuffers::Offset<Notify_EnterZone> Notify_EnterZone::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterZoneT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_EnterZone(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_EnterZone> CreateNotify_EnterZone(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterZoneT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _map_id = _o->map_id;
  auto _move = _o->move ? _o->move.get() : 0;
  return protocol::world::CreateNotify_EnterZone(
      _fbb,
      _map_id,
      _move);
}

inline Request_MoveT *Request_Move::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_MoveT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Move::UnPackTo(Request_MoveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = move(); if (_e) _o->move = std::unique_ptr<MoveInfo>(new MoveInfo(*_e)); };
}

inline flatbuffers::Offset<Request_Move> Request_Move::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_MoveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Move> CreateRequest_Move(flatbuffers::FlatBufferBuilder &_fbb, const Request_MoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _move = _o->move ? _o->move.get() : 0;
  return protocol::world::CreateRequest_Move(
      _fbb,
      _move);
}

inline Request_AttackT *Request_Attack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_AttackT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Attack::UnPackTo(Request_AttackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rotation(); _o->rotation = _e; };
}

inline flatbuffers::Offset<Request_Attack> Request_Attack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_AttackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Attack(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Attack> CreateRequest_Attack(flatbuffers::FlatBufferBuilder &_fbb, const Request_AttackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _rotation = _o->rotation;
  return protocol::world::CreateRequest_Attack(
      _fbb,
      _rotation);
}

inline Notify_MoveT *Notify_Move::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_MoveT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_Move::UnPackTo(Notify_MoveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); if (_e) _o->uuid = _e->str(); };
  { auto _e = move(); if (_e) _o->move = std::unique_ptr<MoveInfo>(new MoveInfo(*_e)); };
}

inline flatbuffers::Offset<Notify_Move> Notify_Move::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_MoveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_Move(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_Move> CreateNotify_Move(flatbuffers::FlatBufferBuilder &_fbb, const Notify_MoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uuid = _o->uuid.size() ? _fbb.CreateString(_o->uuid) : 0;
  auto _move = _o->move ? _o->move.get() : 0;
  return protocol::world::CreateNotify_Move(
      _fbb,
      _uuid,
      _move);
}

inline Notify_AttackT *Notify_Attack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_AttackT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_Attack::UnPackTo(Notify_AttackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); if (_e) _o->uuid = _e->str(); };
  { auto _e = rotation(); _o->rotation = _e; };
}

inline flatbuffers::Offset<Notify_Attack> Notify_Attack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AttackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_Attack(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_Attack> CreateNotify_Attack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AttackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uuid = _o->uuid.size() ? _fbb.CreateString(_o->uuid) : 0;
  auto _rotation = _o->rotation;
  return protocol::world::CreateNotify_Attack(
      _fbb,
      _uuid,
      _rotation);
}

inline Notify_HitT *Notify_Hit::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_HitT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_Hit::UnPackTo(Notify_HitT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hit_list(); if (_e) { _o->hit_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->hit_list[_i] = std::unique_ptr<HittingInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Notify_Hit> Notify_Hit::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_HitT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_Hit(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_Hit> CreateNotify_Hit(flatbuffers::FlatBufferBuilder &_fbb, const Notify_HitT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _hit_list = _o->hit_list.size() ? _fbb.CreateVector<flatbuffers::Offset<HittingInfo>>(_o->hit_list.size(), [&](size_t i) { return CreateHittingInfo(_fbb, _o->hit_list[i].get(), _rehasher); }) : 0;
  return protocol::world::CreateNotify_Hit(
      _fbb,
      _hit_list);
}

inline Notify_AppearActorT *Notify_AppearActor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_AppearActorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_AppearActor::UnPackTo(Notify_AppearActorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = remote_pc(); if (_e) { _o->remote_pc.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->remote_pc[_i] = std::unique_ptr<RemotePCT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = monster(); if (_e) { _o->monster.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->monster[_i] = std::unique_ptr<MonsterT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Notify_AppearActor> Notify_AppearActor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AppearActorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_AppearActor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_AppearActor> CreateNotify_AppearActor(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AppearActorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _remote_pc = _o->remote_pc.size() ? _fbb.CreateVector<flatbuffers::Offset<RemotePC>>(_o->remote_pc.size(), [&](size_t i) { return CreateRemotePC(_fbb, _o->remote_pc[i].get(), _rehasher); }) : 0;
  auto _monster = _o->monster.size() ? _fbb.CreateVector<flatbuffers::Offset<Monster>>(_o->monster.size(), [&](size_t i) { return CreateMonster(_fbb, _o->monster[i].get(), _rehasher); }) : 0;
  return protocol::world::CreateNotify_AppearActor(
      _fbb,
      _remote_pc,
      _monster);
}

inline Notify_DisappearActorT *Notify_DisappearActor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_DisappearActorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_DisappearActor::UnPackTo(Notify_DisappearActorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuids(); if (_e) { _o->uuids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->uuids[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<Notify_DisappearActor> Notify_DisappearActor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DisappearActorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_DisappearActor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_DisappearActor> CreateNotify_DisappearActor(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DisappearActorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uuids = _o->uuids.size() ? _fbb.CreateVectorOfStrings(_o->uuids) : 0;
  return protocol::world::CreateNotify_DisappearActor(
      _fbb,
      _uuids);
}

}  // namespace world

inline NetMessageT *NetMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NetMessageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NetMessage::UnPackTo(NetMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_type(); _o->message.type = _e; };
  { auto _e = message(); if (_e) _o->message.value = MessageTUnion::UnPack(_e, message_type(), _resolver); };
}

inline flatbuffers::Offset<NetMessage> NetMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNetMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NetMessage> CreateNetMessage(flatbuffers::FlatBufferBuilder &_fbb, const NetMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  return protocol::CreateNetMessage(
      _fbb,
      _message_type,
      _message);
}

inline bool VerifyMessageT(flatbuffers::Verifier &verifier, const void *obj, MessageT type) {
  switch (type) {
    case MessageT::NONE: {
      return true;
    }
    case MessageT::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<const protocol::Notify_UnauthedAccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Request_Login: {
      auto ptr = reinterpret_cast<const protocol::login::Request_Login *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_LoginFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_LoginSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Request_Join: {
      auto ptr = reinterpret_cast<const protocol::login::Request_Join *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Reply_JoinFailed: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_JoinFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Reply_JoinSuccess: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_JoinSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Request_CharacterList: {
      auto ptr = reinterpret_cast<const protocol::login::Request_CharacterList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Reply_CharacterList: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_CharacterList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Request_CreateCharacter: {
      auto ptr = reinterpret_cast<const protocol::login::Request_CreateCharacter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Reply_CreateCharacterFailed: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_CreateCharacterFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Reply_CreateCharacterSuccess: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_CreateCharacterSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Request_DeleteCharacter: {
      auto ptr = reinterpret_cast<const protocol::login::Request_DeleteCharacter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Reply_DeleteCharacterFailed: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_DeleteCharacterFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::login_Reply_DeleteCharacterSuccess: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_DeleteCharacterSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Request_EnterWorld: {
      auto ptr = reinterpret_cast<const protocol::world::Request_EnterWorld *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Reply_EnterWorldFailed: {
      auto ptr = reinterpret_cast<const protocol::world::Reply_EnterWorldFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Reply_EnterWorldSuccess: {
      auto ptr = reinterpret_cast<const protocol::world::Reply_EnterWorldSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Request_EnterWorldNext: {
      auto ptr = reinterpret_cast<const protocol::world::Request_EnterWorldNext *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Reply_EnterWorldNextFailed: {
      auto ptr = reinterpret_cast<const protocol::world::Reply_EnterWorldNextFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Reply_EnterWorldNextSuccess: {
      auto ptr = reinterpret_cast<const protocol::world::Reply_EnterWorldNextSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Notify_WorldLogicError: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_WorldLogicError *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Notify_EnterZone: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_EnterZone *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Notify_AppearActor: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_AppearActor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Notify_DisappearActor: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_DisappearActor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Request_Move: {
      auto ptr = reinterpret_cast<const protocol::world::Request_Move *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Request_Attack: {
      auto ptr = reinterpret_cast<const protocol::world::Request_Attack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Notify_Move: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_Move *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Notify_Attack: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_Attack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT::world_Notify_Hit: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_Hit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageTVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageT(
        verifier,  values->Get(i), types->GetEnum<MessageT>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageTUnion::UnPack(const void *obj, MessageT type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case MessageT::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<const protocol::Notify_UnauthedAccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Request_Login: {
      auto ptr = reinterpret_cast<const protocol::login::Request_Login *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_LoginFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_LoginSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Request_Join: {
      auto ptr = reinterpret_cast<const protocol::login::Request_Join *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Reply_JoinFailed: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_JoinFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Reply_JoinSuccess: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_JoinSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Request_CharacterList: {
      auto ptr = reinterpret_cast<const protocol::login::Request_CharacterList *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Reply_CharacterList: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_CharacterList *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Request_CreateCharacter: {
      auto ptr = reinterpret_cast<const protocol::login::Request_CreateCharacter *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Reply_CreateCharacterFailed: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_CreateCharacterFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Reply_CreateCharacterSuccess: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_CreateCharacterSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Request_DeleteCharacter: {
      auto ptr = reinterpret_cast<const protocol::login::Request_DeleteCharacter *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Reply_DeleteCharacterFailed: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_DeleteCharacterFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::login_Reply_DeleteCharacterSuccess: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_DeleteCharacterSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Request_EnterWorld: {
      auto ptr = reinterpret_cast<const protocol::world::Request_EnterWorld *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Reply_EnterWorldFailed: {
      auto ptr = reinterpret_cast<const protocol::world::Reply_EnterWorldFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Reply_EnterWorldSuccess: {
      auto ptr = reinterpret_cast<const protocol::world::Reply_EnterWorldSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Request_EnterWorldNext: {
      auto ptr = reinterpret_cast<const protocol::world::Request_EnterWorldNext *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Reply_EnterWorldNextFailed: {
      auto ptr = reinterpret_cast<const protocol::world::Reply_EnterWorldNextFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Reply_EnterWorldNextSuccess: {
      auto ptr = reinterpret_cast<const protocol::world::Reply_EnterWorldNextSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Notify_WorldLogicError: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_WorldLogicError *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Notify_EnterZone: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_EnterZone *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Notify_AppearActor: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_AppearActor *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Notify_DisappearActor: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_DisappearActor *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Request_Move: {
      auto ptr = reinterpret_cast<const protocol::world::Request_Move *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Request_Attack: {
      auto ptr = reinterpret_cast<const protocol::world::Request_Attack *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Notify_Move: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_Move *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Notify_Attack: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_Attack *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT::world_Notify_Hit: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_Hit *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageTUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case MessageT::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<const protocol::Notify_UnauthedAccessT *>(value);
      return CreateNotify_UnauthedAccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Request_Login: {
      auto ptr = reinterpret_cast<const protocol::login::Request_LoginT *>(value);
      return CreateRequest_Login(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_LoginFailedT *>(value);
      return CreateReply_LoginFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_LoginSuccessT *>(value);
      return CreateReply_LoginSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Request_Join: {
      auto ptr = reinterpret_cast<const protocol::login::Request_JoinT *>(value);
      return CreateRequest_Join(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Reply_JoinFailed: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_JoinFailedT *>(value);
      return CreateReply_JoinFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Reply_JoinSuccess: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_JoinSuccessT *>(value);
      return CreateReply_JoinSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Request_CharacterList: {
      auto ptr = reinterpret_cast<const protocol::login::Request_CharacterListT *>(value);
      return CreateRequest_CharacterList(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Reply_CharacterList: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_CharacterListT *>(value);
      return CreateReply_CharacterList(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Request_CreateCharacter: {
      auto ptr = reinterpret_cast<const protocol::login::Request_CreateCharacterT *>(value);
      return CreateRequest_CreateCharacter(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Reply_CreateCharacterFailed: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_CreateCharacterFailedT *>(value);
      return CreateReply_CreateCharacterFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Reply_CreateCharacterSuccess: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_CreateCharacterSuccessT *>(value);
      return CreateReply_CreateCharacterSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Request_DeleteCharacter: {
      auto ptr = reinterpret_cast<const protocol::login::Request_DeleteCharacterT *>(value);
      return CreateRequest_DeleteCharacter(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Reply_DeleteCharacterFailed: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_DeleteCharacterFailedT *>(value);
      return CreateReply_DeleteCharacterFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::login_Reply_DeleteCharacterSuccess: {
      auto ptr = reinterpret_cast<const protocol::login::Reply_DeleteCharacterSuccessT *>(value);
      return CreateReply_DeleteCharacterSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Request_EnterWorld: {
      auto ptr = reinterpret_cast<const protocol::world::Request_EnterWorldT *>(value);
      return CreateRequest_EnterWorld(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Reply_EnterWorldFailed: {
      auto ptr = reinterpret_cast<const protocol::world::Reply_EnterWorldFailedT *>(value);
      return CreateReply_EnterWorldFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Reply_EnterWorldSuccess: {
      auto ptr = reinterpret_cast<const protocol::world::Reply_EnterWorldSuccessT *>(value);
      return CreateReply_EnterWorldSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Request_EnterWorldNext: {
      auto ptr = reinterpret_cast<const protocol::world::Request_EnterWorldNextT *>(value);
      return CreateRequest_EnterWorldNext(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Reply_EnterWorldNextFailed: {
      auto ptr = reinterpret_cast<const protocol::world::Reply_EnterWorldNextFailedT *>(value);
      return CreateReply_EnterWorldNextFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Reply_EnterWorldNextSuccess: {
      auto ptr = reinterpret_cast<const protocol::world::Reply_EnterWorldNextSuccessT *>(value);
      return CreateReply_EnterWorldNextSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Notify_WorldLogicError: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_WorldLogicErrorT *>(value);
      return CreateNotify_WorldLogicError(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Notify_EnterZone: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_EnterZoneT *>(value);
      return CreateNotify_EnterZone(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Notify_AppearActor: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_AppearActorT *>(value);
      return CreateNotify_AppearActor(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Notify_DisappearActor: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_DisappearActorT *>(value);
      return CreateNotify_DisappearActor(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Request_Move: {
      auto ptr = reinterpret_cast<const protocol::world::Request_MoveT *>(value);
      return CreateRequest_Move(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Request_Attack: {
      auto ptr = reinterpret_cast<const protocol::world::Request_AttackT *>(value);
      return CreateRequest_Attack(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Notify_Move: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_MoveT *>(value);
      return CreateNotify_Move(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Notify_Attack: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_AttackT *>(value);
      return CreateNotify_Attack(_fbb, ptr, _rehasher).Union();
    }
    case MessageT::world_Notify_Hit: {
      auto ptr = reinterpret_cast<const protocol::world::Notify_HitT *>(value);
      return CreateNotify_Hit(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageTUnion::MessageTUnion(const MessageTUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case MessageT::Notify_UnauthedAccess: {
      value = new protocol::Notify_UnauthedAccessT(*reinterpret_cast<protocol::Notify_UnauthedAccessT *>(u.value));
      break;
    }
    case MessageT::login_Request_Login: {
      value = new protocol::login::Request_LoginT(*reinterpret_cast<protocol::login::Request_LoginT *>(u.value));
      break;
    }
    case MessageT::login_Reply_LoginFailed: {
      value = new protocol::login::Reply_LoginFailedT(*reinterpret_cast<protocol::login::Reply_LoginFailedT *>(u.value));
      break;
    }
    case MessageT::login_Reply_LoginSuccess: {
      value = new protocol::login::Reply_LoginSuccessT(*reinterpret_cast<protocol::login::Reply_LoginSuccessT *>(u.value));
      break;
    }
    case MessageT::login_Request_Join: {
      value = new protocol::login::Request_JoinT(*reinterpret_cast<protocol::login::Request_JoinT *>(u.value));
      break;
    }
    case MessageT::login_Reply_JoinFailed: {
      value = new protocol::login::Reply_JoinFailedT(*reinterpret_cast<protocol::login::Reply_JoinFailedT *>(u.value));
      break;
    }
    case MessageT::login_Reply_JoinSuccess: {
      value = new protocol::login::Reply_JoinSuccessT(*reinterpret_cast<protocol::login::Reply_JoinSuccessT *>(u.value));
      break;
    }
    case MessageT::login_Request_CharacterList: {
      value = new protocol::login::Request_CharacterListT(*reinterpret_cast<protocol::login::Request_CharacterListT *>(u.value));
      break;
    }
    case MessageT::login_Reply_CharacterList: {
      assert(false);  // protocol::login::Reply_CharacterListT not copyable.
      break;
    }
    case MessageT::login_Request_CreateCharacter: {
      value = new protocol::login::Request_CreateCharacterT(*reinterpret_cast<protocol::login::Request_CreateCharacterT *>(u.value));
      break;
    }
    case MessageT::login_Reply_CreateCharacterFailed: {
      value = new protocol::login::Reply_CreateCharacterFailedT(*reinterpret_cast<protocol::login::Reply_CreateCharacterFailedT *>(u.value));
      break;
    }
    case MessageT::login_Reply_CreateCharacterSuccess: {
      assert(false);  // protocol::login::Reply_CreateCharacterSuccessT not copyable.
      break;
    }
    case MessageT::login_Request_DeleteCharacter: {
      value = new protocol::login::Request_DeleteCharacterT(*reinterpret_cast<protocol::login::Request_DeleteCharacterT *>(u.value));
      break;
    }
    case MessageT::login_Reply_DeleteCharacterFailed: {
      value = new protocol::login::Reply_DeleteCharacterFailedT(*reinterpret_cast<protocol::login::Reply_DeleteCharacterFailedT *>(u.value));
      break;
    }
    case MessageT::login_Reply_DeleteCharacterSuccess: {
      value = new protocol::login::Reply_DeleteCharacterSuccessT(*reinterpret_cast<protocol::login::Reply_DeleteCharacterSuccessT *>(u.value));
      break;
    }
    case MessageT::world_Request_EnterWorld: {
      value = new protocol::world::Request_EnterWorldT(*reinterpret_cast<protocol::world::Request_EnterWorldT *>(u.value));
      break;
    }
    case MessageT::world_Reply_EnterWorldFailed: {
      value = new protocol::world::Reply_EnterWorldFailedT(*reinterpret_cast<protocol::world::Reply_EnterWorldFailedT *>(u.value));
      break;
    }
    case MessageT::world_Reply_EnterWorldSuccess: {
      value = new protocol::world::Reply_EnterWorldSuccessT(*reinterpret_cast<protocol::world::Reply_EnterWorldSuccessT *>(u.value));
      break;
    }
    case MessageT::world_Request_EnterWorldNext: {
      value = new protocol::world::Request_EnterWorldNextT(*reinterpret_cast<protocol::world::Request_EnterWorldNextT *>(u.value));
      break;
    }
    case MessageT::world_Reply_EnterWorldNextFailed: {
      value = new protocol::world::Reply_EnterWorldNextFailedT(*reinterpret_cast<protocol::world::Reply_EnterWorldNextFailedT *>(u.value));
      break;
    }
    case MessageT::world_Reply_EnterWorldNextSuccess: {
      assert(false);  // protocol::world::Reply_EnterWorldNextSuccessT not copyable.
      break;
    }
    case MessageT::world_Notify_WorldLogicError: {
      value = new protocol::world::Notify_WorldLogicErrorT(*reinterpret_cast<protocol::world::Notify_WorldLogicErrorT *>(u.value));
      break;
    }
    case MessageT::world_Notify_EnterZone: {
      assert(false);  // protocol::world::Notify_EnterZoneT not copyable.
      break;
    }
    case MessageT::world_Notify_AppearActor: {
      assert(false);  // protocol::world::Notify_AppearActorT not copyable.
      break;
    }
    case MessageT::world_Notify_DisappearActor: {
      value = new protocol::world::Notify_DisappearActorT(*reinterpret_cast<protocol::world::Notify_DisappearActorT *>(u.value));
      break;
    }
    case MessageT::world_Request_Move: {
      assert(false);  // protocol::world::Request_MoveT not copyable.
      break;
    }
    case MessageT::world_Request_Attack: {
      value = new protocol::world::Request_AttackT(*reinterpret_cast<protocol::world::Request_AttackT *>(u.value));
      break;
    }
    case MessageT::world_Notify_Move: {
      assert(false);  // protocol::world::Notify_MoveT not copyable.
      break;
    }
    case MessageT::world_Notify_Attack: {
      value = new protocol::world::Notify_AttackT(*reinterpret_cast<protocol::world::Notify_AttackT *>(u.value));
      break;
    }
    case MessageT::world_Notify_Hit: {
      assert(false);  // protocol::world::Notify_HitT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void MessageTUnion::Reset() {
  switch (type) {
    case MessageT::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<protocol::Notify_UnauthedAccessT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Request_Login: {
      auto ptr = reinterpret_cast<protocol::login::Request_LoginT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<protocol::login::Reply_LoginFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<protocol::login::Reply_LoginSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Request_Join: {
      auto ptr = reinterpret_cast<protocol::login::Request_JoinT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Reply_JoinFailed: {
      auto ptr = reinterpret_cast<protocol::login::Reply_JoinFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Reply_JoinSuccess: {
      auto ptr = reinterpret_cast<protocol::login::Reply_JoinSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Request_CharacterList: {
      auto ptr = reinterpret_cast<protocol::login::Request_CharacterListT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Reply_CharacterList: {
      auto ptr = reinterpret_cast<protocol::login::Reply_CharacterListT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Request_CreateCharacter: {
      auto ptr = reinterpret_cast<protocol::login::Request_CreateCharacterT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Reply_CreateCharacterFailed: {
      auto ptr = reinterpret_cast<protocol::login::Reply_CreateCharacterFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Reply_CreateCharacterSuccess: {
      auto ptr = reinterpret_cast<protocol::login::Reply_CreateCharacterSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Request_DeleteCharacter: {
      auto ptr = reinterpret_cast<protocol::login::Request_DeleteCharacterT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Reply_DeleteCharacterFailed: {
      auto ptr = reinterpret_cast<protocol::login::Reply_DeleteCharacterFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageT::login_Reply_DeleteCharacterSuccess: {
      auto ptr = reinterpret_cast<protocol::login::Reply_DeleteCharacterSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Request_EnterWorld: {
      auto ptr = reinterpret_cast<protocol::world::Request_EnterWorldT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Reply_EnterWorldFailed: {
      auto ptr = reinterpret_cast<protocol::world::Reply_EnterWorldFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Reply_EnterWorldSuccess: {
      auto ptr = reinterpret_cast<protocol::world::Reply_EnterWorldSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Request_EnterWorldNext: {
      auto ptr = reinterpret_cast<protocol::world::Request_EnterWorldNextT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Reply_EnterWorldNextFailed: {
      auto ptr = reinterpret_cast<protocol::world::Reply_EnterWorldNextFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Reply_EnterWorldNextSuccess: {
      auto ptr = reinterpret_cast<protocol::world::Reply_EnterWorldNextSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Notify_WorldLogicError: {
      auto ptr = reinterpret_cast<protocol::world::Notify_WorldLogicErrorT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Notify_EnterZone: {
      auto ptr = reinterpret_cast<protocol::world::Notify_EnterZoneT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Notify_AppearActor: {
      auto ptr = reinterpret_cast<protocol::world::Notify_AppearActorT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Notify_DisappearActor: {
      auto ptr = reinterpret_cast<protocol::world::Notify_DisappearActorT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Request_Move: {
      auto ptr = reinterpret_cast<protocol::world::Request_MoveT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Request_Attack: {
      auto ptr = reinterpret_cast<protocol::world::Request_AttackT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Notify_Move: {
      auto ptr = reinterpret_cast<protocol::world::Notify_MoveT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Notify_Attack: {
      auto ptr = reinterpret_cast<protocol::world::Notify_AttackT *>(value);
      delete ptr;
      break;
    }
    case MessageT::world_Notify_Hit: {
      auto ptr = reinterpret_cast<protocol::world::Notify_HitT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MessageT::NONE;
}

inline const protocol::NetMessage *GetNetMessage(const void *buf) {
  return flatbuffers::GetRoot<protocol::NetMessage>(buf);
}

inline bool VerifyNetMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<protocol::NetMessage>(nullptr);
}

inline void FinishNetMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<protocol::NetMessage> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<NetMessageT> UnPackNetMessage(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NetMessageT>(GetNetMessage(buf)->UnPack(res));
}

}  // namespace protocol

#endif  // FLATBUFFERS_GENERATED_PROTOCOL_PROTOCOL_H_
