// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAMEMESSAGE_GAME_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_GAMEMESSAGE_GAME_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace Game {
namespace Protocol {

struct Vec3;

struct CS_LoginRequest;

struct SC_LoginFailed;

struct SC_LoginSuccess;

struct CS_JoinRequest;

struct SC_JoinFailed;

struct SC_JoinSuccess;

struct NetMessage;

enum ErrorCode {
  ErrorCode_OK = 0,
  ErrorCode_FATAL_ERROR = 1,
  ErrorCode_SQL_ERROR = 2,
  ErrorCode_MIN = ErrorCode_OK,
  ErrorCode_MAX = ErrorCode_SQL_ERROR
};

inline const char **EnumNamesErrorCode() {
  static const char *names[] = {
    "OK",
    "FATAL_ERROR",
    "SQL_ERROR",
    nullptr
  };
  return names;
}

inline const char *EnumNameErrorCode(ErrorCode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesErrorCode()[index];
}

enum Message {
  Message_NONE = 0,
  Message_CS_LoginRequest = 1,
  Message_SC_LoginFailed = 2,
  Message_SC_LoginSuccess = 3,
  Message_CS_JoinRequest = 4,
  Message_SC_JoinFailed = 5,
  Message_SC_JoinSuccess = 6,
  Message_MIN = Message_NONE,
  Message_MAX = Message_SC_JoinSuccess
};

inline const char **EnumNamesMessage() {
  static const char *names[] = {
    "NONE",
    "CS_LoginRequest",
    "SC_LoginFailed",
    "SC_LoginSuccess",
    "CS_JoinRequest",
    "SC_JoinFailed",
    "SC_JoinSuccess",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<CS_LoginRequest> {
  static const Message enum_value = Message_CS_LoginRequest;
};

template<> struct MessageTraits<SC_LoginFailed> {
  static const Message enum_value = Message_SC_LoginFailed;
};

template<> struct MessageTraits<SC_LoginSuccess> {
  static const Message enum_value = Message_SC_LoginSuccess;
};

template<> struct MessageTraits<CS_JoinRequest> {
  static const Message enum_value = Message_CS_JoinRequest;
};

template<> struct MessageTraits<SC_JoinFailed> {
  static const Message enum_value = Message_SC_JoinFailed;
};

template<> struct MessageTraits<SC_JoinSuccess> {
  static const Message enum_value = Message_SC_JoinSuccess;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(const Vec3 &_o) {
    memcpy(this, &_o, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vec3, 12);

struct CS_LoginRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC_NAME = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *acc_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ACC_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ACC_NAME) &&
           verifier.Verify(acc_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
};

struct CS_LoginRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc_name(flatbuffers::Offset<flatbuffers::String> acc_name) {
    fbb_.AddOffset(CS_LoginRequest::VT_ACC_NAME, acc_name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(CS_LoginRequest::VT_PASSWORD, password);
  }
  CS_LoginRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CS_LoginRequestBuilder &operator=(const CS_LoginRequestBuilder &);
  flatbuffers::Offset<CS_LoginRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CS_LoginRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CS_LoginRequest> CreateCS_LoginRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> acc_name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  CS_LoginRequestBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_acc_name(acc_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CS_LoginRequest> CreateCS_LoginRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *acc_name = nullptr,
    const char *password = nullptr) {
  return CreateCS_LoginRequest(
      _fbb,
      acc_name ? _fbb.CreateString(acc_name) : 0,
      password ? _fbb.CreateString(password) : 0);
}

struct SC_LoginFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
};

struct SC_LoginFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(SC_LoginFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  SC_LoginFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SC_LoginFailedBuilder &operator=(const SC_LoginFailedBuilder &);
  flatbuffers::Offset<SC_LoginFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SC_LoginFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<SC_LoginFailed> CreateSC_LoginFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_OK) {
  SC_LoginFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

struct SC_LoginSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UID = 4
  };
  int32_t uid() const {
    return GetField<int32_t>(VT_UID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UID) &&
           verifier.EndTable();
  }
};

struct SC_LoginSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(int32_t uid) {
    fbb_.AddElement<int32_t>(SC_LoginSuccess::VT_UID, uid, 0);
  }
  SC_LoginSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SC_LoginSuccessBuilder &operator=(const SC_LoginSuccessBuilder &);
  flatbuffers::Offset<SC_LoginSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SC_LoginSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<SC_LoginSuccess> CreateSC_LoginSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t uid = 0) {
  SC_LoginSuccessBuilder builder_(_fbb);
  builder_.add_uid(uid);
  return builder_.Finish();
}

struct CS_JoinRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACC_NAME = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *acc_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ACC_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ACC_NAME) &&
           verifier.Verify(acc_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
};

struct CS_JoinRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc_name(flatbuffers::Offset<flatbuffers::String> acc_name) {
    fbb_.AddOffset(CS_JoinRequest::VT_ACC_NAME, acc_name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(CS_JoinRequest::VT_PASSWORD, password);
  }
  CS_JoinRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CS_JoinRequestBuilder &operator=(const CS_JoinRequestBuilder &);
  flatbuffers::Offset<CS_JoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CS_JoinRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CS_JoinRequest> CreateCS_JoinRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> acc_name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  CS_JoinRequestBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_acc_name(acc_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CS_JoinRequest> CreateCS_JoinRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *acc_name = nullptr,
    const char *password = nullptr) {
  return CreateCS_JoinRequest(
      _fbb,
      acc_name ? _fbb.CreateString(acc_name) : 0,
      password ? _fbb.CreateString(password) : 0);
}

struct SC_JoinFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
};

struct SC_JoinFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(SC_JoinFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  SC_JoinFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SC_JoinFailedBuilder &operator=(const SC_JoinFailedBuilder &);
  flatbuffers::Offset<SC_JoinFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SC_JoinFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<SC_JoinFailed> CreateSC_JoinFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_OK) {
  SC_JoinFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

struct SC_JoinSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SC_JoinSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  SC_JoinSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SC_JoinSuccessBuilder &operator=(const SC_JoinSuccessBuilder &);
  flatbuffers::Offset<SC_JoinSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<SC_JoinSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<SC_JoinSuccess> CreateSC_JoinSuccess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SC_JoinSuccessBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NetMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  Message message_type() const {
    return static_cast<Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

struct NetMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(Message message_type) {
    fbb_.AddElement<uint8_t>(NetMessage::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(NetMessage::VT_MESSAGE, message);
  }
  NetMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NetMessageBuilder &operator=(const NetMessageBuilder &);
  flatbuffers::Offset<NetMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<NetMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetMessage> CreateNetMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    Message message_type = Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  NetMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_CS_LoginRequest: {
      auto ptr = reinterpret_cast<const CS_LoginRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_SC_LoginFailed: {
      auto ptr = reinterpret_cast<const SC_LoginFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_SC_LoginSuccess: {
      auto ptr = reinterpret_cast<const SC_LoginSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_CS_JoinRequest: {
      auto ptr = reinterpret_cast<const CS_JoinRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_SC_JoinFailed: {
      auto ptr = reinterpret_cast<const SC_JoinFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_SC_JoinSuccess: {
      auto ptr = reinterpret_cast<const SC_JoinSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline const Game::Protocol::NetMessage *GetNetMessage(const void *buf) {
  return flatbuffers::GetRoot<Game::Protocol::NetMessage>(buf);
}

inline bool VerifyNetMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Game::Protocol::NetMessage>(nullptr);
}

inline void FinishNetMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Game::Protocol::NetMessage> root) {
  fbb.Finish(root);
}

}  // namespace Protocol
}  // namespace Game

#endif  // FLATBUFFERS_GENERATED_GAMEMESSAGE_GAME_PROTOCOL_H_
