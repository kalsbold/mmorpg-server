// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROTOCOLCS_PROTOCOLCS_H_
#define FLATBUFFERS_GENERATED_PROTOCOLCS_PROTOCOLCS_H_

#include "flatbuffers/flatbuffers.h"

namespace ProtocolCS {

struct Vec2;

struct Vec3;

struct Notify_UnauthedAccess;
struct Notify_UnauthedAccessT;

namespace Login {

struct Character;
struct CharacterT;

struct Request_Login;
struct Request_LoginT;

struct Reply_LoginSuccess;
struct Reply_LoginSuccessT;

struct Reply_LoginFailed;
struct Reply_LoginFailedT;

struct Request_Join;
struct Request_JoinT;

struct Reply_JoinSuccess;
struct Reply_JoinSuccessT;

struct Reply_JoinFailed;
struct Reply_JoinFailedT;

struct Request_CharacterList;
struct Request_CharacterListT;

struct Reply_CharacterList;
struct Reply_CharacterListT;

struct Request_CreateCharacter;
struct Request_CreateCharacterT;

struct Reply_CreateCharacterSuccess;
struct Reply_CreateCharacterSuccessT;

struct Reply_CreateCharacterFailed;
struct Reply_CreateCharacterFailedT;

struct Request_DeleteCharacter;
struct Request_DeleteCharacterT;

struct Reply_DeleteCharacterSuccess;
struct Reply_DeleteCharacterSuccessT;

struct Reply_DeleteCharacterFailed;
struct Reply_DeleteCharacterFailedT;

}  // namespace Login

namespace World {

struct PlayerCharacter;
struct PlayerCharacterT;

struct RemotePC;
struct RemotePCT;

struct Monster;
struct MonsterT;

struct MoveData;
struct MoveDataT;

struct AttackData;
struct AttackDataT;

struct DamageData;
struct DamageDataT;

struct Request_EnterWorld;
struct Request_EnterWorldT;

struct Reply_EnterWorldSuccess;
struct Reply_EnterWorldSuccessT;

struct Reply_EnterWorldFailed;
struct Reply_EnterWorldFailedT;

struct Request_EnterWorldNext;
struct Request_EnterWorldNextT;

struct Reply_EnterWorldNextSuccess;
struct Reply_EnterWorldNextSuccessT;

struct Reply_EnterWorldNextFailed;
struct Reply_EnterWorldNextFailedT;

struct Notify_EnterZone;
struct Notify_EnterZoneT;

struct Request_Move;
struct Request_MoveT;

struct Request_Attack;
struct Request_AttackT;

struct Notify_AppearActor;
struct Notify_AppearActorT;

struct Notify_DisappearActor;
struct Notify_DisappearActorT;

struct Notify_Move;
struct Notify_MoveT;

struct Notify_Attack;
struct Notify_AttackT;

struct Notify_Damage;
struct Notify_DamageT;

}  // namespace World

struct MessageRoot;
struct MessageRootT;

enum class ErrorCode : int32_t {
  OK = 0,
  UNEXPECTED = 1,
  DATABASE_FAILED = 2,
  INVALID_SESSION = 10,
  INVALID_STRING = 20,
  LOGIN_INCORRECT_ACC_NAME = 100,
  LOGIN_INCORRECT_ACC_PASSWORD = 101,
  LOGIN_DUPLICATION = 102,
  JOIN_ACC_NAME_ALREADY = 200,
  JOIN_CANNOT_ACC_CREATE = 201,
  CREATE_CHARACTER_NAME_ALREADY = 300,
  CREATE_CHARACTER_CANNOT_CREATE = 301,
  CREATE_CHARACTER_ATTRIBUTE_NOT_EXIST = 302,
  DELETE_CHARACTER_NOT_EXIST = 400,
  DELETE_CHARACTER_CANNOT_DELETE = 401,
  ENTER_WORLD_INVALID_CHARACTER = 500,
  ENTER_WORLD_INVALID_STATE = 501,
  ENTER_WORLD_CANNOT_ENTER_ZONE = 502,
  ENTER_WORLD_NEXT_INVALID_STATE = 510,
  ENTER_WORLD_NEXT_CHARACTER_NOT_LOADED = 511,
  ENTER_WORLD_NEXT_CANNOT_FIND_ZONE = 512,
  WORLD_LOGIC_INVALID_STATE = 600,
  WORLD_LOGIC_ENTER_ZONE_FAILED = 603,
  MIN = OK,
  MAX = WORLD_LOGIC_ENTER_ZONE_FAILED
};

enum class ClassType : int32_t {
  NONE = 0,
  Knight = 1,
  Archer = 2,
  Mage = 3,
  MIN = NONE,
  MAX = Mage
};

inline const char **EnumNamesClassType() {
  static const char *names[] = {
    "NONE",
    "Knight",
    "Archer",
    "Mage",
    nullptr
  };
  return names;
}

inline const char *EnumNameClassType(ClassType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesClassType()[index];
}

enum class MapType : int32_t {
  NONE = 0,
  FIELD = 1,
  DUNGEON = 2,
  MIN = NONE,
  MAX = DUNGEON
};

inline const char **EnumNamesMapType() {
  static const char *names[] = {
    "NONE",
    "FIELD",
    "DUNGEON",
    nullptr
  };
  return names;
}

inline const char *EnumNameMapType(MapType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMapType()[index];
}

enum class MessageType : uint8_t {
  NONE = 0,
  Notify_UnauthedAccess = 1,
  Login_Request_Login = 2,
  Login_Reply_LoginSuccess = 3,
  Login_Reply_LoginFailed = 4,
  Login_Request_Join = 5,
  Login_Reply_JoinSuccess = 6,
  Login_Reply_JoinFailed = 7,
  Login_Request_CharacterList = 8,
  Login_Reply_CharacterList = 9,
  Login_Request_CreateCharacter = 10,
  Login_Reply_CreateCharacterSuccess = 11,
  Login_Reply_CreateCharacterFailed = 12,
  Login_Request_DeleteCharacter = 13,
  Login_Reply_DeleteCharacterSuccess = 14,
  Login_Reply_DeleteCharacterFailed = 15,
  World_Request_EnterWorld = 16,
  World_Reply_EnterWorldSuccess = 17,
  World_Reply_EnterWorldFailed = 18,
  World_Request_EnterWorldNext = 19,
  World_Reply_EnterWorldNextSuccess = 20,
  World_Reply_EnterWorldNextFailed = 21,
  World_Request_Move = 22,
  World_Request_Attack = 23,
  World_Notify_EnterZone = 24,
  World_Notify_AppearActor = 25,
  World_Notify_DisappearActor = 26,
  World_Notify_Move = 27,
  World_Notify_Attack = 28,
  World_Notify_Damage = 29,
  MIN = NONE,
  MAX = World_Notify_Damage
};

inline const char **EnumNamesMessageType() {
  static const char *names[] = {
    "NONE",
    "Notify_UnauthedAccess",
    "Login_Request_Login",
    "Login_Reply_LoginSuccess",
    "Login_Reply_LoginFailed",
    "Login_Request_Join",
    "Login_Reply_JoinSuccess",
    "Login_Reply_JoinFailed",
    "Login_Request_CharacterList",
    "Login_Reply_CharacterList",
    "Login_Request_CreateCharacter",
    "Login_Reply_CreateCharacterSuccess",
    "Login_Reply_CreateCharacterFailed",
    "Login_Request_DeleteCharacter",
    "Login_Reply_DeleteCharacterSuccess",
    "Login_Reply_DeleteCharacterFailed",
    "World_Request_EnterWorld",
    "World_Reply_EnterWorldSuccess",
    "World_Reply_EnterWorldFailed",
    "World_Request_EnterWorldNext",
    "World_Reply_EnterWorldNextSuccess",
    "World_Reply_EnterWorldNextFailed",
    "World_Request_Move",
    "World_Request_Attack",
    "World_Notify_EnterZone",
    "World_Notify_AppearActor",
    "World_Notify_DisappearActor",
    "World_Notify_Move",
    "World_Notify_Attack",
    "World_Notify_Damage",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageType()[index];
}

template<typename T> struct MessageTypeTraits {
  static const MessageType enum_value = MessageType::NONE;
};

template<> struct MessageTypeTraits<ProtocolCS::Notify_UnauthedAccess> {
  static const MessageType enum_value = MessageType::Notify_UnauthedAccess;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Request_Login> {
  static const MessageType enum_value = MessageType::Login_Request_Login;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_LoginSuccess> {
  static const MessageType enum_value = MessageType::Login_Reply_LoginSuccess;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_LoginFailed> {
  static const MessageType enum_value = MessageType::Login_Reply_LoginFailed;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Request_Join> {
  static const MessageType enum_value = MessageType::Login_Request_Join;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_JoinSuccess> {
  static const MessageType enum_value = MessageType::Login_Reply_JoinSuccess;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_JoinFailed> {
  static const MessageType enum_value = MessageType::Login_Reply_JoinFailed;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Request_CharacterList> {
  static const MessageType enum_value = MessageType::Login_Request_CharacterList;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_CharacterList> {
  static const MessageType enum_value = MessageType::Login_Reply_CharacterList;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Request_CreateCharacter> {
  static const MessageType enum_value = MessageType::Login_Request_CreateCharacter;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_CreateCharacterSuccess> {
  static const MessageType enum_value = MessageType::Login_Reply_CreateCharacterSuccess;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_CreateCharacterFailed> {
  static const MessageType enum_value = MessageType::Login_Reply_CreateCharacterFailed;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Request_DeleteCharacter> {
  static const MessageType enum_value = MessageType::Login_Request_DeleteCharacter;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_DeleteCharacterSuccess> {
  static const MessageType enum_value = MessageType::Login_Reply_DeleteCharacterSuccess;
};

template<> struct MessageTypeTraits<ProtocolCS::Login::Reply_DeleteCharacterFailed> {
  static const MessageType enum_value = MessageType::Login_Reply_DeleteCharacterFailed;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Request_EnterWorld> {
  static const MessageType enum_value = MessageType::World_Request_EnterWorld;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Reply_EnterWorldSuccess> {
  static const MessageType enum_value = MessageType::World_Reply_EnterWorldSuccess;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Reply_EnterWorldFailed> {
  static const MessageType enum_value = MessageType::World_Reply_EnterWorldFailed;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Request_EnterWorldNext> {
  static const MessageType enum_value = MessageType::World_Request_EnterWorldNext;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Reply_EnterWorldNextSuccess> {
  static const MessageType enum_value = MessageType::World_Reply_EnterWorldNextSuccess;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Reply_EnterWorldNextFailed> {
  static const MessageType enum_value = MessageType::World_Reply_EnterWorldNextFailed;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Request_Move> {
  static const MessageType enum_value = MessageType::World_Request_Move;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Request_Attack> {
  static const MessageType enum_value = MessageType::World_Request_Attack;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Notify_EnterZone> {
  static const MessageType enum_value = MessageType::World_Notify_EnterZone;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Notify_AppearActor> {
  static const MessageType enum_value = MessageType::World_Notify_AppearActor;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Notify_DisappearActor> {
  static const MessageType enum_value = MessageType::World_Notify_DisappearActor;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Notify_Move> {
  static const MessageType enum_value = MessageType::World_Notify_Move;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Notify_Attack> {
  static const MessageType enum_value = MessageType::World_Notify_Attack;
};

template<> struct MessageTypeTraits<ProtocolCS::World::Notify_Damage> {
  static const MessageType enum_value = MessageType::World_Notify_Damage;
};

struct MessageTypeUnion {
  MessageType type;
  void *value;

  MessageTypeUnion() : type(MessageType::NONE), value(nullptr) {}
  MessageTypeUnion(MessageTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MessageType::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageTypeUnion(const MessageTypeUnion &) FLATBUFFERS_NOEXCEPT;
  MessageTypeUnion &operator=(const MessageTypeUnion &u) FLATBUFFERS_NOEXCEPT
    { MessageTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageTypeUnion &operator=(MessageTypeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageTypeUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    Reset();
    type = MessageTypeTraits<typename T::TableType>::enum_value;
    if (type != MessageType::NONE) {
      value = new T(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, MessageType type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ProtocolCS::Notify_UnauthedAccessT *AsNotify_UnauthedAccess() {
    return type == MessageType::Notify_UnauthedAccess ?
      reinterpret_cast<ProtocolCS::Notify_UnauthedAccessT *>(value) : nullptr;
  }
  ProtocolCS::Login::Request_LoginT *AsLogin_Request_Login() {
    return type == MessageType::Login_Request_Login ?
      reinterpret_cast<ProtocolCS::Login::Request_LoginT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_LoginSuccessT *AsLogin_Reply_LoginSuccess() {
    return type == MessageType::Login_Reply_LoginSuccess ?
      reinterpret_cast<ProtocolCS::Login::Reply_LoginSuccessT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_LoginFailedT *AsLogin_Reply_LoginFailed() {
    return type == MessageType::Login_Reply_LoginFailed ?
      reinterpret_cast<ProtocolCS::Login::Reply_LoginFailedT *>(value) : nullptr;
  }
  ProtocolCS::Login::Request_JoinT *AsLogin_Request_Join() {
    return type == MessageType::Login_Request_Join ?
      reinterpret_cast<ProtocolCS::Login::Request_JoinT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_JoinSuccessT *AsLogin_Reply_JoinSuccess() {
    return type == MessageType::Login_Reply_JoinSuccess ?
      reinterpret_cast<ProtocolCS::Login::Reply_JoinSuccessT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_JoinFailedT *AsLogin_Reply_JoinFailed() {
    return type == MessageType::Login_Reply_JoinFailed ?
      reinterpret_cast<ProtocolCS::Login::Reply_JoinFailedT *>(value) : nullptr;
  }
  ProtocolCS::Login::Request_CharacterListT *AsLogin_Request_CharacterList() {
    return type == MessageType::Login_Request_CharacterList ?
      reinterpret_cast<ProtocolCS::Login::Request_CharacterListT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_CharacterListT *AsLogin_Reply_CharacterList() {
    return type == MessageType::Login_Reply_CharacterList ?
      reinterpret_cast<ProtocolCS::Login::Reply_CharacterListT *>(value) : nullptr;
  }
  ProtocolCS::Login::Request_CreateCharacterT *AsLogin_Request_CreateCharacter() {
    return type == MessageType::Login_Request_CreateCharacter ?
      reinterpret_cast<ProtocolCS::Login::Request_CreateCharacterT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_CreateCharacterSuccessT *AsLogin_Reply_CreateCharacterSuccess() {
    return type == MessageType::Login_Reply_CreateCharacterSuccess ?
      reinterpret_cast<ProtocolCS::Login::Reply_CreateCharacterSuccessT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_CreateCharacterFailedT *AsLogin_Reply_CreateCharacterFailed() {
    return type == MessageType::Login_Reply_CreateCharacterFailed ?
      reinterpret_cast<ProtocolCS::Login::Reply_CreateCharacterFailedT *>(value) : nullptr;
  }
  ProtocolCS::Login::Request_DeleteCharacterT *AsLogin_Request_DeleteCharacter() {
    return type == MessageType::Login_Request_DeleteCharacter ?
      reinterpret_cast<ProtocolCS::Login::Request_DeleteCharacterT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_DeleteCharacterSuccessT *AsLogin_Reply_DeleteCharacterSuccess() {
    return type == MessageType::Login_Reply_DeleteCharacterSuccess ?
      reinterpret_cast<ProtocolCS::Login::Reply_DeleteCharacterSuccessT *>(value) : nullptr;
  }
  ProtocolCS::Login::Reply_DeleteCharacterFailedT *AsLogin_Reply_DeleteCharacterFailed() {
    return type == MessageType::Login_Reply_DeleteCharacterFailed ?
      reinterpret_cast<ProtocolCS::Login::Reply_DeleteCharacterFailedT *>(value) : nullptr;
  }
  ProtocolCS::World::Request_EnterWorldT *AsWorld_Request_EnterWorld() {
    return type == MessageType::World_Request_EnterWorld ?
      reinterpret_cast<ProtocolCS::World::Request_EnterWorldT *>(value) : nullptr;
  }
  ProtocolCS::World::Reply_EnterWorldSuccessT *AsWorld_Reply_EnterWorldSuccess() {
    return type == MessageType::World_Reply_EnterWorldSuccess ?
      reinterpret_cast<ProtocolCS::World::Reply_EnterWorldSuccessT *>(value) : nullptr;
  }
  ProtocolCS::World::Reply_EnterWorldFailedT *AsWorld_Reply_EnterWorldFailed() {
    return type == MessageType::World_Reply_EnterWorldFailed ?
      reinterpret_cast<ProtocolCS::World::Reply_EnterWorldFailedT *>(value) : nullptr;
  }
  ProtocolCS::World::Request_EnterWorldNextT *AsWorld_Request_EnterWorldNext() {
    return type == MessageType::World_Request_EnterWorldNext ?
      reinterpret_cast<ProtocolCS::World::Request_EnterWorldNextT *>(value) : nullptr;
  }
  ProtocolCS::World::Reply_EnterWorldNextSuccessT *AsWorld_Reply_EnterWorldNextSuccess() {
    return type == MessageType::World_Reply_EnterWorldNextSuccess ?
      reinterpret_cast<ProtocolCS::World::Reply_EnterWorldNextSuccessT *>(value) : nullptr;
  }
  ProtocolCS::World::Reply_EnterWorldNextFailedT *AsWorld_Reply_EnterWorldNextFailed() {
    return type == MessageType::World_Reply_EnterWorldNextFailed ?
      reinterpret_cast<ProtocolCS::World::Reply_EnterWorldNextFailedT *>(value) : nullptr;
  }
  ProtocolCS::World::Request_MoveT *AsWorld_Request_Move() {
    return type == MessageType::World_Request_Move ?
      reinterpret_cast<ProtocolCS::World::Request_MoveT *>(value) : nullptr;
  }
  ProtocolCS::World::Request_AttackT *AsWorld_Request_Attack() {
    return type == MessageType::World_Request_Attack ?
      reinterpret_cast<ProtocolCS::World::Request_AttackT *>(value) : nullptr;
  }
  ProtocolCS::World::Notify_EnterZoneT *AsWorld_Notify_EnterZone() {
    return type == MessageType::World_Notify_EnterZone ?
      reinterpret_cast<ProtocolCS::World::Notify_EnterZoneT *>(value) : nullptr;
  }
  ProtocolCS::World::Notify_AppearActorT *AsWorld_Notify_AppearActor() {
    return type == MessageType::World_Notify_AppearActor ?
      reinterpret_cast<ProtocolCS::World::Notify_AppearActorT *>(value) : nullptr;
  }
  ProtocolCS::World::Notify_DisappearActorT *AsWorld_Notify_DisappearActor() {
    return type == MessageType::World_Notify_DisappearActor ?
      reinterpret_cast<ProtocolCS::World::Notify_DisappearActorT *>(value) : nullptr;
  }
  ProtocolCS::World::Notify_MoveT *AsWorld_Notify_Move() {
    return type == MessageType::World_Notify_Move ?
      reinterpret_cast<ProtocolCS::World::Notify_MoveT *>(value) : nullptr;
  }
  ProtocolCS::World::Notify_AttackT *AsWorld_Notify_Attack() {
    return type == MessageType::World_Notify_Attack ?
      reinterpret_cast<ProtocolCS::World::Notify_AttackT *>(value) : nullptr;
  }
  ProtocolCS::World::Notify_DamageT *AsWorld_Notify_Damage() {
    return type == MessageType::World_Notify_Damage ?
      reinterpret_cast<ProtocolCS::World::Notify_DamageT *>(value) : nullptr;
  }
};

bool VerifyMessageType(flatbuffers::Verifier &verifier, const void *obj, MessageType type);
bool VerifyMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(this, 0, sizeof(Vec2));
  }
  Vec2(const Vec2 &_o) {
    memcpy(this, &_o, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(const Vec3 &_o) {
    memcpy(this, &_o, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
};
STRUCT_END(Vec3, 12);

struct Notify_UnauthedAccessT : public flatbuffers::NativeTable {
  typedef Notify_UnauthedAccess TableType;
  Notify_UnauthedAccessT() {
  }
};

struct Notify_UnauthedAccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_UnauthedAccessT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Notify_UnauthedAccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_UnauthedAccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_UnauthedAccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_UnauthedAccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Notify_UnauthedAccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_UnauthedAccessBuilder &operator=(const Notify_UnauthedAccessBuilder &);
  flatbuffers::Offset<Notify_UnauthedAccess> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Notify_UnauthedAccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_UnauthedAccess> CreateNotify_UnauthedAccess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Notify_UnauthedAccessBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Notify_UnauthedAccess> CreateNotify_UnauthedAccess(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

namespace Login {

struct CharacterT : public flatbuffers::NativeTable {
  typedef Character TableType;
  int32_t uid;
  std::string name;
  ProtocolCS::ClassType class_type;
  int32_t level;
  CharacterT()
      : uid(0),
        class_type(ProtocolCS::ClassType::NONE),
        level(0) {
  }
};

struct Character FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CharacterT NativeTableType;
  enum {
    VT_UID = 4,
    VT_NAME = 6,
    VT_CLASS_TYPE = 8,
    VT_LEVEL = 10
  };
  int32_t uid() const {
    return GetField<int32_t>(VT_UID, 0);
  }
  bool mutate_uid(int32_t _uid) {
    return SetField<int32_t>(VT_UID, _uid, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  ProtocolCS::ClassType class_type() const {
    return static_cast<ProtocolCS::ClassType>(GetField<int32_t>(VT_CLASS_TYPE, 0));
  }
  bool mutate_class_type(ProtocolCS::ClassType _class_type) {
    return SetField<int32_t>(VT_CLASS_TYPE, static_cast<int32_t>(_class_type), 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool mutate_level(int32_t _level) {
    return SetField<int32_t>(VT_LEVEL, _level, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
  CharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Character> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(int32_t uid) {
    fbb_.AddElement<int32_t>(Character::VT_UID, uid, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Character::VT_NAME, name);
  }
  void add_class_type(ProtocolCS::ClassType class_type) {
    fbb_.AddElement<int32_t>(Character::VT_CLASS_TYPE, static_cast<int32_t>(class_type), 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(Character::VT_LEVEL, level, 0);
  }
  CharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CharacterBuilder &operator=(const CharacterBuilder &);
  flatbuffers::Offset<Character> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Character>(end);
    return o;
  }
};

inline flatbuffers::Offset<Character> CreateCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t uid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE,
    int32_t level = 0) {
  CharacterBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_uid(uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Character> CreateCharacterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t uid = 0,
    const char *name = nullptr,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE,
    int32_t level = 0) {
  return ProtocolCS::Login::CreateCharacter(
      _fbb,
      uid,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      level);
}

flatbuffers::Offset<Character> CreateCharacter(flatbuffers::FlatBufferBuilder &_fbb, const CharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_LoginT : public flatbuffers::NativeTable {
  typedef Request_Login TableType;
  std::string user_name;
  std::string password;
  Request_LoginT() {
  }
};

struct Request_Login FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_LoginT NativeTableType;
  enum {
    VT_USER_NAME = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *user_name() const {
    return GetPointer<const flatbuffers::String *>(VT_USER_NAME);
  }
  flatbuffers::String *mutable_user_name() {
    return GetPointer<flatbuffers::String *>(VT_USER_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  flatbuffers::String *mutable_password() {
    return GetPointer<flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_NAME) &&
           verifier.Verify(user_name()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
  Request_LoginT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_LoginT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Login> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_LoginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user_name(flatbuffers::Offset<flatbuffers::String> user_name) {
    fbb_.AddOffset(Request_Login::VT_USER_NAME, user_name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(Request_Login::VT_PASSWORD, password);
  }
  Request_LoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_LoginBuilder &operator=(const Request_LoginBuilder &);
  flatbuffers::Offset<Request_Login> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_Login>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Login> CreateRequest_Login(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> user_name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  Request_LoginBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_user_name(user_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Login> CreateRequest_LoginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *user_name = nullptr,
    const char *password = nullptr) {
  return ProtocolCS::Login::CreateRequest_Login(
      _fbb,
      user_name ? _fbb.CreateString(user_name) : 0,
      password ? _fbb.CreateString(password) : 0);
}

flatbuffers::Offset<Request_Login> CreateRequest_Login(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_LoginSuccessT : public flatbuffers::NativeTable {
  typedef Reply_LoginSuccess TableType;
  std::string credential;
  Reply_LoginSuccessT() {
  }
};

struct Reply_LoginSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_LoginSuccessT NativeTableType;
  enum {
    VT_CREDENTIAL = 4
  };
  const flatbuffers::String *credential() const {
    return GetPointer<const flatbuffers::String *>(VT_CREDENTIAL);
  }
  flatbuffers::String *mutable_credential() {
    return GetPointer<flatbuffers::String *>(VT_CREDENTIAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CREDENTIAL) &&
           verifier.Verify(credential()) &&
           verifier.EndTable();
  }
  Reply_LoginSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_LoginSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_LoginSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_LoginSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_credential(flatbuffers::Offset<flatbuffers::String> credential) {
    fbb_.AddOffset(Reply_LoginSuccess::VT_CREDENTIAL, credential);
  }
  Reply_LoginSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_LoginSuccessBuilder &operator=(const Reply_LoginSuccessBuilder &);
  flatbuffers::Offset<Reply_LoginSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_LoginSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> credential = 0) {
  Reply_LoginSuccessBuilder builder_(_fbb);
  builder_.add_credential(credential);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccessDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *credential = nullptr) {
  return ProtocolCS::Login::CreateReply_LoginSuccess(
      _fbb,
      credential ? _fbb.CreateString(credential) : 0);
}

flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_LoginFailedT : public flatbuffers::NativeTable {
  typedef Reply_LoginFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Reply_LoginFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Reply_LoginFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_LoginFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_LoginFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_LoginFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_LoginFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_LoginFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_LoginFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_LoginFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_LoginFailedBuilder &operator=(const Reply_LoginFailedBuilder &);
  flatbuffers::Offset<Reply_LoginFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_LoginFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_LoginFailed> CreateReply_LoginFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Reply_LoginFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_LoginFailed> CreateReply_LoginFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_JoinT : public flatbuffers::NativeTable {
  typedef Request_Join TableType;
  std::string user_name;
  std::string password;
  Request_JoinT() {
  }
};

struct Request_Join FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_JoinT NativeTableType;
  enum {
    VT_USER_NAME = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *user_name() const {
    return GetPointer<const flatbuffers::String *>(VT_USER_NAME);
  }
  flatbuffers::String *mutable_user_name() {
    return GetPointer<flatbuffers::String *>(VT_USER_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  flatbuffers::String *mutable_password() {
    return GetPointer<flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_NAME) &&
           verifier.Verify(user_name()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
  Request_JoinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_JoinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Join> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_JoinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_JoinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user_name(flatbuffers::Offset<flatbuffers::String> user_name) {
    fbb_.AddOffset(Request_Join::VT_USER_NAME, user_name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(Request_Join::VT_PASSWORD, password);
  }
  Request_JoinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_JoinBuilder &operator=(const Request_JoinBuilder &);
  flatbuffers::Offset<Request_Join> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_Join>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Join> CreateRequest_Join(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> user_name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  Request_JoinBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_user_name(user_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_Join> CreateRequest_JoinDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *user_name = nullptr,
    const char *password = nullptr) {
  return ProtocolCS::Login::CreateRequest_Join(
      _fbb,
      user_name ? _fbb.CreateString(user_name) : 0,
      password ? _fbb.CreateString(password) : 0);
}

flatbuffers::Offset<Request_Join> CreateRequest_Join(flatbuffers::FlatBufferBuilder &_fbb, const Request_JoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_JoinSuccessT : public flatbuffers::NativeTable {
  typedef Reply_JoinSuccess TableType;
  Reply_JoinSuccessT() {
  }
};

struct Reply_JoinSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_JoinSuccessT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Reply_JoinSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_JoinSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_JoinSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_JoinSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Reply_JoinSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_JoinSuccessBuilder &operator=(const Reply_JoinSuccessBuilder &);
  flatbuffers::Offset<Reply_JoinSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Reply_JoinSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_JoinSuccess> CreateReply_JoinSuccess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Reply_JoinSuccessBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_JoinSuccess> CreateReply_JoinSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_JoinFailedT : public flatbuffers::NativeTable {
  typedef Reply_JoinFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Reply_JoinFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Reply_JoinFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_JoinFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_JoinFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_JoinFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_JoinFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_JoinFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_JoinFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_JoinFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_JoinFailedBuilder &operator=(const Reply_JoinFailedBuilder &);
  flatbuffers::Offset<Reply_JoinFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_JoinFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_JoinFailed> CreateReply_JoinFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Reply_JoinFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_JoinFailed> CreateReply_JoinFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_CharacterListT : public flatbuffers::NativeTable {
  typedef Request_CharacterList TableType;
  Request_CharacterListT() {
  }
};

struct Request_CharacterList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_CharacterListT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_CharacterListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_CharacterListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_CharacterList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_CharacterListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_CharacterListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Request_CharacterListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_CharacterListBuilder &operator=(const Request_CharacterListBuilder &);
  flatbuffers::Offset<Request_CharacterList> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Request_CharacterList>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_CharacterList> CreateRequest_CharacterList(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Request_CharacterListBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Request_CharacterList> CreateRequest_CharacterList(flatbuffers::FlatBufferBuilder &_fbb, const Request_CharacterListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_CharacterListT : public flatbuffers::NativeTable {
  typedef Reply_CharacterList TableType;
  std::vector<std::unique_ptr<CharacterT>> list;
  Reply_CharacterListT() {
  }
};

struct Reply_CharacterList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_CharacterListT NativeTableType;
  enum {
    VT_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Character>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Character>> *>(VT_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<Character>> *mutable_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Character>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.Verify(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
  Reply_CharacterListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_CharacterListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_CharacterList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CharacterListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_CharacterListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Character>>> list) {
    fbb_.AddOffset(Reply_CharacterList::VT_LIST, list);
  }
  Reply_CharacterListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_CharacterListBuilder &operator=(const Reply_CharacterListBuilder &);
  flatbuffers::Offset<Reply_CharacterList> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_CharacterList>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_CharacterList> CreateReply_CharacterList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Character>>> list = 0) {
  Reply_CharacterListBuilder builder_(_fbb);
  builder_.add_list(list);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reply_CharacterList> CreateReply_CharacterListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Character>> *list = nullptr) {
  return ProtocolCS::Login::CreateReply_CharacterList(
      _fbb,
      list ? _fbb.CreateVector<flatbuffers::Offset<Character>>(*list) : 0);
}

flatbuffers::Offset<Reply_CharacterList> CreateReply_CharacterList(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CharacterListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_CreateCharacterT : public flatbuffers::NativeTable {
  typedef Request_CreateCharacter TableType;
  std::string name;
  ProtocolCS::ClassType class_type;
  Request_CreateCharacterT()
      : class_type(ProtocolCS::ClassType::NONE) {
  }
};

struct Request_CreateCharacter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_CreateCharacterT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_CLASS_TYPE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  ProtocolCS::ClassType class_type() const {
    return static_cast<ProtocolCS::ClassType>(GetField<int32_t>(VT_CLASS_TYPE, 0));
  }
  bool mutate_class_type(ProtocolCS::ClassType _class_type) {
    return SetField<int32_t>(VT_CLASS_TYPE, static_cast<int32_t>(_class_type), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           verifier.EndTable();
  }
  Request_CreateCharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_CreateCharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_CreateCharacter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_CreateCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_CreateCharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Request_CreateCharacter::VT_NAME, name);
  }
  void add_class_type(ProtocolCS::ClassType class_type) {
    fbb_.AddElement<int32_t>(Request_CreateCharacter::VT_CLASS_TYPE, static_cast<int32_t>(class_type), 0);
  }
  Request_CreateCharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_CreateCharacterBuilder &operator=(const Request_CreateCharacterBuilder &);
  flatbuffers::Offset<Request_CreateCharacter> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Request_CreateCharacter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_CreateCharacter> CreateRequest_CreateCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE) {
  Request_CreateCharacterBuilder builder_(_fbb);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request_CreateCharacter> CreateRequest_CreateCharacterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE) {
  return ProtocolCS::Login::CreateRequest_CreateCharacter(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      class_type);
}

flatbuffers::Offset<Request_CreateCharacter> CreateRequest_CreateCharacter(flatbuffers::FlatBufferBuilder &_fbb, const Request_CreateCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_CreateCharacterSuccessT : public flatbuffers::NativeTable {
  typedef Reply_CreateCharacterSuccess TableType;
  std::unique_ptr<CharacterT> character;
  Reply_CreateCharacterSuccessT() {
  }
};

struct Reply_CreateCharacterSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_CreateCharacterSuccessT NativeTableType;
  enum {
    VT_CHARACTER = 4
  };
  const Character *character() const {
    return GetPointer<const Character *>(VT_CHARACTER);
  }
  Character *mutable_character() {
    return GetPointer<Character *>(VT_CHARACTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHARACTER) &&
           verifier.VerifyTable(character()) &&
           verifier.EndTable();
  }
  Reply_CreateCharacterSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_CreateCharacterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_CreateCharacterSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_CreateCharacterSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character(flatbuffers::Offset<Character> character) {
    fbb_.AddOffset(Reply_CreateCharacterSuccess::VT_CHARACTER, character);
  }
  Reply_CreateCharacterSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_CreateCharacterSuccessBuilder &operator=(const Reply_CreateCharacterSuccessBuilder &);
  flatbuffers::Offset<Reply_CreateCharacterSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_CreateCharacterSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_CreateCharacterSuccess> CreateReply_CreateCharacterSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Character> character = 0) {
  Reply_CreateCharacterSuccessBuilder builder_(_fbb);
  builder_.add_character(character);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_CreateCharacterSuccess> CreateReply_CreateCharacterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_CreateCharacterFailedT : public flatbuffers::NativeTable {
  typedef Reply_CreateCharacterFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Reply_CreateCharacterFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Reply_CreateCharacterFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_CreateCharacterFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_CreateCharacterFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_CreateCharacterFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_CreateCharacterFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_CreateCharacterFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_CreateCharacterFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_CreateCharacterFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_CreateCharacterFailedBuilder &operator=(const Reply_CreateCharacterFailedBuilder &);
  flatbuffers::Offset<Reply_CreateCharacterFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_CreateCharacterFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_CreateCharacterFailed> CreateReply_CreateCharacterFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Reply_CreateCharacterFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_CreateCharacterFailed> CreateReply_CreateCharacterFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_DeleteCharacterT : public flatbuffers::NativeTable {
  typedef Request_DeleteCharacter TableType;
  int32_t character_uid;
  Request_DeleteCharacterT()
      : character_uid(0) {
  }
};

struct Request_DeleteCharacter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_DeleteCharacterT NativeTableType;
  enum {
    VT_CHARACTER_UID = 4
  };
  int32_t character_uid() const {
    return GetField<int32_t>(VT_CHARACTER_UID, 0);
  }
  bool mutate_character_uid(int32_t _character_uid) {
    return SetField<int32_t>(VT_CHARACTER_UID, _character_uid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARACTER_UID) &&
           verifier.EndTable();
  }
  Request_DeleteCharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_DeleteCharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_DeleteCharacter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_DeleteCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_DeleteCharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character_uid(int32_t character_uid) {
    fbb_.AddElement<int32_t>(Request_DeleteCharacter::VT_CHARACTER_UID, character_uid, 0);
  }
  Request_DeleteCharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_DeleteCharacterBuilder &operator=(const Request_DeleteCharacterBuilder &);
  flatbuffers::Offset<Request_DeleteCharacter> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Request_DeleteCharacter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_DeleteCharacter> CreateRequest_DeleteCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_uid = 0) {
  Request_DeleteCharacterBuilder builder_(_fbb);
  builder_.add_character_uid(character_uid);
  return builder_.Finish();
}

flatbuffers::Offset<Request_DeleteCharacter> CreateRequest_DeleteCharacter(flatbuffers::FlatBufferBuilder &_fbb, const Request_DeleteCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_DeleteCharacterSuccessT : public flatbuffers::NativeTable {
  typedef Reply_DeleteCharacterSuccess TableType;
  int32_t character_uid;
  Reply_DeleteCharacterSuccessT()
      : character_uid(0) {
  }
};

struct Reply_DeleteCharacterSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_DeleteCharacterSuccessT NativeTableType;
  enum {
    VT_CHARACTER_UID = 4
  };
  int32_t character_uid() const {
    return GetField<int32_t>(VT_CHARACTER_UID, 0);
  }
  bool mutate_character_uid(int32_t _character_uid) {
    return SetField<int32_t>(VT_CHARACTER_UID, _character_uid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARACTER_UID) &&
           verifier.EndTable();
  }
  Reply_DeleteCharacterSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_DeleteCharacterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_DeleteCharacterSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_DeleteCharacterSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character_uid(int32_t character_uid) {
    fbb_.AddElement<int32_t>(Reply_DeleteCharacterSuccess::VT_CHARACTER_UID, character_uid, 0);
  }
  Reply_DeleteCharacterSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_DeleteCharacterSuccessBuilder &operator=(const Reply_DeleteCharacterSuccessBuilder &);
  flatbuffers::Offset<Reply_DeleteCharacterSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_DeleteCharacterSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_DeleteCharacterSuccess> CreateReply_DeleteCharacterSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_uid = 0) {
  Reply_DeleteCharacterSuccessBuilder builder_(_fbb);
  builder_.add_character_uid(character_uid);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_DeleteCharacterSuccess> CreateReply_DeleteCharacterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_DeleteCharacterFailedT : public flatbuffers::NativeTable {
  typedef Reply_DeleteCharacterFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Reply_DeleteCharacterFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Reply_DeleteCharacterFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_DeleteCharacterFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_DeleteCharacterFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_DeleteCharacterFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_DeleteCharacterFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_DeleteCharacterFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_DeleteCharacterFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_DeleteCharacterFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_DeleteCharacterFailedBuilder &operator=(const Reply_DeleteCharacterFailedBuilder &);
  flatbuffers::Offset<Reply_DeleteCharacterFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_DeleteCharacterFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_DeleteCharacterFailed> CreateReply_DeleteCharacterFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Reply_DeleteCharacterFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_DeleteCharacterFailed> CreateReply_DeleteCharacterFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace Login

namespace World {

struct PlayerCharacterT : public flatbuffers::NativeTable {
  typedef PlayerCharacter TableType;
  std::string entity_id;
  std::string name;
  ProtocolCS::ClassType class_type;
  int32_t exp;
  int32_t level;
  int32_t max_hp;
  int32_t hp;
  int32_t max_mp;
  int32_t mp;
  int32_t att;
  int32_t def;
  std::unique_ptr<ProtocolCS::Vec3> pos;
  float rotation;
  PlayerCharacterT()
      : class_type(ProtocolCS::ClassType::NONE),
        exp(0),
        level(0),
        max_hp(0),
        hp(0),
        max_mp(0),
        mp(0),
        att(0),
        def(0),
        rotation(0.0f) {
  }
};

struct PlayerCharacter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerCharacterT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_NAME = 6,
    VT_CLASS_TYPE = 8,
    VT_EXP = 10,
    VT_LEVEL = 12,
    VT_MAX_HP = 14,
    VT_HP = 16,
    VT_MAX_MP = 18,
    VT_MP = 20,
    VT_ATT = 22,
    VT_DEF = 24,
    VT_POS = 26,
    VT_ROTATION = 28
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  ProtocolCS::ClassType class_type() const {
    return static_cast<ProtocolCS::ClassType>(GetField<int32_t>(VT_CLASS_TYPE, 0));
  }
  bool mutate_class_type(ProtocolCS::ClassType _class_type) {
    return SetField<int32_t>(VT_CLASS_TYPE, static_cast<int32_t>(_class_type), 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  bool mutate_exp(int32_t _exp) {
    return SetField<int32_t>(VT_EXP, _exp, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool mutate_level(int32_t _level) {
    return SetField<int32_t>(VT_LEVEL, _level, 0);
  }
  int32_t max_hp() const {
    return GetField<int32_t>(VT_MAX_HP, 0);
  }
  bool mutate_max_hp(int32_t _max_hp) {
    return SetField<int32_t>(VT_MAX_HP, _max_hp, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  bool mutate_hp(int32_t _hp) {
    return SetField<int32_t>(VT_HP, _hp, 0);
  }
  int32_t max_mp() const {
    return GetField<int32_t>(VT_MAX_MP, 0);
  }
  bool mutate_max_mp(int32_t _max_mp) {
    return SetField<int32_t>(VT_MAX_MP, _max_mp, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  bool mutate_mp(int32_t _mp) {
    return SetField<int32_t>(VT_MP, _mp, 0);
  }
  int32_t att() const {
    return GetField<int32_t>(VT_ATT, 0);
  }
  bool mutate_att(int32_t _att) {
    return SetField<int32_t>(VT_ATT, _att, 0);
  }
  int32_t def() const {
    return GetField<int32_t>(VT_DEF, 0);
  }
  bool mutate_def(int32_t _def) {
    return SetField<int32_t>(VT_DEF, _def, 0);
  }
  const ProtocolCS::Vec3 *pos() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_POS);
  }
  ProtocolCS::Vec3 *mutable_pos() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_POS);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_MAX_HP) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MAX_MP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<int32_t>(verifier, VT_ATT) &&
           VerifyField<int32_t>(verifier, VT_DEF) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  PlayerCharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerCharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PlayerCharacter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerCharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(PlayerCharacter::VT_ENTITY_ID, entity_id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PlayerCharacter::VT_NAME, name);
  }
  void add_class_type(ProtocolCS::ClassType class_type) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_CLASS_TYPE, static_cast<int32_t>(class_type), 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_EXP, exp, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_LEVEL, level, 0);
  }
  void add_max_hp(int32_t max_hp) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_MAX_HP, max_hp, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_HP, hp, 0);
  }
  void add_max_mp(int32_t max_mp) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_MAX_MP, max_mp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_MP, mp, 0);
  }
  void add_att(int32_t att) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_ATT, att, 0);
  }
  void add_def(int32_t def) {
    fbb_.AddElement<int32_t>(PlayerCharacter::VT_DEF, def, 0);
  }
  void add_pos(const ProtocolCS::Vec3 *pos) {
    fbb_.AddStruct(PlayerCharacter::VT_POS, pos);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(PlayerCharacter::VT_ROTATION, rotation, 0.0f);
  }
  PlayerCharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerCharacterBuilder &operator=(const PlayerCharacterBuilder &);
  flatbuffers::Offset<PlayerCharacter> Finish() {
    const auto end = fbb_.EndTable(start_, 13);
    auto o = flatbuffers::Offset<PlayerCharacter>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerCharacter> CreatePlayerCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE,
    int32_t exp = 0,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    int32_t att = 0,
    int32_t def = 0,
    const ProtocolCS::Vec3 *pos = 0,
    float rotation = 0.0f) {
  PlayerCharacterBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_pos(pos);
  builder_.add_def(def);
  builder_.add_att(att);
  builder_.add_mp(mp);
  builder_.add_max_mp(max_mp);
  builder_.add_hp(hp);
  builder_.add_max_hp(max_hp);
  builder_.add_level(level);
  builder_.add_exp(exp);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerCharacter> CreatePlayerCharacterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    const char *name = nullptr,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE,
    int32_t exp = 0,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    int32_t att = 0,
    int32_t def = 0,
    const ProtocolCS::Vec3 *pos = 0,
    float rotation = 0.0f) {
  return ProtocolCS::World::CreatePlayerCharacter(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      exp,
      level,
      max_hp,
      hp,
      max_mp,
      mp,
      att,
      def,
      pos,
      rotation);
}

flatbuffers::Offset<PlayerCharacter> CreatePlayerCharacter(flatbuffers::FlatBufferBuilder &_fbb, const PlayerCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RemotePCT : public flatbuffers::NativeTable {
  typedef RemotePC TableType;
  std::string entity_id;
  std::string name;
  ProtocolCS::ClassType class_type;
  int32_t level;
  int32_t max_hp;
  int32_t hp;
  int32_t max_mp;
  int32_t mp;
  std::unique_ptr<ProtocolCS::Vec3> pos;
  float rotation;
  RemotePCT()
      : class_type(ProtocolCS::ClassType::NONE),
        level(0),
        max_hp(0),
        hp(0),
        max_mp(0),
        mp(0),
        rotation(0.0f) {
  }
};

struct RemotePC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RemotePCT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_NAME = 6,
    VT_CLASS_TYPE = 8,
    VT_LEVEL = 10,
    VT_MAX_HP = 12,
    VT_HP = 14,
    VT_MAX_MP = 16,
    VT_MP = 18,
    VT_POS = 20,
    VT_ROTATION = 22
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  ProtocolCS::ClassType class_type() const {
    return static_cast<ProtocolCS::ClassType>(GetField<int32_t>(VT_CLASS_TYPE, 0));
  }
  bool mutate_class_type(ProtocolCS::ClassType _class_type) {
    return SetField<int32_t>(VT_CLASS_TYPE, static_cast<int32_t>(_class_type), 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool mutate_level(int32_t _level) {
    return SetField<int32_t>(VT_LEVEL, _level, 0);
  }
  int32_t max_hp() const {
    return GetField<int32_t>(VT_MAX_HP, 0);
  }
  bool mutate_max_hp(int32_t _max_hp) {
    return SetField<int32_t>(VT_MAX_HP, _max_hp, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  bool mutate_hp(int32_t _hp) {
    return SetField<int32_t>(VT_HP, _hp, 0);
  }
  int32_t max_mp() const {
    return GetField<int32_t>(VT_MAX_MP, 0);
  }
  bool mutate_max_mp(int32_t _max_mp) {
    return SetField<int32_t>(VT_MAX_MP, _max_mp, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  bool mutate_mp(int32_t _mp) {
    return SetField<int32_t>(VT_MP, _mp, 0);
  }
  const ProtocolCS::Vec3 *pos() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_POS);
  }
  ProtocolCS::Vec3 *mutable_pos() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_POS);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_MAX_HP) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MAX_MP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  RemotePCT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RemotePCT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RemotePC> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemotePCT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RemotePCBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(RemotePC::VT_ENTITY_ID, entity_id);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RemotePC::VT_NAME, name);
  }
  void add_class_type(ProtocolCS::ClassType class_type) {
    fbb_.AddElement<int32_t>(RemotePC::VT_CLASS_TYPE, static_cast<int32_t>(class_type), 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(RemotePC::VT_LEVEL, level, 0);
  }
  void add_max_hp(int32_t max_hp) {
    fbb_.AddElement<int32_t>(RemotePC::VT_MAX_HP, max_hp, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(RemotePC::VT_HP, hp, 0);
  }
  void add_max_mp(int32_t max_mp) {
    fbb_.AddElement<int32_t>(RemotePC::VT_MAX_MP, max_mp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(RemotePC::VT_MP, mp, 0);
  }
  void add_pos(const ProtocolCS::Vec3 *pos) {
    fbb_.AddStruct(RemotePC::VT_POS, pos);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(RemotePC::VT_ROTATION, rotation, 0.0f);
  }
  RemotePCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemotePCBuilder &operator=(const RemotePCBuilder &);
  flatbuffers::Offset<RemotePC> Finish() {
    const auto end = fbb_.EndTable(start_, 10);
    auto o = flatbuffers::Offset<RemotePC>(end);
    return o;
  }
};

inline flatbuffers::Offset<RemotePC> CreateRemotePC(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    const ProtocolCS::Vec3 *pos = 0,
    float rotation = 0.0f) {
  RemotePCBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_pos(pos);
  builder_.add_mp(mp);
  builder_.add_max_mp(max_mp);
  builder_.add_hp(hp);
  builder_.add_max_hp(max_hp);
  builder_.add_level(level);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<RemotePC> CreateRemotePCDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    const char *name = nullptr,
    ProtocolCS::ClassType class_type = ProtocolCS::ClassType::NONE,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    const ProtocolCS::Vec3 *pos = 0,
    float rotation = 0.0f) {
  return ProtocolCS::World::CreateRemotePC(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      level,
      max_hp,
      hp,
      max_mp,
      mp,
      pos,
      rotation);
}

flatbuffers::Offset<RemotePC> CreateRemotePC(flatbuffers::FlatBufferBuilder &_fbb, const RemotePCT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MonsterT : public flatbuffers::NativeTable {
  typedef Monster TableType;
  std::string entity_id;
  int32_t type_id;
  std::string name;
  int32_t level;
  int32_t max_hp;
  int32_t hp;
  int32_t max_mp;
  int32_t mp;
  std::unique_ptr<ProtocolCS::Vec3> pos;
  float rotation;
  MonsterT()
      : type_id(0),
        level(0),
        max_hp(0),
        hp(0),
        max_mp(0),
        mp(0),
        rotation(0.0f) {
  }
};

struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MonsterT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_TYPE_ID = 6,
    VT_NAME = 8,
    VT_LEVEL = 10,
    VT_MAX_HP = 12,
    VT_HP = 14,
    VT_MAX_MP = 16,
    VT_MP = 18,
    VT_POS = 20,
    VT_ROTATION = 22
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  int32_t type_id() const {
    return GetField<int32_t>(VT_TYPE_ID, 0);
  }
  bool mutate_type_id(int32_t _type_id) {
    return SetField<int32_t>(VT_TYPE_ID, _type_id, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool mutate_level(int32_t _level) {
    return SetField<int32_t>(VT_LEVEL, _level, 0);
  }
  int32_t max_hp() const {
    return GetField<int32_t>(VT_MAX_HP, 0);
  }
  bool mutate_max_hp(int32_t _max_hp) {
    return SetField<int32_t>(VT_MAX_HP, _max_hp, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  bool mutate_hp(int32_t _hp) {
    return SetField<int32_t>(VT_HP, _hp, 0);
  }
  int32_t max_mp() const {
    return GetField<int32_t>(VT_MAX_MP, 0);
  }
  bool mutate_max_mp(int32_t _max_mp) {
    return SetField<int32_t>(VT_MAX_MP, _max_mp, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  bool mutate_mp(int32_t _mp) {
    return SetField<int32_t>(VT_MP, _mp, 0);
  }
  const ProtocolCS::Vec3 *pos() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_POS);
  }
  ProtocolCS::Vec3 *mutable_pos() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_POS);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<int32_t>(verifier, VT_TYPE_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_MAX_HP) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MAX_MP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  MonsterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MonsterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Monster> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MonsterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(Monster::VT_ENTITY_ID, entity_id);
  }
  void add_type_id(int32_t type_id) {
    fbb_.AddElement<int32_t>(Monster::VT_TYPE_ID, type_id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Monster::VT_NAME, name);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(Monster::VT_LEVEL, level, 0);
  }
  void add_max_hp(int32_t max_hp) {
    fbb_.AddElement<int32_t>(Monster::VT_MAX_HP, max_hp, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(Monster::VT_HP, hp, 0);
  }
  void add_max_mp(int32_t max_mp) {
    fbb_.AddElement<int32_t>(Monster::VT_MAX_MP, max_mp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(Monster::VT_MP, mp, 0);
  }
  void add_pos(const ProtocolCS::Vec3 *pos) {
    fbb_.AddStruct(Monster::VT_POS, pos);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(Monster::VT_ROTATION, rotation, 0.0f);
  }
  MonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MonsterBuilder &operator=(const MonsterBuilder &);
  flatbuffers::Offset<Monster> Finish() {
    const auto end = fbb_.EndTable(start_, 10);
    auto o = flatbuffers::Offset<Monster>(end);
    return o;
  }
};

inline flatbuffers::Offset<Monster> CreateMonster(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    int32_t type_id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    const ProtocolCS::Vec3 *pos = 0,
    float rotation = 0.0f) {
  MonsterBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_pos(pos);
  builder_.add_mp(mp);
  builder_.add_max_mp(max_mp);
  builder_.add_hp(hp);
  builder_.add_max_hp(max_hp);
  builder_.add_level(level);
  builder_.add_name(name);
  builder_.add_type_id(type_id);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Monster> CreateMonsterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    int32_t type_id = 0,
    const char *name = nullptr,
    int32_t level = 0,
    int32_t max_hp = 0,
    int32_t hp = 0,
    int32_t max_mp = 0,
    int32_t mp = 0,
    const ProtocolCS::Vec3 *pos = 0,
    float rotation = 0.0f) {
  return ProtocolCS::World::CreateMonster(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      type_id,
      name ? _fbb.CreateString(name) : 0,
      level,
      max_hp,
      hp,
      max_mp,
      mp,
      pos,
      rotation);
}

flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveDataT : public flatbuffers::NativeTable {
  typedef MoveData TableType;
  std::string entity_id;
  std::unique_ptr<ProtocolCS::Vec3> position;
  float rotation;
  std::unique_ptr<ProtocolCS::Vec3> velocity;
  MoveDataT()
      : rotation(0.0f) {
  }
};

struct MoveData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoveDataT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_POSITION = 6,
    VT_ROTATION = 8,
    VT_VELOCITY = 10
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  const ProtocolCS::Vec3 *position() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_POSITION);
  }
  ProtocolCS::Vec3 *mutable_position() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_POSITION);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  const ProtocolCS::Vec3 *velocity() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_VELOCITY);
  }
  ProtocolCS::Vec3 *mutable_velocity() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_VELOCITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_POSITION) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_VELOCITY) &&
           verifier.EndTable();
  }
  MoveDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MoveData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(MoveData::VT_ENTITY_ID, entity_id);
  }
  void add_position(const ProtocolCS::Vec3 *position) {
    fbb_.AddStruct(MoveData::VT_POSITION, position);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(MoveData::VT_ROTATION, rotation, 0.0f);
  }
  void add_velocity(const ProtocolCS::Vec3 *velocity) {
    fbb_.AddStruct(MoveData::VT_VELOCITY, velocity);
  }
  MoveDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveDataBuilder &operator=(const MoveDataBuilder &);
  flatbuffers::Offset<MoveData> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<MoveData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveData> CreateMoveData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    const ProtocolCS::Vec3 *position = 0,
    float rotation = 0.0f,
    const ProtocolCS::Vec3 *velocity = 0) {
  MoveDataBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MoveData> CreateMoveDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    const ProtocolCS::Vec3 *position = 0,
    float rotation = 0.0f,
    const ProtocolCS::Vec3 *velocity = 0) {
  return ProtocolCS::World::CreateMoveData(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      position,
      rotation,
      velocity);
}

flatbuffers::Offset<MoveData> CreateMoveData(flatbuffers::FlatBufferBuilder &_fbb, const MoveDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AttackDataT : public flatbuffers::NativeTable {
  typedef AttackData TableType;
  std::string entity_id;
  float rotation;
  AttackDataT()
      : rotation(0.0f) {
  }
};

struct AttackData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttackDataT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_ROTATION = 6
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  AttackDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AttackDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AttackData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttackDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AttackDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(AttackData::VT_ENTITY_ID, entity_id);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(AttackData::VT_ROTATION, rotation, 0.0f);
  }
  AttackDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttackDataBuilder &operator=(const AttackDataBuilder &);
  flatbuffers::Offset<AttackData> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AttackData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttackData> CreateAttackData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    float rotation = 0.0f) {
  AttackDataBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttackData> CreateAttackDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    float rotation = 0.0f) {
  return ProtocolCS::World::CreateAttackData(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      rotation);
}

flatbuffers::Offset<AttackData> CreateAttackData(flatbuffers::FlatBufferBuilder &_fbb, const AttackDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DamageDataT : public flatbuffers::NativeTable {
  typedef DamageData TableType;
  std::string entity_id;
  int32_t damage;
  DamageDataT()
      : damage(0) {
  }
};

struct DamageData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DamageDataT NativeTableType;
  enum {
    VT_ENTITY_ID = 4,
    VT_DAMAGE = 6
  };
  const flatbuffers::String *entity_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTITY_ID);
  }
  flatbuffers::String *mutable_entity_id() {
    return GetPointer<flatbuffers::String *>(VT_ENTITY_ID);
  }
  int32_t damage() const {
    return GetField<int32_t>(VT_DAMAGE, 0);
  }
  bool mutate_damage(int32_t _damage) {
    return SetField<int32_t>(VT_DAMAGE, _damage, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.Verify(entity_id()) &&
           VerifyField<int32_t>(verifier, VT_DAMAGE) &&
           verifier.EndTable();
  }
  DamageDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DamageDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DamageData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DamageDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DamageDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id(flatbuffers::Offset<flatbuffers::String> entity_id) {
    fbb_.AddOffset(DamageData::VT_ENTITY_ID, entity_id);
  }
  void add_damage(int32_t damage) {
    fbb_.AddElement<int32_t>(DamageData::VT_DAMAGE, damage, 0);
  }
  DamageDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DamageDataBuilder &operator=(const DamageDataBuilder &);
  flatbuffers::Offset<DamageData> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<DamageData>(end);
    return o;
  }
};

inline flatbuffers::Offset<DamageData> CreateDamageData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> entity_id = 0,
    int32_t damage = 0) {
  DamageDataBuilder builder_(_fbb);
  builder_.add_damage(damage);
  builder_.add_entity_id(entity_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DamageData> CreateDamageDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *entity_id = nullptr,
    int32_t damage = 0) {
  return ProtocolCS::World::CreateDamageData(
      _fbb,
      entity_id ? _fbb.CreateString(entity_id) : 0,
      damage);
}

flatbuffers::Offset<DamageData> CreateDamageData(flatbuffers::FlatBufferBuilder &_fbb, const DamageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_EnterWorldT : public flatbuffers::NativeTable {
  typedef Request_EnterWorld TableType;
  int32_t character_uid;
  Request_EnterWorldT()
      : character_uid(0) {
  }
};

struct Request_EnterWorld FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_EnterWorldT NativeTableType;
  enum {
    VT_CHARACTER_UID = 4
  };
  int32_t character_uid() const {
    return GetField<int32_t>(VT_CHARACTER_UID, 0);
  }
  bool mutate_character_uid(int32_t _character_uid) {
    return SetField<int32_t>(VT_CHARACTER_UID, _character_uid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARACTER_UID) &&
           verifier.EndTable();
  }
  Request_EnterWorldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_EnterWorldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_EnterWorld> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_EnterWorldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character_uid(int32_t character_uid) {
    fbb_.AddElement<int32_t>(Request_EnterWorld::VT_CHARACTER_UID, character_uid, 0);
  }
  Request_EnterWorldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_EnterWorldBuilder &operator=(const Request_EnterWorldBuilder &);
  flatbuffers::Offset<Request_EnterWorld> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Request_EnterWorld>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_EnterWorld> CreateRequest_EnterWorld(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_uid = 0) {
  Request_EnterWorldBuilder builder_(_fbb);
  builder_.add_character_uid(character_uid);
  return builder_.Finish();
}

flatbuffers::Offset<Request_EnterWorld> CreateRequest_EnterWorld(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_EnterWorldSuccessT : public flatbuffers::NativeTable {
  typedef Reply_EnterWorldSuccess TableType;
  Reply_EnterWorldSuccessT() {
  }
};

struct Reply_EnterWorldSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_EnterWorldSuccessT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Reply_EnterWorldSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_EnterWorldSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_EnterWorldSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_EnterWorldSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Reply_EnterWorldSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_EnterWorldSuccessBuilder &operator=(const Reply_EnterWorldSuccessBuilder &);
  flatbuffers::Offset<Reply_EnterWorldSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Reply_EnterWorldSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_EnterWorldSuccess> CreateReply_EnterWorldSuccess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Reply_EnterWorldSuccessBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_EnterWorldSuccess> CreateReply_EnterWorldSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_EnterWorldFailedT : public flatbuffers::NativeTable {
  typedef Reply_EnterWorldFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Reply_EnterWorldFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Reply_EnterWorldFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_EnterWorldFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_EnterWorldFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_EnterWorldFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_EnterWorldFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_EnterWorldFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_EnterWorldFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_EnterWorldFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_EnterWorldFailedBuilder &operator=(const Reply_EnterWorldFailedBuilder &);
  flatbuffers::Offset<Reply_EnterWorldFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_EnterWorldFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_EnterWorldFailed> CreateReply_EnterWorldFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Reply_EnterWorldFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_EnterWorldFailed> CreateReply_EnterWorldFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_EnterWorldNextT : public flatbuffers::NativeTable {
  typedef Request_EnterWorldNext TableType;
  Request_EnterWorldNextT() {
  }
};

struct Request_EnterWorldNext FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_EnterWorldNextT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  Request_EnterWorldNextT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_EnterWorldNextT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_EnterWorldNext> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldNextT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_EnterWorldNextBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  Request_EnterWorldNextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_EnterWorldNextBuilder &operator=(const Request_EnterWorldNextBuilder &);
  flatbuffers::Offset<Request_EnterWorldNext> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Request_EnterWorldNext>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_EnterWorldNext> CreateRequest_EnterWorldNext(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Request_EnterWorldNextBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<Request_EnterWorldNext> CreateRequest_EnterWorldNext(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldNextT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_EnterWorldNextSuccessT : public flatbuffers::NativeTable {
  typedef Reply_EnterWorldNextSuccess TableType;
  std::unique_ptr<PlayerCharacterT> character;
  Reply_EnterWorldNextSuccessT() {
  }
};

struct Reply_EnterWorldNextSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_EnterWorldNextSuccessT NativeTableType;
  enum {
    VT_CHARACTER = 4
  };
  const PlayerCharacter *character() const {
    return GetPointer<const PlayerCharacter *>(VT_CHARACTER);
  }
  PlayerCharacter *mutable_character() {
    return GetPointer<PlayerCharacter *>(VT_CHARACTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHARACTER) &&
           verifier.VerifyTable(character()) &&
           verifier.EndTable();
  }
  Reply_EnterWorldNextSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_EnterWorldNextSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_EnterWorldNextSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_EnterWorldNextSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character(flatbuffers::Offset<PlayerCharacter> character) {
    fbb_.AddOffset(Reply_EnterWorldNextSuccess::VT_CHARACTER, character);
  }
  Reply_EnterWorldNextSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_EnterWorldNextSuccessBuilder &operator=(const Reply_EnterWorldNextSuccessBuilder &);
  flatbuffers::Offset<Reply_EnterWorldNextSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_EnterWorldNextSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_EnterWorldNextSuccess> CreateReply_EnterWorldNextSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<PlayerCharacter> character = 0) {
  Reply_EnterWorldNextSuccessBuilder builder_(_fbb);
  builder_.add_character(character);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_EnterWorldNextSuccess> CreateReply_EnterWorldNextSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Reply_EnterWorldNextFailedT : public flatbuffers::NativeTable {
  typedef Reply_EnterWorldNextFailed TableType;
  ProtocolCS::ErrorCode error_code;
  Reply_EnterWorldNextFailedT()
      : error_code(ProtocolCS::ErrorCode::OK) {
  }
};

struct Reply_EnterWorldNextFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Reply_EnterWorldNextFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ProtocolCS::ErrorCode error_code() const {
    return static_cast<ProtocolCS::ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool mutate_error_code(ProtocolCS::ErrorCode _error_code) {
    return SetField<int32_t>(VT_ERROR_CODE, static_cast<int32_t>(_error_code), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  Reply_EnterWorldNextFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Reply_EnterWorldNextFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reply_EnterWorldNextFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Reply_EnterWorldNextFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ProtocolCS::ErrorCode error_code) {
    fbb_.AddElement<int32_t>(Reply_EnterWorldNextFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  Reply_EnterWorldNextFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Reply_EnterWorldNextFailedBuilder &operator=(const Reply_EnterWorldNextFailedBuilder &);
  flatbuffers::Offset<Reply_EnterWorldNextFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Reply_EnterWorldNextFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reply_EnterWorldNextFailed> CreateReply_EnterWorldNextFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ProtocolCS::ErrorCode error_code = ProtocolCS::ErrorCode::OK) {
  Reply_EnterWorldNextFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<Reply_EnterWorldNextFailed> CreateReply_EnterWorldNextFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_EnterZoneT : public flatbuffers::NativeTable {
  typedef Notify_EnterZone TableType;
  int32_t map_id;
  std::unique_ptr<ProtocolCS::Vec3> position;
  float rotation;
  Notify_EnterZoneT()
      : map_id(0),
        rotation(0.0f) {
  }
};

struct Notify_EnterZone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_EnterZoneT NativeTableType;
  enum {
    VT_MAP_ID = 4,
    VT_POSITION = 6,
    VT_ROTATION = 8
  };
  int32_t map_id() const {
    return GetField<int32_t>(VT_MAP_ID, 0);
  }
  bool mutate_map_id(int32_t _map_id) {
    return SetField<int32_t>(VT_MAP_ID, _map_id, 0);
  }
  const ProtocolCS::Vec3 *position() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_POSITION);
  }
  ProtocolCS::Vec3 *mutable_position() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_POSITION);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAP_ID) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_POSITION) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  Notify_EnterZoneT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_EnterZoneT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_EnterZone> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterZoneT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_EnterZoneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_map_id(int32_t map_id) {
    fbb_.AddElement<int32_t>(Notify_EnterZone::VT_MAP_ID, map_id, 0);
  }
  void add_position(const ProtocolCS::Vec3 *position) {
    fbb_.AddStruct(Notify_EnterZone::VT_POSITION, position);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(Notify_EnterZone::VT_ROTATION, rotation, 0.0f);
  }
  Notify_EnterZoneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_EnterZoneBuilder &operator=(const Notify_EnterZoneBuilder &);
  flatbuffers::Offset<Notify_EnterZone> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Notify_EnterZone>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_EnterZone> CreateNotify_EnterZone(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t map_id = 0,
    const ProtocolCS::Vec3 *position = 0,
    float rotation = 0.0f) {
  Notify_EnterZoneBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_map_id(map_id);
  return builder_.Finish();
}

flatbuffers::Offset<Notify_EnterZone> CreateNotify_EnterZone(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterZoneT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_MoveT : public flatbuffers::NativeTable {
  typedef Request_Move TableType;
  std::unique_ptr<ProtocolCS::Vec3> position;
  float rotation;
  std::unique_ptr<ProtocolCS::Vec3> velocity;
  Request_MoveT()
      : rotation(0.0f) {
  }
};

struct Request_Move FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_MoveT NativeTableType;
  enum {
    VT_POSITION = 4,
    VT_ROTATION = 6,
    VT_VELOCITY = 8
  };
  const ProtocolCS::Vec3 *position() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_POSITION);
  }
  ProtocolCS::Vec3 *mutable_position() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_POSITION);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  const ProtocolCS::Vec3 *velocity() const {
    return GetStruct<const ProtocolCS::Vec3 *>(VT_VELOCITY);
  }
  ProtocolCS::Vec3 *mutable_velocity() {
    return GetStruct<ProtocolCS::Vec3 *>(VT_VELOCITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_POSITION) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           VerifyField<ProtocolCS::Vec3>(verifier, VT_VELOCITY) &&
           verifier.EndTable();
  }
  Request_MoveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_MoveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Move> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_MoveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_MoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const ProtocolCS::Vec3 *position) {
    fbb_.AddStruct(Request_Move::VT_POSITION, position);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(Request_Move::VT_ROTATION, rotation, 0.0f);
  }
  void add_velocity(const ProtocolCS::Vec3 *velocity) {
    fbb_.AddStruct(Request_Move::VT_VELOCITY, velocity);
  }
  Request_MoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_MoveBuilder &operator=(const Request_MoveBuilder &);
  flatbuffers::Offset<Request_Move> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Request_Move>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Move> CreateRequest_Move(
    flatbuffers::FlatBufferBuilder &_fbb,
    const ProtocolCS::Vec3 *position = 0,
    float rotation = 0.0f,
    const ProtocolCS::Vec3 *velocity = 0) {
  Request_MoveBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  return builder_.Finish();
}

flatbuffers::Offset<Request_Move> CreateRequest_Move(flatbuffers::FlatBufferBuilder &_fbb, const Request_MoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Request_AttackT : public flatbuffers::NativeTable {
  typedef Request_Attack TableType;
  float rotation;
  Request_AttackT()
      : rotation(0.0f) {
  }
};

struct Request_Attack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Request_AttackT NativeTableType;
  enum {
    VT_ROTATION = 4
  };
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool mutate_rotation(float _rotation) {
    return SetField<float>(VT_ROTATION, _rotation, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
  Request_AttackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Request_AttackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request_Attack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_AttackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Request_AttackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(Request_Attack::VT_ROTATION, rotation, 0.0f);
  }
  Request_AttackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Request_AttackBuilder &operator=(const Request_AttackBuilder &);
  flatbuffers::Offset<Request_Attack> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Request_Attack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request_Attack> CreateRequest_Attack(
    flatbuffers::FlatBufferBuilder &_fbb,
    float rotation = 0.0f) {
  Request_AttackBuilder builder_(_fbb);
  builder_.add_rotation(rotation);
  return builder_.Finish();
}

flatbuffers::Offset<Request_Attack> CreateRequest_Attack(flatbuffers::FlatBufferBuilder &_fbb, const Request_AttackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_AppearActorT : public flatbuffers::NativeTable {
  typedef Notify_AppearActor TableType;
  std::vector<std::unique_ptr<RemotePCT>> remote_pc_list;
  std::vector<std::unique_ptr<MonsterT>> monster_list;
  Notify_AppearActorT() {
  }
};

struct Notify_AppearActor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_AppearActorT NativeTableType;
  enum {
    VT_REMOTE_PC_LIST = 4,
    VT_MONSTER_LIST = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<RemotePC>> *remote_pc_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RemotePC>> *>(VT_REMOTE_PC_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<RemotePC>> *mutable_remote_pc_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<RemotePC>> *>(VT_REMOTE_PC_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Monster>> *monster_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Monster>> *>(VT_MONSTER_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<Monster>> *mutable_monster_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Monster>> *>(VT_MONSTER_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REMOTE_PC_LIST) &&
           verifier.Verify(remote_pc_list()) &&
           verifier.VerifyVectorOfTables(remote_pc_list()) &&
           VerifyOffset(verifier, VT_MONSTER_LIST) &&
           verifier.Verify(monster_list()) &&
           verifier.VerifyVectorOfTables(monster_list()) &&
           verifier.EndTable();
  }
  Notify_AppearActorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_AppearActorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_AppearActor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AppearActorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_AppearActorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_remote_pc_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RemotePC>>> remote_pc_list) {
    fbb_.AddOffset(Notify_AppearActor::VT_REMOTE_PC_LIST, remote_pc_list);
  }
  void add_monster_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Monster>>> monster_list) {
    fbb_.AddOffset(Notify_AppearActor::VT_MONSTER_LIST, monster_list);
  }
  Notify_AppearActorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_AppearActorBuilder &operator=(const Notify_AppearActorBuilder &);
  flatbuffers::Offset<Notify_AppearActor> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Notify_AppearActor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_AppearActor> CreateNotify_AppearActor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RemotePC>>> remote_pc_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Monster>>> monster_list = 0) {
  Notify_AppearActorBuilder builder_(_fbb);
  builder_.add_monster_list(monster_list);
  builder_.add_remote_pc_list(remote_pc_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_AppearActor> CreateNotify_AppearActorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<RemotePC>> *remote_pc_list = nullptr,
    const std::vector<flatbuffers::Offset<Monster>> *monster_list = nullptr) {
  return ProtocolCS::World::CreateNotify_AppearActor(
      _fbb,
      remote_pc_list ? _fbb.CreateVector<flatbuffers::Offset<RemotePC>>(*remote_pc_list) : 0,
      monster_list ? _fbb.CreateVector<flatbuffers::Offset<Monster>>(*monster_list) : 0);
}

flatbuffers::Offset<Notify_AppearActor> CreateNotify_AppearActor(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AppearActorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_DisappearActorT : public flatbuffers::NativeTable {
  typedef Notify_DisappearActor TableType;
  std::vector<std::string> entity_id_list;
  Notify_DisappearActorT() {
  }
};

struct Notify_DisappearActor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_DisappearActorT NativeTableType;
  enum {
    VT_ENTITY_ID_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *entity_id_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ENTITY_ID_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_entity_id_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ENTITY_ID_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID_LIST) &&
           verifier.Verify(entity_id_list()) &&
           verifier.VerifyVectorOfStrings(entity_id_list()) &&
           verifier.EndTable();
  }
  Notify_DisappearActorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_DisappearActorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_DisappearActor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DisappearActorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_DisappearActorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity_id_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> entity_id_list) {
    fbb_.AddOffset(Notify_DisappearActor::VT_ENTITY_ID_LIST, entity_id_list);
  }
  Notify_DisappearActorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_DisappearActorBuilder &operator=(const Notify_DisappearActorBuilder &);
  flatbuffers::Offset<Notify_DisappearActor> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Notify_DisappearActor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_DisappearActor> CreateNotify_DisappearActor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> entity_id_list = 0) {
  Notify_DisappearActorBuilder builder_(_fbb);
  builder_.add_entity_id_list(entity_id_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_DisappearActor> CreateNotify_DisappearActorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *entity_id_list = nullptr) {
  return ProtocolCS::World::CreateNotify_DisappearActor(
      _fbb,
      entity_id_list ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*entity_id_list) : 0);
}

flatbuffers::Offset<Notify_DisappearActor> CreateNotify_DisappearActor(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DisappearActorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_MoveT : public flatbuffers::NativeTable {
  typedef Notify_Move TableType;
  std::vector<std::unique_ptr<MoveDataT>> move_list;
  Notify_MoveT() {
  }
};

struct Notify_Move FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_MoveT NativeTableType;
  enum {
    VT_MOVE_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<MoveData>> *move_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MoveData>> *>(VT_MOVE_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<MoveData>> *mutable_move_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MoveData>> *>(VT_MOVE_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MOVE_LIST) &&
           verifier.Verify(move_list()) &&
           verifier.VerifyVectorOfTables(move_list()) &&
           verifier.EndTable();
  }
  Notify_MoveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_MoveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_Move> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_MoveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_MoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_move_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MoveData>>> move_list) {
    fbb_.AddOffset(Notify_Move::VT_MOVE_LIST, move_list);
  }
  Notify_MoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_MoveBuilder &operator=(const Notify_MoveBuilder &);
  flatbuffers::Offset<Notify_Move> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Notify_Move>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_Move> CreateNotify_Move(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MoveData>>> move_list = 0) {
  Notify_MoveBuilder builder_(_fbb);
  builder_.add_move_list(move_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_Move> CreateNotify_MoveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MoveData>> *move_list = nullptr) {
  return ProtocolCS::World::CreateNotify_Move(
      _fbb,
      move_list ? _fbb.CreateVector<flatbuffers::Offset<MoveData>>(*move_list) : 0);
}

flatbuffers::Offset<Notify_Move> CreateNotify_Move(flatbuffers::FlatBufferBuilder &_fbb, const Notify_MoveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_AttackT : public flatbuffers::NativeTable {
  typedef Notify_Attack TableType;
  std::vector<std::unique_ptr<AttackDataT>> attack_list;
  Notify_AttackT() {
  }
};

struct Notify_Attack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_AttackT NativeTableType;
  enum {
    VT_ATTACK_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AttackData>> *attack_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AttackData>> *>(VT_ATTACK_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<AttackData>> *mutable_attack_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<AttackData>> *>(VT_ATTACK_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTACK_LIST) &&
           verifier.Verify(attack_list()) &&
           verifier.VerifyVectorOfTables(attack_list()) &&
           verifier.EndTable();
  }
  Notify_AttackT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_AttackT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_Attack> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AttackT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_AttackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attack_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttackData>>> attack_list) {
    fbb_.AddOffset(Notify_Attack::VT_ATTACK_LIST, attack_list);
  }
  Notify_AttackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_AttackBuilder &operator=(const Notify_AttackBuilder &);
  flatbuffers::Offset<Notify_Attack> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Notify_Attack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_Attack> CreateNotify_Attack(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttackData>>> attack_list = 0) {
  Notify_AttackBuilder builder_(_fbb);
  builder_.add_attack_list(attack_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_Attack> CreateNotify_AttackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AttackData>> *attack_list = nullptr) {
  return ProtocolCS::World::CreateNotify_Attack(
      _fbb,
      attack_list ? _fbb.CreateVector<flatbuffers::Offset<AttackData>>(*attack_list) : 0);
}

flatbuffers::Offset<Notify_Attack> CreateNotify_Attack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AttackT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Notify_DamageT : public flatbuffers::NativeTable {
  typedef Notify_Damage TableType;
  std::vector<std::unique_ptr<DamageDataT>> damage_list;
  Notify_DamageT() {
  }
};

struct Notify_Damage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Notify_DamageT NativeTableType;
  enum {
    VT_DAMAGE_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DamageData>> *damage_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DamageData>> *>(VT_DAMAGE_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<DamageData>> *mutable_damage_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<DamageData>> *>(VT_DAMAGE_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DAMAGE_LIST) &&
           verifier.Verify(damage_list()) &&
           verifier.VerifyVectorOfTables(damage_list()) &&
           verifier.EndTable();
  }
  Notify_DamageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Notify_DamageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Notify_Damage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DamageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Notify_DamageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_damage_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DamageData>>> damage_list) {
    fbb_.AddOffset(Notify_Damage::VT_DAMAGE_LIST, damage_list);
  }
  Notify_DamageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Notify_DamageBuilder &operator=(const Notify_DamageBuilder &);
  flatbuffers::Offset<Notify_Damage> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Notify_Damage>(end);
    return o;
  }
};

inline flatbuffers::Offset<Notify_Damage> CreateNotify_Damage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DamageData>>> damage_list = 0) {
  Notify_DamageBuilder builder_(_fbb);
  builder_.add_damage_list(damage_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<Notify_Damage> CreateNotify_DamageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DamageData>> *damage_list = nullptr) {
  return ProtocolCS::World::CreateNotify_Damage(
      _fbb,
      damage_list ? _fbb.CreateVector<flatbuffers::Offset<DamageData>>(*damage_list) : 0);
}

flatbuffers::Offset<Notify_Damage> CreateNotify_Damage(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DamageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace World

struct MessageRootT : public flatbuffers::NativeTable {
  typedef MessageRoot TableType;
  MessageTypeUnion message;
  MessageRootT() {
  }
};

struct MessageRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageRootT NativeTableType;
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  MessageType message_type() const {
    return static_cast<MessageType>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  bool mutate_message_type(MessageType _message_type) {
    return SetField<uint8_t>(VT_MESSAGE_TYPE, static_cast<uint8_t>(_message_type), 0);
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const ProtocolCS::Notify_UnauthedAccess *message_as_Notify_UnauthedAccess() const {
    return message_type() == MessageType::Notify_UnauthedAccess ? static_cast<const ProtocolCS::Notify_UnauthedAccess *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Request_Login *message_as_Login_Request_Login() const {
    return message_type() == MessageType::Login_Request_Login ? static_cast<const ProtocolCS::Login::Request_Login *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_LoginSuccess *message_as_Login_Reply_LoginSuccess() const {
    return message_type() == MessageType::Login_Reply_LoginSuccess ? static_cast<const ProtocolCS::Login::Reply_LoginSuccess *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_LoginFailed *message_as_Login_Reply_LoginFailed() const {
    return message_type() == MessageType::Login_Reply_LoginFailed ? static_cast<const ProtocolCS::Login::Reply_LoginFailed *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Request_Join *message_as_Login_Request_Join() const {
    return message_type() == MessageType::Login_Request_Join ? static_cast<const ProtocolCS::Login::Request_Join *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_JoinSuccess *message_as_Login_Reply_JoinSuccess() const {
    return message_type() == MessageType::Login_Reply_JoinSuccess ? static_cast<const ProtocolCS::Login::Reply_JoinSuccess *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_JoinFailed *message_as_Login_Reply_JoinFailed() const {
    return message_type() == MessageType::Login_Reply_JoinFailed ? static_cast<const ProtocolCS::Login::Reply_JoinFailed *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Request_CharacterList *message_as_Login_Request_CharacterList() const {
    return message_type() == MessageType::Login_Request_CharacterList ? static_cast<const ProtocolCS::Login::Request_CharacterList *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_CharacterList *message_as_Login_Reply_CharacterList() const {
    return message_type() == MessageType::Login_Reply_CharacterList ? static_cast<const ProtocolCS::Login::Reply_CharacterList *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Request_CreateCharacter *message_as_Login_Request_CreateCharacter() const {
    return message_type() == MessageType::Login_Request_CreateCharacter ? static_cast<const ProtocolCS::Login::Request_CreateCharacter *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_CreateCharacterSuccess *message_as_Login_Reply_CreateCharacterSuccess() const {
    return message_type() == MessageType::Login_Reply_CreateCharacterSuccess ? static_cast<const ProtocolCS::Login::Reply_CreateCharacterSuccess *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_CreateCharacterFailed *message_as_Login_Reply_CreateCharacterFailed() const {
    return message_type() == MessageType::Login_Reply_CreateCharacterFailed ? static_cast<const ProtocolCS::Login::Reply_CreateCharacterFailed *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Request_DeleteCharacter *message_as_Login_Request_DeleteCharacter() const {
    return message_type() == MessageType::Login_Request_DeleteCharacter ? static_cast<const ProtocolCS::Login::Request_DeleteCharacter *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_DeleteCharacterSuccess *message_as_Login_Reply_DeleteCharacterSuccess() const {
    return message_type() == MessageType::Login_Reply_DeleteCharacterSuccess ? static_cast<const ProtocolCS::Login::Reply_DeleteCharacterSuccess *>(message()) : nullptr;
  }
  const ProtocolCS::Login::Reply_DeleteCharacterFailed *message_as_Login_Reply_DeleteCharacterFailed() const {
    return message_type() == MessageType::Login_Reply_DeleteCharacterFailed ? static_cast<const ProtocolCS::Login::Reply_DeleteCharacterFailed *>(message()) : nullptr;
  }
  const ProtocolCS::World::Request_EnterWorld *message_as_World_Request_EnterWorld() const {
    return message_type() == MessageType::World_Request_EnterWorld ? static_cast<const ProtocolCS::World::Request_EnterWorld *>(message()) : nullptr;
  }
  const ProtocolCS::World::Reply_EnterWorldSuccess *message_as_World_Reply_EnterWorldSuccess() const {
    return message_type() == MessageType::World_Reply_EnterWorldSuccess ? static_cast<const ProtocolCS::World::Reply_EnterWorldSuccess *>(message()) : nullptr;
  }
  const ProtocolCS::World::Reply_EnterWorldFailed *message_as_World_Reply_EnterWorldFailed() const {
    return message_type() == MessageType::World_Reply_EnterWorldFailed ? static_cast<const ProtocolCS::World::Reply_EnterWorldFailed *>(message()) : nullptr;
  }
  const ProtocolCS::World::Request_EnterWorldNext *message_as_World_Request_EnterWorldNext() const {
    return message_type() == MessageType::World_Request_EnterWorldNext ? static_cast<const ProtocolCS::World::Request_EnterWorldNext *>(message()) : nullptr;
  }
  const ProtocolCS::World::Reply_EnterWorldNextSuccess *message_as_World_Reply_EnterWorldNextSuccess() const {
    return message_type() == MessageType::World_Reply_EnterWorldNextSuccess ? static_cast<const ProtocolCS::World::Reply_EnterWorldNextSuccess *>(message()) : nullptr;
  }
  const ProtocolCS::World::Reply_EnterWorldNextFailed *message_as_World_Reply_EnterWorldNextFailed() const {
    return message_type() == MessageType::World_Reply_EnterWorldNextFailed ? static_cast<const ProtocolCS::World::Reply_EnterWorldNextFailed *>(message()) : nullptr;
  }
  const ProtocolCS::World::Request_Move *message_as_World_Request_Move() const {
    return message_type() == MessageType::World_Request_Move ? static_cast<const ProtocolCS::World::Request_Move *>(message()) : nullptr;
  }
  const ProtocolCS::World::Request_Attack *message_as_World_Request_Attack() const {
    return message_type() == MessageType::World_Request_Attack ? static_cast<const ProtocolCS::World::Request_Attack *>(message()) : nullptr;
  }
  const ProtocolCS::World::Notify_EnterZone *message_as_World_Notify_EnterZone() const {
    return message_type() == MessageType::World_Notify_EnterZone ? static_cast<const ProtocolCS::World::Notify_EnterZone *>(message()) : nullptr;
  }
  const ProtocolCS::World::Notify_AppearActor *message_as_World_Notify_AppearActor() const {
    return message_type() == MessageType::World_Notify_AppearActor ? static_cast<const ProtocolCS::World::Notify_AppearActor *>(message()) : nullptr;
  }
  const ProtocolCS::World::Notify_DisappearActor *message_as_World_Notify_DisappearActor() const {
    return message_type() == MessageType::World_Notify_DisappearActor ? static_cast<const ProtocolCS::World::Notify_DisappearActor *>(message()) : nullptr;
  }
  const ProtocolCS::World::Notify_Move *message_as_World_Notify_Move() const {
    return message_type() == MessageType::World_Notify_Move ? static_cast<const ProtocolCS::World::Notify_Move *>(message()) : nullptr;
  }
  const ProtocolCS::World::Notify_Attack *message_as_World_Notify_Attack() const {
    return message_type() == MessageType::World_Notify_Attack ? static_cast<const ProtocolCS::World::Notify_Attack *>(message()) : nullptr;
  }
  const ProtocolCS::World::Notify_Damage *message_as_World_Notify_Damage() const {
    return message_type() == MessageType::World_Notify_Damage ? static_cast<const ProtocolCS::World::Notify_Damage *>(message()) : nullptr;
  }
  void *mutable_message() {
    return GetPointer<void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessageType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
  MessageRootT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageRootT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MessageRoot> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageRootT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ProtocolCS::Notify_UnauthedAccess *MessageRoot::message_as<ProtocolCS::Notify_UnauthedAccess>() const {
  return message_as_Notify_UnauthedAccess();
}

template<> inline const ProtocolCS::Login::Request_Login *MessageRoot::message_as<ProtocolCS::Login::Request_Login>() const {
  return message_as_Login_Request_Login();
}

template<> inline const ProtocolCS::Login::Reply_LoginSuccess *MessageRoot::message_as<ProtocolCS::Login::Reply_LoginSuccess>() const {
  return message_as_Login_Reply_LoginSuccess();
}

template<> inline const ProtocolCS::Login::Reply_LoginFailed *MessageRoot::message_as<ProtocolCS::Login::Reply_LoginFailed>() const {
  return message_as_Login_Reply_LoginFailed();
}

template<> inline const ProtocolCS::Login::Request_Join *MessageRoot::message_as<ProtocolCS::Login::Request_Join>() const {
  return message_as_Login_Request_Join();
}

template<> inline const ProtocolCS::Login::Reply_JoinSuccess *MessageRoot::message_as<ProtocolCS::Login::Reply_JoinSuccess>() const {
  return message_as_Login_Reply_JoinSuccess();
}

template<> inline const ProtocolCS::Login::Reply_JoinFailed *MessageRoot::message_as<ProtocolCS::Login::Reply_JoinFailed>() const {
  return message_as_Login_Reply_JoinFailed();
}

template<> inline const ProtocolCS::Login::Request_CharacterList *MessageRoot::message_as<ProtocolCS::Login::Request_CharacterList>() const {
  return message_as_Login_Request_CharacterList();
}

template<> inline const ProtocolCS::Login::Reply_CharacterList *MessageRoot::message_as<ProtocolCS::Login::Reply_CharacterList>() const {
  return message_as_Login_Reply_CharacterList();
}

template<> inline const ProtocolCS::Login::Request_CreateCharacter *MessageRoot::message_as<ProtocolCS::Login::Request_CreateCharacter>() const {
  return message_as_Login_Request_CreateCharacter();
}

template<> inline const ProtocolCS::Login::Reply_CreateCharacterSuccess *MessageRoot::message_as<ProtocolCS::Login::Reply_CreateCharacterSuccess>() const {
  return message_as_Login_Reply_CreateCharacterSuccess();
}

template<> inline const ProtocolCS::Login::Reply_CreateCharacterFailed *MessageRoot::message_as<ProtocolCS::Login::Reply_CreateCharacterFailed>() const {
  return message_as_Login_Reply_CreateCharacterFailed();
}

template<> inline const ProtocolCS::Login::Request_DeleteCharacter *MessageRoot::message_as<ProtocolCS::Login::Request_DeleteCharacter>() const {
  return message_as_Login_Request_DeleteCharacter();
}

template<> inline const ProtocolCS::Login::Reply_DeleteCharacterSuccess *MessageRoot::message_as<ProtocolCS::Login::Reply_DeleteCharacterSuccess>() const {
  return message_as_Login_Reply_DeleteCharacterSuccess();
}

template<> inline const ProtocolCS::Login::Reply_DeleteCharacterFailed *MessageRoot::message_as<ProtocolCS::Login::Reply_DeleteCharacterFailed>() const {
  return message_as_Login_Reply_DeleteCharacterFailed();
}

template<> inline const ProtocolCS::World::Request_EnterWorld *MessageRoot::message_as<ProtocolCS::World::Request_EnterWorld>() const {
  return message_as_World_Request_EnterWorld();
}

template<> inline const ProtocolCS::World::Reply_EnterWorldSuccess *MessageRoot::message_as<ProtocolCS::World::Reply_EnterWorldSuccess>() const {
  return message_as_World_Reply_EnterWorldSuccess();
}

template<> inline const ProtocolCS::World::Reply_EnterWorldFailed *MessageRoot::message_as<ProtocolCS::World::Reply_EnterWorldFailed>() const {
  return message_as_World_Reply_EnterWorldFailed();
}

template<> inline const ProtocolCS::World::Request_EnterWorldNext *MessageRoot::message_as<ProtocolCS::World::Request_EnterWorldNext>() const {
  return message_as_World_Request_EnterWorldNext();
}

template<> inline const ProtocolCS::World::Reply_EnterWorldNextSuccess *MessageRoot::message_as<ProtocolCS::World::Reply_EnterWorldNextSuccess>() const {
  return message_as_World_Reply_EnterWorldNextSuccess();
}

template<> inline const ProtocolCS::World::Reply_EnterWorldNextFailed *MessageRoot::message_as<ProtocolCS::World::Reply_EnterWorldNextFailed>() const {
  return message_as_World_Reply_EnterWorldNextFailed();
}

template<> inline const ProtocolCS::World::Request_Move *MessageRoot::message_as<ProtocolCS::World::Request_Move>() const {
  return message_as_World_Request_Move();
}

template<> inline const ProtocolCS::World::Request_Attack *MessageRoot::message_as<ProtocolCS::World::Request_Attack>() const {
  return message_as_World_Request_Attack();
}

template<> inline const ProtocolCS::World::Notify_EnterZone *MessageRoot::message_as<ProtocolCS::World::Notify_EnterZone>() const {
  return message_as_World_Notify_EnterZone();
}

template<> inline const ProtocolCS::World::Notify_AppearActor *MessageRoot::message_as<ProtocolCS::World::Notify_AppearActor>() const {
  return message_as_World_Notify_AppearActor();
}

template<> inline const ProtocolCS::World::Notify_DisappearActor *MessageRoot::message_as<ProtocolCS::World::Notify_DisappearActor>() const {
  return message_as_World_Notify_DisappearActor();
}

template<> inline const ProtocolCS::World::Notify_Move *MessageRoot::message_as<ProtocolCS::World::Notify_Move>() const {
  return message_as_World_Notify_Move();
}

template<> inline const ProtocolCS::World::Notify_Attack *MessageRoot::message_as<ProtocolCS::World::Notify_Attack>() const {
  return message_as_World_Notify_Attack();
}

template<> inline const ProtocolCS::World::Notify_Damage *MessageRoot::message_as<ProtocolCS::World::Notify_Damage>() const {
  return message_as_World_Notify_Damage();
}

struct MessageRootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(MessageType message_type) {
    fbb_.AddElement<uint8_t>(MessageRoot::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(MessageRoot::VT_MESSAGE, message);
  }
  MessageRootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageRootBuilder &operator=(const MessageRootBuilder &);
  flatbuffers::Offset<MessageRoot> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<MessageRoot>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageRoot> CreateMessageRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    MessageType message_type = MessageType::NONE,
    flatbuffers::Offset<void> message = 0) {
  MessageRootBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

flatbuffers::Offset<MessageRoot> CreateMessageRoot(flatbuffers::FlatBufferBuilder &_fbb, const MessageRootT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Notify_UnauthedAccessT *Notify_UnauthedAccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_UnauthedAccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_UnauthedAccess::UnPackTo(Notify_UnauthedAccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Notify_UnauthedAccess> Notify_UnauthedAccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_UnauthedAccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_UnauthedAccess> CreateNotify_UnauthedAccess(flatbuffers::FlatBufferBuilder &_fbb, const Notify_UnauthedAccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return ProtocolCS::CreateNotify_UnauthedAccess(
      _fbb);
}

namespace Login {

inline CharacterT *Character::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Character::UnPackTo(CharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uid(); _o->uid = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = level(); _o->level = _e; };
}

inline flatbuffers::Offset<Character> Character::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Character> CreateCharacter(flatbuffers::FlatBufferBuilder &_fbb, const CharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uid = _o->uid;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _level = _o->level;
  return ProtocolCS::Login::CreateCharacter(
      _fbb,
      _uid,
      _name,
      _class_type,
      _level);
}

inline Request_LoginT *Request_Login::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_LoginT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Login::UnPackTo(Request_LoginT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = user_name(); if (_e) _o->user_name = _e->str(); };
  { auto _e = password(); if (_e) _o->password = _e->str(); };
}

inline flatbuffers::Offset<Request_Login> Request_Login::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Login(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Login> CreateRequest_Login(flatbuffers::FlatBufferBuilder &_fbb, const Request_LoginT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _user_name = _o->user_name.size() ? _fbb.CreateString(_o->user_name) : 0;
  auto _password = _o->password.size() ? _fbb.CreateString(_o->password) : 0;
  return ProtocolCS::Login::CreateRequest_Login(
      _fbb,
      _user_name,
      _password);
}

inline Reply_LoginSuccessT *Reply_LoginSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_LoginSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_LoginSuccess::UnPackTo(Reply_LoginSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = credential(); if (_e) _o->credential = _e->str(); };
}

inline flatbuffers::Offset<Reply_LoginSuccess> Reply_LoginSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_LoginSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_LoginSuccess> CreateReply_LoginSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _credential = _o->credential.size() ? _fbb.CreateString(_o->credential) : 0;
  return ProtocolCS::Login::CreateReply_LoginSuccess(
      _fbb,
      _credential);
}

inline Reply_LoginFailedT *Reply_LoginFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_LoginFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_LoginFailed::UnPackTo(Reply_LoginFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_LoginFailed> Reply_LoginFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_LoginFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_LoginFailed> CreateReply_LoginFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_LoginFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::Login::CreateReply_LoginFailed(
      _fbb,
      _error_code);
}

inline Request_JoinT *Request_Join::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_JoinT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Join::UnPackTo(Request_JoinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = user_name(); if (_e) _o->user_name = _e->str(); };
  { auto _e = password(); if (_e) _o->password = _e->str(); };
}

inline flatbuffers::Offset<Request_Join> Request_Join::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_JoinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Join(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Join> CreateRequest_Join(flatbuffers::FlatBufferBuilder &_fbb, const Request_JoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _user_name = _o->user_name.size() ? _fbb.CreateString(_o->user_name) : 0;
  auto _password = _o->password.size() ? _fbb.CreateString(_o->password) : 0;
  return ProtocolCS::Login::CreateRequest_Join(
      _fbb,
      _user_name,
      _password);
}

inline Reply_JoinSuccessT *Reply_JoinSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_JoinSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_JoinSuccess::UnPackTo(Reply_JoinSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Reply_JoinSuccess> Reply_JoinSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_JoinSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_JoinSuccess> CreateReply_JoinSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return ProtocolCS::Login::CreateReply_JoinSuccess(
      _fbb);
}

inline Reply_JoinFailedT *Reply_JoinFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_JoinFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_JoinFailed::UnPackTo(Reply_JoinFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_JoinFailed> Reply_JoinFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_JoinFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_JoinFailed> CreateReply_JoinFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_JoinFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::Login::CreateReply_JoinFailed(
      _fbb,
      _error_code);
}

inline Request_CharacterListT *Request_CharacterList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_CharacterListT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_CharacterList::UnPackTo(Request_CharacterListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Request_CharacterList> Request_CharacterList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_CharacterListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_CharacterList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_CharacterList> CreateRequest_CharacterList(flatbuffers::FlatBufferBuilder &_fbb, const Request_CharacterListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return ProtocolCS::Login::CreateRequest_CharacterList(
      _fbb);
}

inline Reply_CharacterListT *Reply_CharacterList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_CharacterListT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_CharacterList::UnPackTo(Reply_CharacterListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = list(); if (_e) { _o->list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->list[_i] = std::unique_ptr<CharacterT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Reply_CharacterList> Reply_CharacterList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CharacterListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_CharacterList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_CharacterList> CreateReply_CharacterList(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CharacterListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _list = _o->list.size() ? _fbb.CreateVector<flatbuffers::Offset<Character>>(_o->list.size(), [&](size_t i) { return CreateCharacter(_fbb, _o->list[i].get(), _rehasher); }) : 0;
  return ProtocolCS::Login::CreateReply_CharacterList(
      _fbb,
      _list);
}

inline Request_CreateCharacterT *Request_CreateCharacter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_CreateCharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_CreateCharacter::UnPackTo(Request_CreateCharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
}

inline flatbuffers::Offset<Request_CreateCharacter> Request_CreateCharacter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_CreateCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_CreateCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_CreateCharacter> CreateRequest_CreateCharacter(flatbuffers::FlatBufferBuilder &_fbb, const Request_CreateCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  return ProtocolCS::Login::CreateRequest_CreateCharacter(
      _fbb,
      _name,
      _class_type);
}

inline Reply_CreateCharacterSuccessT *Reply_CreateCharacterSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_CreateCharacterSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_CreateCharacterSuccess::UnPackTo(Reply_CreateCharacterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character(); if (_e) _o->character = std::unique_ptr<CharacterT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Reply_CreateCharacterSuccess> Reply_CreateCharacterSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_CreateCharacterSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_CreateCharacterSuccess> CreateReply_CreateCharacterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character = _o->character ? CreateCharacter(_fbb, _o->character.get(), _rehasher) : 0;
  return ProtocolCS::Login::CreateReply_CreateCharacterSuccess(
      _fbb,
      _character);
}

inline Reply_CreateCharacterFailedT *Reply_CreateCharacterFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_CreateCharacterFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_CreateCharacterFailed::UnPackTo(Reply_CreateCharacterFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_CreateCharacterFailed> Reply_CreateCharacterFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_CreateCharacterFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_CreateCharacterFailed> CreateReply_CreateCharacterFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_CreateCharacterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::Login::CreateReply_CreateCharacterFailed(
      _fbb,
      _error_code);
}

inline Request_DeleteCharacterT *Request_DeleteCharacter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_DeleteCharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_DeleteCharacter::UnPackTo(Request_DeleteCharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character_uid(); _o->character_uid = _e; };
}

inline flatbuffers::Offset<Request_DeleteCharacter> Request_DeleteCharacter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_DeleteCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_DeleteCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_DeleteCharacter> CreateRequest_DeleteCharacter(flatbuffers::FlatBufferBuilder &_fbb, const Request_DeleteCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character_uid = _o->character_uid;
  return ProtocolCS::Login::CreateRequest_DeleteCharacter(
      _fbb,
      _character_uid);
}

inline Reply_DeleteCharacterSuccessT *Reply_DeleteCharacterSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_DeleteCharacterSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_DeleteCharacterSuccess::UnPackTo(Reply_DeleteCharacterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character_uid(); _o->character_uid = _e; };
}

inline flatbuffers::Offset<Reply_DeleteCharacterSuccess> Reply_DeleteCharacterSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_DeleteCharacterSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_DeleteCharacterSuccess> CreateReply_DeleteCharacterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character_uid = _o->character_uid;
  return ProtocolCS::Login::CreateReply_DeleteCharacterSuccess(
      _fbb,
      _character_uid);
}

inline Reply_DeleteCharacterFailedT *Reply_DeleteCharacterFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_DeleteCharacterFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_DeleteCharacterFailed::UnPackTo(Reply_DeleteCharacterFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_DeleteCharacterFailed> Reply_DeleteCharacterFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_DeleteCharacterFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_DeleteCharacterFailed> CreateReply_DeleteCharacterFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_DeleteCharacterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::Login::CreateReply_DeleteCharacterFailed(
      _fbb,
      _error_code);
}

}  // namespace Login

namespace World {

inline PlayerCharacterT *PlayerCharacter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PlayerCharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PlayerCharacter::UnPackTo(PlayerCharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = exp(); _o->exp = _e; };
  { auto _e = level(); _o->level = _e; };
  { auto _e = max_hp(); _o->max_hp = _e; };
  { auto _e = hp(); _o->hp = _e; };
  { auto _e = max_mp(); _o->max_mp = _e; };
  { auto _e = mp(); _o->mp = _e; };
  { auto _e = att(); _o->att = _e; };
  { auto _e = def(); _o->def = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
  { auto _e = rotation(); _o->rotation = _e; };
}

inline flatbuffers::Offset<PlayerCharacter> PlayerCharacter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayerCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PlayerCharacter> CreatePlayerCharacter(flatbuffers::FlatBufferBuilder &_fbb, const PlayerCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _exp = _o->exp;
  auto _level = _o->level;
  auto _max_hp = _o->max_hp;
  auto _hp = _o->hp;
  auto _max_mp = _o->max_mp;
  auto _mp = _o->mp;
  auto _att = _o->att;
  auto _def = _o->def;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _rotation = _o->rotation;
  return ProtocolCS::World::CreatePlayerCharacter(
      _fbb,
      _entity_id,
      _name,
      _class_type,
      _exp,
      _level,
      _max_hp,
      _hp,
      _max_mp,
      _mp,
      _att,
      _def,
      _pos,
      _rotation);
}

inline RemotePCT *RemotePC::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RemotePCT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RemotePC::UnPackTo(RemotePCT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = level(); _o->level = _e; };
  { auto _e = max_hp(); _o->max_hp = _e; };
  { auto _e = hp(); _o->hp = _e; };
  { auto _e = max_mp(); _o->max_mp = _e; };
  { auto _e = mp(); _o->mp = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
  { auto _e = rotation(); _o->rotation = _e; };
}

inline flatbuffers::Offset<RemotePC> RemotePC::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemotePCT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRemotePC(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RemotePC> CreateRemotePC(flatbuffers::FlatBufferBuilder &_fbb, const RemotePCT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _level = _o->level;
  auto _max_hp = _o->max_hp;
  auto _hp = _o->hp;
  auto _max_mp = _o->max_mp;
  auto _mp = _o->mp;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _rotation = _o->rotation;
  return ProtocolCS::World::CreateRemotePC(
      _fbb,
      _entity_id,
      _name,
      _class_type,
      _level,
      _max_hp,
      _hp,
      _max_mp,
      _mp,
      _pos,
      _rotation);
}

inline MonsterT *Monster::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MonsterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Monster::UnPackTo(MonsterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = type_id(); _o->type_id = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = max_hp(); _o->max_hp = _e; };
  { auto _e = hp(); _o->hp = _e; };
  { auto _e = max_mp(); _o->max_mp = _e; };
  { auto _e = mp(); _o->mp = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
  { auto _e = rotation(); _o->rotation = _e; };
}

inline flatbuffers::Offset<Monster> Monster::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMonster(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _type_id = _o->type_id;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _level = _o->level;
  auto _max_hp = _o->max_hp;
  auto _hp = _o->hp;
  auto _max_mp = _o->max_mp;
  auto _mp = _o->mp;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _rotation = _o->rotation;
  return ProtocolCS::World::CreateMonster(
      _fbb,
      _entity_id,
      _type_id,
      _name,
      _level,
      _max_hp,
      _hp,
      _max_mp,
      _mp,
      _pos,
      _rotation);
}

inline MoveDataT *MoveData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MoveDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MoveData::UnPackTo(MoveDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
  { auto _e = rotation(); _o->rotation = _e; };
  { auto _e = velocity(); if (_e) _o->velocity = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
}

inline flatbuffers::Offset<MoveData> MoveData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MoveData> CreateMoveData(flatbuffers::FlatBufferBuilder &_fbb, const MoveDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _rotation = _o->rotation;
  auto _velocity = _o->velocity ? _o->velocity.get() : 0;
  return ProtocolCS::World::CreateMoveData(
      _fbb,
      _entity_id,
      _position,
      _rotation,
      _velocity);
}

inline AttackDataT *AttackData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AttackDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AttackData::UnPackTo(AttackDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = rotation(); _o->rotation = _e; };
}

inline flatbuffers::Offset<AttackData> AttackData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AttackDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAttackData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AttackData> CreateAttackData(flatbuffers::FlatBufferBuilder &_fbb, const AttackDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _rotation = _o->rotation;
  return ProtocolCS::World::CreateAttackData(
      _fbb,
      _entity_id,
      _rotation);
}

inline DamageDataT *DamageData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DamageDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DamageData::UnPackTo(DamageDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id(); if (_e) _o->entity_id = _e->str(); };
  { auto _e = damage(); _o->damage = _e; };
}

inline flatbuffers::Offset<DamageData> DamageData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DamageDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDamageData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DamageData> CreateDamageData(flatbuffers::FlatBufferBuilder &_fbb, const DamageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id = _o->entity_id.size() ? _fbb.CreateString(_o->entity_id) : 0;
  auto _damage = _o->damage;
  return ProtocolCS::World::CreateDamageData(
      _fbb,
      _entity_id,
      _damage);
}

inline Request_EnterWorldT *Request_EnterWorld::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_EnterWorldT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_EnterWorld::UnPackTo(Request_EnterWorldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character_uid(); _o->character_uid = _e; };
}

inline flatbuffers::Offset<Request_EnterWorld> Request_EnterWorld::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_EnterWorld(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_EnterWorld> CreateRequest_EnterWorld(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character_uid = _o->character_uid;
  return ProtocolCS::World::CreateRequest_EnterWorld(
      _fbb,
      _character_uid);
}

inline Reply_EnterWorldSuccessT *Reply_EnterWorldSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_EnterWorldSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_EnterWorldSuccess::UnPackTo(Reply_EnterWorldSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Reply_EnterWorldSuccess> Reply_EnterWorldSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_EnterWorldSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_EnterWorldSuccess> CreateReply_EnterWorldSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return ProtocolCS::World::CreateReply_EnterWorldSuccess(
      _fbb);
}

inline Reply_EnterWorldFailedT *Reply_EnterWorldFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_EnterWorldFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_EnterWorldFailed::UnPackTo(Reply_EnterWorldFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_EnterWorldFailed> Reply_EnterWorldFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_EnterWorldFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_EnterWorldFailed> CreateReply_EnterWorldFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::World::CreateReply_EnterWorldFailed(
      _fbb,
      _error_code);
}

inline Request_EnterWorldNextT *Request_EnterWorldNext::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_EnterWorldNextT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_EnterWorldNext::UnPackTo(Request_EnterWorldNextT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<Request_EnterWorldNext> Request_EnterWorldNext::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldNextT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_EnterWorldNext(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_EnterWorldNext> CreateRequest_EnterWorldNext(flatbuffers::FlatBufferBuilder &_fbb, const Request_EnterWorldNextT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return ProtocolCS::World::CreateRequest_EnterWorldNext(
      _fbb);
}

inline Reply_EnterWorldNextSuccessT *Reply_EnterWorldNextSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_EnterWorldNextSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_EnterWorldNextSuccess::UnPackTo(Reply_EnterWorldNextSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character(); if (_e) _o->character = std::unique_ptr<PlayerCharacterT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Reply_EnterWorldNextSuccess> Reply_EnterWorldNextSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_EnterWorldNextSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_EnterWorldNextSuccess> CreateReply_EnterWorldNextSuccess(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character = _o->character ? CreatePlayerCharacter(_fbb, _o->character.get(), _rehasher) : 0;
  return ProtocolCS::World::CreateReply_EnterWorldNextSuccess(
      _fbb,
      _character);
}

inline Reply_EnterWorldNextFailedT *Reply_EnterWorldNextFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Reply_EnterWorldNextFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Reply_EnterWorldNextFailed::UnPackTo(Reply_EnterWorldNextFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<Reply_EnterWorldNextFailed> Reply_EnterWorldNextFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReply_EnterWorldNextFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reply_EnterWorldNextFailed> CreateReply_EnterWorldNextFailed(flatbuffers::FlatBufferBuilder &_fbb, const Reply_EnterWorldNextFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return ProtocolCS::World::CreateReply_EnterWorldNextFailed(
      _fbb,
      _error_code);
}

inline Notify_EnterZoneT *Notify_EnterZone::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_EnterZoneT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_EnterZone::UnPackTo(Notify_EnterZoneT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = map_id(); _o->map_id = _e; };
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
  { auto _e = rotation(); _o->rotation = _e; };
}

inline flatbuffers::Offset<Notify_EnterZone> Notify_EnterZone::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterZoneT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_EnterZone(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_EnterZone> CreateNotify_EnterZone(flatbuffers::FlatBufferBuilder &_fbb, const Notify_EnterZoneT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _map_id = _o->map_id;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _rotation = _o->rotation;
  return ProtocolCS::World::CreateNotify_EnterZone(
      _fbb,
      _map_id,
      _position,
      _rotation);
}

inline Request_MoveT *Request_Move::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_MoveT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Move::UnPackTo(Request_MoveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
  { auto _e = rotation(); _o->rotation = _e; };
  { auto _e = velocity(); if (_e) _o->velocity = std::unique_ptr<ProtocolCS::Vec3>(new ProtocolCS::Vec3(*_e)); };
}

inline flatbuffers::Offset<Request_Move> Request_Move::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_MoveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Move(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Move> CreateRequest_Move(flatbuffers::FlatBufferBuilder &_fbb, const Request_MoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _rotation = _o->rotation;
  auto _velocity = _o->velocity ? _o->velocity.get() : 0;
  return ProtocolCS::World::CreateRequest_Move(
      _fbb,
      _position,
      _rotation,
      _velocity);
}

inline Request_AttackT *Request_Attack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Request_AttackT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request_Attack::UnPackTo(Request_AttackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rotation(); _o->rotation = _e; };
}

inline flatbuffers::Offset<Request_Attack> Request_Attack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Request_AttackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest_Attack(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request_Attack> CreateRequest_Attack(flatbuffers::FlatBufferBuilder &_fbb, const Request_AttackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _rotation = _o->rotation;
  return ProtocolCS::World::CreateRequest_Attack(
      _fbb,
      _rotation);
}

inline Notify_AppearActorT *Notify_AppearActor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_AppearActorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_AppearActor::UnPackTo(Notify_AppearActorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = remote_pc_list(); if (_e) { _o->remote_pc_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->remote_pc_list[_i] = std::unique_ptr<RemotePCT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = monster_list(); if (_e) { _o->monster_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->monster_list[_i] = std::unique_ptr<MonsterT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Notify_AppearActor> Notify_AppearActor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AppearActorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_AppearActor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_AppearActor> CreateNotify_AppearActor(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AppearActorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _remote_pc_list = _o->remote_pc_list.size() ? _fbb.CreateVector<flatbuffers::Offset<RemotePC>>(_o->remote_pc_list.size(), [&](size_t i) { return CreateRemotePC(_fbb, _o->remote_pc_list[i].get(), _rehasher); }) : 0;
  auto _monster_list = _o->monster_list.size() ? _fbb.CreateVector<flatbuffers::Offset<Monster>>(_o->monster_list.size(), [&](size_t i) { return CreateMonster(_fbb, _o->monster_list[i].get(), _rehasher); }) : 0;
  return ProtocolCS::World::CreateNotify_AppearActor(
      _fbb,
      _remote_pc_list,
      _monster_list);
}

inline Notify_DisappearActorT *Notify_DisappearActor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_DisappearActorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_DisappearActor::UnPackTo(Notify_DisappearActorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity_id_list(); if (_e) { _o->entity_id_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->entity_id_list[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<Notify_DisappearActor> Notify_DisappearActor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DisappearActorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_DisappearActor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_DisappearActor> CreateNotify_DisappearActor(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DisappearActorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _entity_id_list = _o->entity_id_list.size() ? _fbb.CreateVectorOfStrings(_o->entity_id_list) : 0;
  return ProtocolCS::World::CreateNotify_DisappearActor(
      _fbb,
      _entity_id_list);
}

inline Notify_MoveT *Notify_Move::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_MoveT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_Move::UnPackTo(Notify_MoveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = move_list(); if (_e) { _o->move_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->move_list[_i] = std::unique_ptr<MoveDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Notify_Move> Notify_Move::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_MoveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_Move(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_Move> CreateNotify_Move(flatbuffers::FlatBufferBuilder &_fbb, const Notify_MoveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _move_list = _o->move_list.size() ? _fbb.CreateVector<flatbuffers::Offset<MoveData>>(_o->move_list.size(), [&](size_t i) { return CreateMoveData(_fbb, _o->move_list[i].get(), _rehasher); }) : 0;
  return ProtocolCS::World::CreateNotify_Move(
      _fbb,
      _move_list);
}

inline Notify_AttackT *Notify_Attack::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_AttackT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_Attack::UnPackTo(Notify_AttackT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = attack_list(); if (_e) { _o->attack_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attack_list[_i] = std::unique_ptr<AttackDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Notify_Attack> Notify_Attack::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AttackT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_Attack(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_Attack> CreateNotify_Attack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_AttackT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _attack_list = _o->attack_list.size() ? _fbb.CreateVector<flatbuffers::Offset<AttackData>>(_o->attack_list.size(), [&](size_t i) { return CreateAttackData(_fbb, _o->attack_list[i].get(), _rehasher); }) : 0;
  return ProtocolCS::World::CreateNotify_Attack(
      _fbb,
      _attack_list);
}

inline Notify_DamageT *Notify_Damage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new Notify_DamageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Notify_Damage::UnPackTo(Notify_DamageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = damage_list(); if (_e) { _o->damage_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->damage_list[_i] = std::unique_ptr<DamageDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Notify_Damage> Notify_Damage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DamageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNotify_Damage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Notify_Damage> CreateNotify_Damage(flatbuffers::FlatBufferBuilder &_fbb, const Notify_DamageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _damage_list = _o->damage_list.size() ? _fbb.CreateVector<flatbuffers::Offset<DamageData>>(_o->damage_list.size(), [&](size_t i) { return CreateDamageData(_fbb, _o->damage_list[i].get(), _rehasher); }) : 0;
  return ProtocolCS::World::CreateNotify_Damage(
      _fbb,
      _damage_list);
}

}  // namespace World

inline MessageRootT *MessageRoot::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MessageRootT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MessageRoot::UnPackTo(MessageRootT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_type(); _o->message.type = _e; };
  { auto _e = message(); if (_e) _o->message.value = MessageTypeUnion::UnPack(_e, message_type(), _resolver); };
}

inline flatbuffers::Offset<MessageRoot> MessageRoot::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageRootT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageRoot(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MessageRoot> CreateMessageRoot(flatbuffers::FlatBufferBuilder &_fbb, const MessageRootT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  return ProtocolCS::CreateMessageRoot(
      _fbb,
      _message_type,
      _message);
}

inline bool VerifyMessageType(flatbuffers::Verifier &verifier, const void *obj, MessageType type) {
  switch (type) {
    case MessageType::NONE: {
      return true;
    }
    case MessageType::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Notify_UnauthedAccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Request_Login: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_Login *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_LoginSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_LoginFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Request_Join: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_Join *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_JoinSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_JoinSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_JoinFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_JoinFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Request_CharacterList: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_CharacterList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_CharacterList: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CharacterList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Request_CreateCharacter: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_CreateCharacter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_CreateCharacterSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CreateCharacterSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_CreateCharacterFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CreateCharacterFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Request_DeleteCharacter: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_DeleteCharacter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_DeleteCharacterSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_DeleteCharacterSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::Login_Reply_DeleteCharacterFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_DeleteCharacterFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Request_EnterWorld: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_EnterWorld *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Reply_EnterWorldSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterWorldSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Reply_EnterWorldFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterWorldFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Request_EnterWorldNext: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_EnterWorldNext *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Reply_EnterWorldNextSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterWorldNextSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Reply_EnterWorldNextFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterWorldNextFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Request_Move: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_Move *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Request_Attack: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_Attack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Notify_EnterZone: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_EnterZone *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Notify_AppearActor: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_AppearActor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Notify_DisappearActor: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_DisappearActor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Notify_Move: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_Move *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Notify_Attack: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_Attack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageType::World_Notify_Damage: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_Damage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageType(
        verifier,  values->Get(i), types->GetEnum<MessageType>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageTypeUnion::UnPack(const void *obj, MessageType type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case MessageType::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Notify_UnauthedAccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Request_Login: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_Login *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_LoginSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_LoginFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Request_Join: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_Join *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_JoinSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_JoinSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_JoinFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_JoinFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Request_CharacterList: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_CharacterList *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_CharacterList: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CharacterList *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Request_CreateCharacter: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_CreateCharacter *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_CreateCharacterSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CreateCharacterSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_CreateCharacterFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CreateCharacterFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Request_DeleteCharacter: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_DeleteCharacter *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_DeleteCharacterSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_DeleteCharacterSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::Login_Reply_DeleteCharacterFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_DeleteCharacterFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Request_EnterWorld: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_EnterWorld *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Reply_EnterWorldSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterWorldSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Reply_EnterWorldFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterWorldFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Request_EnterWorldNext: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_EnterWorldNext *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Reply_EnterWorldNextSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterWorldNextSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Reply_EnterWorldNextFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterWorldNextFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Request_Move: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_Move *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Request_Attack: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_Attack *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Notify_EnterZone: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_EnterZone *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Notify_AppearActor: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_AppearActor *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Notify_DisappearActor: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_DisappearActor *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Notify_Move: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_Move *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Notify_Attack: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_Attack *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageType::World_Notify_Damage: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_Damage *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageTypeUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case MessageType::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Notify_UnauthedAccessT *>(value);
      return CreateNotify_UnauthedAccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Request_Login: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_LoginT *>(value);
      return CreateRequest_Login(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_LoginSuccessT *>(value);
      return CreateReply_LoginSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_LoginFailedT *>(value);
      return CreateReply_LoginFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Request_Join: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_JoinT *>(value);
      return CreateRequest_Join(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_JoinSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_JoinSuccessT *>(value);
      return CreateReply_JoinSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_JoinFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_JoinFailedT *>(value);
      return CreateReply_JoinFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Request_CharacterList: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_CharacterListT *>(value);
      return CreateRequest_CharacterList(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_CharacterList: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CharacterListT *>(value);
      return CreateReply_CharacterList(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Request_CreateCharacter: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_CreateCharacterT *>(value);
      return CreateRequest_CreateCharacter(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_CreateCharacterSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CreateCharacterSuccessT *>(value);
      return CreateReply_CreateCharacterSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_CreateCharacterFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_CreateCharacterFailedT *>(value);
      return CreateReply_CreateCharacterFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Request_DeleteCharacter: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Request_DeleteCharacterT *>(value);
      return CreateRequest_DeleteCharacter(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_DeleteCharacterSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_DeleteCharacterSuccessT *>(value);
      return CreateReply_DeleteCharacterSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::Login_Reply_DeleteCharacterFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::Login::Reply_DeleteCharacterFailedT *>(value);
      return CreateReply_DeleteCharacterFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Request_EnterWorld: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_EnterWorldT *>(value);
      return CreateRequest_EnterWorld(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Reply_EnterWorldSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterWorldSuccessT *>(value);
      return CreateReply_EnterWorldSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Reply_EnterWorldFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterWorldFailedT *>(value);
      return CreateReply_EnterWorldFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Request_EnterWorldNext: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_EnterWorldNextT *>(value);
      return CreateRequest_EnterWorldNext(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Reply_EnterWorldNextSuccess: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterWorldNextSuccessT *>(value);
      return CreateReply_EnterWorldNextSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Reply_EnterWorldNextFailed: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Reply_EnterWorldNextFailedT *>(value);
      return CreateReply_EnterWorldNextFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Request_Move: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_MoveT *>(value);
      return CreateRequest_Move(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Request_Attack: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Request_AttackT *>(value);
      return CreateRequest_Attack(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Notify_EnterZone: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_EnterZoneT *>(value);
      return CreateNotify_EnterZone(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Notify_AppearActor: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_AppearActorT *>(value);
      return CreateNotify_AppearActor(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Notify_DisappearActor: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_DisappearActorT *>(value);
      return CreateNotify_DisappearActor(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Notify_Move: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_MoveT *>(value);
      return CreateNotify_Move(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Notify_Attack: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_AttackT *>(value);
      return CreateNotify_Attack(_fbb, ptr, _rehasher).Union();
    }
    case MessageType::World_Notify_Damage: {
      auto ptr = reinterpret_cast<const ProtocolCS::World::Notify_DamageT *>(value);
      return CreateNotify_Damage(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageTypeUnion::MessageTypeUnion(const MessageTypeUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case MessageType::Notify_UnauthedAccess: {
      value = new ProtocolCS::Notify_UnauthedAccessT(*reinterpret_cast<ProtocolCS::Notify_UnauthedAccessT *>(u.value));
      break;
    }
    case MessageType::Login_Request_Login: {
      value = new ProtocolCS::Login::Request_LoginT(*reinterpret_cast<ProtocolCS::Login::Request_LoginT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_LoginSuccess: {
      value = new ProtocolCS::Login::Reply_LoginSuccessT(*reinterpret_cast<ProtocolCS::Login::Reply_LoginSuccessT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_LoginFailed: {
      value = new ProtocolCS::Login::Reply_LoginFailedT(*reinterpret_cast<ProtocolCS::Login::Reply_LoginFailedT *>(u.value));
      break;
    }
    case MessageType::Login_Request_Join: {
      value = new ProtocolCS::Login::Request_JoinT(*reinterpret_cast<ProtocolCS::Login::Request_JoinT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_JoinSuccess: {
      value = new ProtocolCS::Login::Reply_JoinSuccessT(*reinterpret_cast<ProtocolCS::Login::Reply_JoinSuccessT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_JoinFailed: {
      value = new ProtocolCS::Login::Reply_JoinFailedT(*reinterpret_cast<ProtocolCS::Login::Reply_JoinFailedT *>(u.value));
      break;
    }
    case MessageType::Login_Request_CharacterList: {
      value = new ProtocolCS::Login::Request_CharacterListT(*reinterpret_cast<ProtocolCS::Login::Request_CharacterListT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_CharacterList: {
      assert(false);  // ProtocolCS::Login::Reply_CharacterListT not copyable.
      break;
    }
    case MessageType::Login_Request_CreateCharacter: {
      value = new ProtocolCS::Login::Request_CreateCharacterT(*reinterpret_cast<ProtocolCS::Login::Request_CreateCharacterT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_CreateCharacterSuccess: {
      assert(false);  // ProtocolCS::Login::Reply_CreateCharacterSuccessT not copyable.
      break;
    }
    case MessageType::Login_Reply_CreateCharacterFailed: {
      value = new ProtocolCS::Login::Reply_CreateCharacterFailedT(*reinterpret_cast<ProtocolCS::Login::Reply_CreateCharacterFailedT *>(u.value));
      break;
    }
    case MessageType::Login_Request_DeleteCharacter: {
      value = new ProtocolCS::Login::Request_DeleteCharacterT(*reinterpret_cast<ProtocolCS::Login::Request_DeleteCharacterT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_DeleteCharacterSuccess: {
      value = new ProtocolCS::Login::Reply_DeleteCharacterSuccessT(*reinterpret_cast<ProtocolCS::Login::Reply_DeleteCharacterSuccessT *>(u.value));
      break;
    }
    case MessageType::Login_Reply_DeleteCharacterFailed: {
      value = new ProtocolCS::Login::Reply_DeleteCharacterFailedT(*reinterpret_cast<ProtocolCS::Login::Reply_DeleteCharacterFailedT *>(u.value));
      break;
    }
    case MessageType::World_Request_EnterWorld: {
      value = new ProtocolCS::World::Request_EnterWorldT(*reinterpret_cast<ProtocolCS::World::Request_EnterWorldT *>(u.value));
      break;
    }
    case MessageType::World_Reply_EnterWorldSuccess: {
      value = new ProtocolCS::World::Reply_EnterWorldSuccessT(*reinterpret_cast<ProtocolCS::World::Reply_EnterWorldSuccessT *>(u.value));
      break;
    }
    case MessageType::World_Reply_EnterWorldFailed: {
      value = new ProtocolCS::World::Reply_EnterWorldFailedT(*reinterpret_cast<ProtocolCS::World::Reply_EnterWorldFailedT *>(u.value));
      break;
    }
    case MessageType::World_Request_EnterWorldNext: {
      value = new ProtocolCS::World::Request_EnterWorldNextT(*reinterpret_cast<ProtocolCS::World::Request_EnterWorldNextT *>(u.value));
      break;
    }
    case MessageType::World_Reply_EnterWorldNextSuccess: {
      assert(false);  // ProtocolCS::World::Reply_EnterWorldNextSuccessT not copyable.
      break;
    }
    case MessageType::World_Reply_EnterWorldNextFailed: {
      value = new ProtocolCS::World::Reply_EnterWorldNextFailedT(*reinterpret_cast<ProtocolCS::World::Reply_EnterWorldNextFailedT *>(u.value));
      break;
    }
    case MessageType::World_Request_Move: {
      assert(false);  // ProtocolCS::World::Request_MoveT not copyable.
      break;
    }
    case MessageType::World_Request_Attack: {
      value = new ProtocolCS::World::Request_AttackT(*reinterpret_cast<ProtocolCS::World::Request_AttackT *>(u.value));
      break;
    }
    case MessageType::World_Notify_EnterZone: {
      assert(false);  // ProtocolCS::World::Notify_EnterZoneT not copyable.
      break;
    }
    case MessageType::World_Notify_AppearActor: {
      assert(false);  // ProtocolCS::World::Notify_AppearActorT not copyable.
      break;
    }
    case MessageType::World_Notify_DisappearActor: {
      value = new ProtocolCS::World::Notify_DisappearActorT(*reinterpret_cast<ProtocolCS::World::Notify_DisappearActorT *>(u.value));
      break;
    }
    case MessageType::World_Notify_Move: {
      assert(false);  // ProtocolCS::World::Notify_MoveT not copyable.
      break;
    }
    case MessageType::World_Notify_Attack: {
      assert(false);  // ProtocolCS::World::Notify_AttackT not copyable.
      break;
    }
    case MessageType::World_Notify_Damage: {
      assert(false);  // ProtocolCS::World::Notify_DamageT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void MessageTypeUnion::Reset() {
  switch (type) {
    case MessageType::Notify_UnauthedAccess: {
      auto ptr = reinterpret_cast<ProtocolCS::Notify_UnauthedAccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Request_Login: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Request_LoginT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_LoginSuccess: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_LoginSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_LoginFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_LoginFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Request_Join: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Request_JoinT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_JoinSuccess: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_JoinSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_JoinFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_JoinFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Request_CharacterList: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Request_CharacterListT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_CharacterList: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_CharacterListT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Request_CreateCharacter: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Request_CreateCharacterT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_CreateCharacterSuccess: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_CreateCharacterSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_CreateCharacterFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_CreateCharacterFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Request_DeleteCharacter: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Request_DeleteCharacterT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_DeleteCharacterSuccess: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_DeleteCharacterSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::Login_Reply_DeleteCharacterFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::Login::Reply_DeleteCharacterFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Request_EnterWorld: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Request_EnterWorldT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Reply_EnterWorldSuccess: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Reply_EnterWorldSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Reply_EnterWorldFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Reply_EnterWorldFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Request_EnterWorldNext: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Request_EnterWorldNextT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Reply_EnterWorldNextSuccess: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Reply_EnterWorldNextSuccessT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Reply_EnterWorldNextFailed: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Reply_EnterWorldNextFailedT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Request_Move: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Request_MoveT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Request_Attack: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Request_AttackT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Notify_EnterZone: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Notify_EnterZoneT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Notify_AppearActor: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Notify_AppearActorT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Notify_DisappearActor: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Notify_DisappearActorT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Notify_Move: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Notify_MoveT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Notify_Attack: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Notify_AttackT *>(value);
      delete ptr;
      break;
    }
    case MessageType::World_Notify_Damage: {
      auto ptr = reinterpret_cast<ProtocolCS::World::Notify_DamageT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MessageType::NONE;
}

inline const ProtocolCS::MessageRoot *GetMessageRoot(const void *buf) {
  return flatbuffers::GetRoot<ProtocolCS::MessageRoot>(buf);
}

inline MessageRoot *GetMutableMessageRoot(void *buf) {
  return flatbuffers::GetMutableRoot<MessageRoot>(buf);
}

inline const char *MessageRootIdentifier() {
  return "PTCS";
}

inline bool MessageRootBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MessageRootIdentifier());
}

inline bool VerifyMessageRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ProtocolCS::MessageRoot>(MessageRootIdentifier());
}

inline void FinishMessageRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ProtocolCS::MessageRoot> root) {
  fbb.Finish(root, MessageRootIdentifier());
}

inline std::unique_ptr<MessageRootT> UnPackMessageRoot(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<MessageRootT>(GetMessageRoot(buf)->UnPack(res));
}

}  // namespace ProtocolCS

#endif  // FLATBUFFERS_GENERATED_PROTOCOLCS_PROTOCOLCS_H_
