// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAMEMESSAGE_MMOG_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_GAMEMESSAGE_MMOG_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace mmog {
namespace protocol {

struct Vec2;

struct Vec3;

struct HeroSimple;
struct HeroSimpleT;

struct Hero;
struct HeroT;

struct JoinRequest;
struct JoinRequestT;

struct JoinFailedReply;
struct JoinFailedReplyT;

struct JoinSuccessReply;
struct JoinSuccessReplyT;

struct LoginRequest;
struct LoginRequestT;

struct LoginFailedReply;
struct LoginFailedReplyT;

struct LoginSuccessReply;
struct LoginSuccessReplyT;

struct HeroListRequest;
struct HeroListRequestT;

struct HeroListFailedReply;
struct HeroListFailedReplyT;

struct HeroListReply;
struct HeroListReplyT;

struct SelectHeroRequest;
struct SelectHeroRequestT;

struct SelectHeroFailedReply;
struct SelectHeroFailedReplyT;

struct SelectHeroSuccessReply;
struct SelectHeroSuccessReplyT;

struct CreateHeroRequest;
struct CreateHeroRequestT;

struct CreateHeroFailedReply;
struct CreateHeroFailedReplyT;

struct CreateHeroSuccessReply;
struct CreateHeroSuccessReplyT;

struct DeleteHeroRequest;
struct DeleteHeroRequestT;

struct DeleteHeroFailedReply;
struct DeleteHeroFailedReplyT;

struct DeleteHeroSuccessReply;
struct DeleteHeroSuccessReplyT;

struct EnterGameRequest;
struct EnterGameRequestT;

struct BeginEnterGameReply;
struct BeginEnterGameReplyT;

struct EnterGameFailedReply;
struct EnterGameFailedReplyT;

struct LoadGameReply;
struct LoadGameReplyT;

struct EndLoadGameRequest;
struct EndLoadGameRequestT;

struct GameStartReply;
struct GameStartReplyT;

struct NetMessage;
struct NetMessageT;

enum ErrorCode {
  ErrorCode_OK = 0,
  ErrorCode_FATAL_ERROR = 1,
  ErrorCode_INVALID_SESSION = 10,
  ErrorCode_INVALID_STRING = 20,
  ErrorCode_JOIN_ACC_NAME_ALREADY = 100,
  ErrorCode_JOIN_CANNOT_ACC_CREATE = 101,
  ErrorCode_LOGIN_INCORRECT_ACC_NAME_OR_PASSWORD = 200,
  ErrorCode_LOGIN_ALREADY = 201,
  ErrorCode_CREATE_HERO_NAME_ALREADY = 301,
  ErrorCode_CREATE_HERO_CANNOT_CREATE = 302,
  ErrorCode_ENTER_GAME_INVALID_HERO = 401,
  ErrorCode_ENTER_GAME_INVALID_STATE = 402,
  ErrorCode_MIN = ErrorCode_OK,
  ErrorCode_MAX = ErrorCode_ENTER_GAME_INVALID_STATE
};

enum MessageT {
  MessageT_NONE = 0,
  MessageT_LoginRequest = 1,
  MessageT_LoginFailedReply = 2,
  MessageT_LoginSuccessReply = 3,
  MessageT_JoinRequest = 4,
  MessageT_JoinFailedReply = 5,
  MessageT_JoinSuccessReply = 6,
  MessageT_HeroListRequest = 7,
  MessageT_HeroListFailedReply = 8,
  MessageT_HeroListReply = 9,
  MessageT_CreateHeroRequest = 10,
  MessageT_CreateHeroFailedReply = 11,
  MessageT_CreateHeroSuccessReply = 12,
  MessageT_DeleteHeroRequest = 13,
  MessageT_DeleteHeroFailedReply = 14,
  MessageT_DeleteHeroSuccessReply = 15,
  MessageT_EnterGameRequest = 16,
  MessageT_EnterGameFailedReply = 17,
  MessageT_BeginEnterGameReply = 18,
  MessageT_LoadGameReply = 19,
  MessageT_EndLoadGameRequest = 20,
  MessageT_GameStartReply = 21,
  MessageT_MIN = MessageT_NONE,
  MessageT_MAX = MessageT_GameStartReply
};

inline const char **EnumNamesMessageT() {
  static const char *names[] = {
    "NONE",
    "LoginRequest",
    "LoginFailedReply",
    "LoginSuccessReply",
    "JoinRequest",
    "JoinFailedReply",
    "JoinSuccessReply",
    "HeroListRequest",
    "HeroListFailedReply",
    "HeroListReply",
    "CreateHeroRequest",
    "CreateHeroFailedReply",
    "CreateHeroSuccessReply",
    "DeleteHeroRequest",
    "DeleteHeroFailedReply",
    "DeleteHeroSuccessReply",
    "EnterGameRequest",
    "EnterGameFailedReply",
    "BeginEnterGameReply",
    "LoadGameReply",
    "EndLoadGameRequest",
    "GameStartReply",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageT(MessageT e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageT()[index];
}

template<typename T> struct MessageTTraits {
  static const MessageT enum_value = MessageT_NONE;
};

template<> struct MessageTTraits<LoginRequest> {
  static const MessageT enum_value = MessageT_LoginRequest;
};

template<> struct MessageTTraits<LoginFailedReply> {
  static const MessageT enum_value = MessageT_LoginFailedReply;
};

template<> struct MessageTTraits<LoginSuccessReply> {
  static const MessageT enum_value = MessageT_LoginSuccessReply;
};

template<> struct MessageTTraits<JoinRequest> {
  static const MessageT enum_value = MessageT_JoinRequest;
};

template<> struct MessageTTraits<JoinFailedReply> {
  static const MessageT enum_value = MessageT_JoinFailedReply;
};

template<> struct MessageTTraits<JoinSuccessReply> {
  static const MessageT enum_value = MessageT_JoinSuccessReply;
};

template<> struct MessageTTraits<HeroListRequest> {
  static const MessageT enum_value = MessageT_HeroListRequest;
};

template<> struct MessageTTraits<HeroListFailedReply> {
  static const MessageT enum_value = MessageT_HeroListFailedReply;
};

template<> struct MessageTTraits<HeroListReply> {
  static const MessageT enum_value = MessageT_HeroListReply;
};

template<> struct MessageTTraits<CreateHeroRequest> {
  static const MessageT enum_value = MessageT_CreateHeroRequest;
};

template<> struct MessageTTraits<CreateHeroFailedReply> {
  static const MessageT enum_value = MessageT_CreateHeroFailedReply;
};

template<> struct MessageTTraits<CreateHeroSuccessReply> {
  static const MessageT enum_value = MessageT_CreateHeroSuccessReply;
};

template<> struct MessageTTraits<DeleteHeroRequest> {
  static const MessageT enum_value = MessageT_DeleteHeroRequest;
};

template<> struct MessageTTraits<DeleteHeroFailedReply> {
  static const MessageT enum_value = MessageT_DeleteHeroFailedReply;
};

template<> struct MessageTTraits<DeleteHeroSuccessReply> {
  static const MessageT enum_value = MessageT_DeleteHeroSuccessReply;
};

template<> struct MessageTTraits<EnterGameRequest> {
  static const MessageT enum_value = MessageT_EnterGameRequest;
};

template<> struct MessageTTraits<EnterGameFailedReply> {
  static const MessageT enum_value = MessageT_EnterGameFailedReply;
};

template<> struct MessageTTraits<BeginEnterGameReply> {
  static const MessageT enum_value = MessageT_BeginEnterGameReply;
};

template<> struct MessageTTraits<LoadGameReply> {
  static const MessageT enum_value = MessageT_LoadGameReply;
};

template<> struct MessageTTraits<EndLoadGameRequest> {
  static const MessageT enum_value = MessageT_EndLoadGameRequest;
};

template<> struct MessageTTraits<GameStartReply> {
  static const MessageT enum_value = MessageT_GameStartReply;
};

struct MessageTUnion {
  MessageT type;
  flatbuffers::NativeTable *table;

  MessageTUnion() : type(MessageT_NONE), table(nullptr) {}
  MessageTUnion(const MessageTUnion &);
  MessageTUnion &operator=(const MessageTUnion &);
  ~MessageTUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& value) {
    Reset();
    type = MessageTTraits<typename T::TableType>::enum_value;
    if (type != MessageT_NONE) {
      table = new T(std::forward<T>(value));
    }
  }

  static flatbuffers::NativeTable *UnPack(const void *obj, MessageT type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  LoginRequestT *AsLoginRequest() {
    return type == MessageT_LoginRequest ?
      reinterpret_cast<LoginRequestT *>(table) : nullptr;
  }
  LoginFailedReplyT *AsLoginFailedReply() {
    return type == MessageT_LoginFailedReply ?
      reinterpret_cast<LoginFailedReplyT *>(table) : nullptr;
  }
  LoginSuccessReplyT *AsLoginSuccessReply() {
    return type == MessageT_LoginSuccessReply ?
      reinterpret_cast<LoginSuccessReplyT *>(table) : nullptr;
  }
  JoinRequestT *AsJoinRequest() {
    return type == MessageT_JoinRequest ?
      reinterpret_cast<JoinRequestT *>(table) : nullptr;
  }
  JoinFailedReplyT *AsJoinFailedReply() {
    return type == MessageT_JoinFailedReply ?
      reinterpret_cast<JoinFailedReplyT *>(table) : nullptr;
  }
  JoinSuccessReplyT *AsJoinSuccessReply() {
    return type == MessageT_JoinSuccessReply ?
      reinterpret_cast<JoinSuccessReplyT *>(table) : nullptr;
  }
  HeroListRequestT *AsHeroListRequest() {
    return type == MessageT_HeroListRequest ?
      reinterpret_cast<HeroListRequestT *>(table) : nullptr;
  }
  HeroListFailedReplyT *AsHeroListFailedReply() {
    return type == MessageT_HeroListFailedReply ?
      reinterpret_cast<HeroListFailedReplyT *>(table) : nullptr;
  }
  HeroListReplyT *AsHeroListReply() {
    return type == MessageT_HeroListReply ?
      reinterpret_cast<HeroListReplyT *>(table) : nullptr;
  }
  CreateHeroRequestT *AsCreateHeroRequest() {
    return type == MessageT_CreateHeroRequest ?
      reinterpret_cast<CreateHeroRequestT *>(table) : nullptr;
  }
  CreateHeroFailedReplyT *AsCreateHeroFailedReply() {
    return type == MessageT_CreateHeroFailedReply ?
      reinterpret_cast<CreateHeroFailedReplyT *>(table) : nullptr;
  }
  CreateHeroSuccessReplyT *AsCreateHeroSuccessReply() {
    return type == MessageT_CreateHeroSuccessReply ?
      reinterpret_cast<CreateHeroSuccessReplyT *>(table) : nullptr;
  }
  DeleteHeroRequestT *AsDeleteHeroRequest() {
    return type == MessageT_DeleteHeroRequest ?
      reinterpret_cast<DeleteHeroRequestT *>(table) : nullptr;
  }
  DeleteHeroFailedReplyT *AsDeleteHeroFailedReply() {
    return type == MessageT_DeleteHeroFailedReply ?
      reinterpret_cast<DeleteHeroFailedReplyT *>(table) : nullptr;
  }
  DeleteHeroSuccessReplyT *AsDeleteHeroSuccessReply() {
    return type == MessageT_DeleteHeroSuccessReply ?
      reinterpret_cast<DeleteHeroSuccessReplyT *>(table) : nullptr;
  }
  EnterGameRequestT *AsEnterGameRequest() {
    return type == MessageT_EnterGameRequest ?
      reinterpret_cast<EnterGameRequestT *>(table) : nullptr;
  }
  EnterGameFailedReplyT *AsEnterGameFailedReply() {
    return type == MessageT_EnterGameFailedReply ?
      reinterpret_cast<EnterGameFailedReplyT *>(table) : nullptr;
  }
  BeginEnterGameReplyT *AsBeginEnterGameReply() {
    return type == MessageT_BeginEnterGameReply ?
      reinterpret_cast<BeginEnterGameReplyT *>(table) : nullptr;
  }
  LoadGameReplyT *AsLoadGameReply() {
    return type == MessageT_LoadGameReply ?
      reinterpret_cast<LoadGameReplyT *>(table) : nullptr;
  }
  EndLoadGameRequestT *AsEndLoadGameRequest() {
    return type == MessageT_EndLoadGameRequest ?
      reinterpret_cast<EndLoadGameRequestT *>(table) : nullptr;
  }
  GameStartReplyT *AsGameStartReply() {
    return type == MessageT_GameStartReply ?
      reinterpret_cast<GameStartReplyT *>(table) : nullptr;
  }
};

bool VerifyMessageT(flatbuffers::Verifier &verifier, const void *obj, MessageT type);

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(this, 0, sizeof(Vec2));
  }
  Vec2(const Vec2 &_o) {
    memcpy(this, &_o, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(const Vec3 &_o) {
    memcpy(this, &_o, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vec3, 12);

struct HeroSimpleT : public flatbuffers::NativeTable {
  typedef HeroSimple TableType;
  int32_t id;
  std::string name;
  int32_t class_type;
  int32_t level;
  HeroSimpleT()
      : id(0),
        class_type(0),
        level(0) {
  }
};

struct HeroSimple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeroSimpleT NativeTableType;
  enum {
    VT_ID = 4,
    VT_NAME = 6,
    VT_CLASS_TYPE = 8,
    VT_LEVEL = 10
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t class_type() const {
    return GetField<int32_t>(VT_CLASS_TYPE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
  HeroSimpleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeroSimpleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HeroSimple> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroSimpleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeroSimpleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(HeroSimple::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(HeroSimple::VT_NAME, name);
  }
  void add_class_type(int32_t class_type) {
    fbb_.AddElement<int32_t>(HeroSimple::VT_CLASS_TYPE, class_type, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(HeroSimple::VT_LEVEL, level, 0);
  }
  HeroSimpleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroSimpleBuilder &operator=(const HeroSimpleBuilder &);
  flatbuffers::Offset<HeroSimple> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<HeroSimple>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeroSimple> CreateHeroSimple(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t class_type = 0,
    int32_t level = 0) {
  HeroSimpleBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<HeroSimple> CreateHeroSimpleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    int32_t class_type = 0,
    int32_t level = 0) {
  return CreateHeroSimple(
      _fbb,
      id,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      level);
}

flatbuffers::Offset<HeroSimple> CreateHeroSimple(flatbuffers::FlatBufferBuilder &_fbb, const HeroSimpleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HeroT : public flatbuffers::NativeTable {
  typedef Hero TableType;
  int32_t id;
  std::string name;
  int32_t class_type;
  int32_t exp;
  int32_t level;
  int32_t hp;
  int32_t mp;
  int32_t att;
  int32_t def;
  int32_t zone_id;
  std::unique_ptr<Vec2> pos;
  std::unique_ptr<Vec2> direction;
  HeroT()
      : id(0),
        class_type(0),
        exp(0),
        level(0),
        hp(0),
        mp(0),
        att(0),
        def(0),
        zone_id(0) {
  }
};

struct Hero FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeroT NativeTableType;
  enum {
    VT_ID = 4,
    VT_NAME = 6,
    VT_CLASS_TYPE = 8,
    VT_EXP = 10,
    VT_LEVEL = 12,
    VT_HP = 14,
    VT_MP = 16,
    VT_ATT = 18,
    VT_DEF = 20,
    VT_ZONE_ID = 22,
    VT_POS = 24,
    VT_DIRECTION = 26
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t class_type() const {
    return GetField<int32_t>(VT_CLASS_TYPE, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  int32_t att() const {
    return GetField<int32_t>(VT_ATT, 0);
  }
  int32_t def() const {
    return GetField<int32_t>(VT_DEF, 0);
  }
  int32_t zone_id() const {
    return GetField<int32_t>(VT_ZONE_ID, 0);
  }
  const Vec2 *pos() const {
    return GetStruct<const Vec2 *>(VT_POS);
  }
  const Vec2 *direction() const {
    return GetStruct<const Vec2 *>(VT_DIRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<int32_t>(verifier, VT_ATT) &&
           VerifyField<int32_t>(verifier, VT_DEF) &&
           VerifyField<int32_t>(verifier, VT_ZONE_ID) &&
           VerifyField<Vec2>(verifier, VT_POS) &&
           VerifyField<Vec2>(verifier, VT_DIRECTION) &&
           verifier.EndTable();
  }
  HeroT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeroT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Hero> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeroBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Hero::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Hero::VT_NAME, name);
  }
  void add_class_type(int32_t class_type) {
    fbb_.AddElement<int32_t>(Hero::VT_CLASS_TYPE, class_type, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(Hero::VT_EXP, exp, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(Hero::VT_LEVEL, level, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(Hero::VT_HP, hp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(Hero::VT_MP, mp, 0);
  }
  void add_att(int32_t att) {
    fbb_.AddElement<int32_t>(Hero::VT_ATT, att, 0);
  }
  void add_def(int32_t def) {
    fbb_.AddElement<int32_t>(Hero::VT_DEF, def, 0);
  }
  void add_zone_id(int32_t zone_id) {
    fbb_.AddElement<int32_t>(Hero::VT_ZONE_ID, zone_id, 0);
  }
  void add_pos(const Vec2 *pos) {
    fbb_.AddStruct(Hero::VT_POS, pos);
  }
  void add_direction(const Vec2 *direction) {
    fbb_.AddStruct(Hero::VT_DIRECTION, direction);
  }
  HeroBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroBuilder &operator=(const HeroBuilder &);
  flatbuffers::Offset<Hero> Finish() {
    const auto end = fbb_.EndTable(start_, 12);
    auto o = flatbuffers::Offset<Hero>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hero> CreateHero(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t class_type = 0,
    int32_t exp = 0,
    int32_t level = 0,
    int32_t hp = 0,
    int32_t mp = 0,
    int32_t att = 0,
    int32_t def = 0,
    int32_t zone_id = 0,
    const Vec2 *pos = 0,
    const Vec2 *direction = 0) {
  HeroBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_pos(pos);
  builder_.add_zone_id(zone_id);
  builder_.add_def(def);
  builder_.add_att(att);
  builder_.add_mp(mp);
  builder_.add_hp(hp);
  builder_.add_level(level);
  builder_.add_exp(exp);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hero> CreateHeroDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    int32_t class_type = 0,
    int32_t exp = 0,
    int32_t level = 0,
    int32_t hp = 0,
    int32_t mp = 0,
    int32_t att = 0,
    int32_t def = 0,
    int32_t zone_id = 0,
    const Vec2 *pos = 0,
    const Vec2 *direction = 0) {
  return CreateHero(
      _fbb,
      id,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      exp,
      level,
      hp,
      mp,
      att,
      def,
      zone_id,
      pos,
      direction);
}

flatbuffers::Offset<Hero> CreateHero(flatbuffers::FlatBufferBuilder &_fbb, const HeroT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JoinRequestT : public flatbuffers::NativeTable {
  typedef JoinRequest TableType;
  std::string acc_name;
  std::string password;
  JoinRequestT() {
  }
};

struct JoinRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JoinRequestT NativeTableType;
  enum {
    VT_ACC_NAME = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *acc_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ACC_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ACC_NAME) &&
           verifier.Verify(acc_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
  JoinRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JoinRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<JoinRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const JoinRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JoinRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc_name(flatbuffers::Offset<flatbuffers::String> acc_name) {
    fbb_.AddOffset(JoinRequest::VT_ACC_NAME, acc_name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(JoinRequest::VT_PASSWORD, password);
  }
  JoinRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinRequestBuilder &operator=(const JoinRequestBuilder &);
  flatbuffers::Offset<JoinRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<JoinRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<JoinRequest> CreateJoinRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> acc_name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  JoinRequestBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_acc_name(acc_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<JoinRequest> CreateJoinRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *acc_name = nullptr,
    const char *password = nullptr) {
  return CreateJoinRequest(
      _fbb,
      acc_name ? _fbb.CreateString(acc_name) : 0,
      password ? _fbb.CreateString(password) : 0);
}

flatbuffers::Offset<JoinRequest> CreateJoinRequest(flatbuffers::FlatBufferBuilder &_fbb, const JoinRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JoinFailedReplyT : public flatbuffers::NativeTable {
  typedef JoinFailedReply TableType;
  ErrorCode error_code;
  JoinFailedReplyT()
      : error_code(ErrorCode_OK) {
  }
};

struct JoinFailedReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JoinFailedReplyT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  JoinFailedReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JoinFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<JoinFailedReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const JoinFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JoinFailedReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(JoinFailedReply::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  JoinFailedReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinFailedReplyBuilder &operator=(const JoinFailedReplyBuilder &);
  flatbuffers::Offset<JoinFailedReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<JoinFailedReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<JoinFailedReply> CreateJoinFailedReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_OK) {
  JoinFailedReplyBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<JoinFailedReply> CreateJoinFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const JoinFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JoinSuccessReplyT : public flatbuffers::NativeTable {
  typedef JoinSuccessReply TableType;
  JoinSuccessReplyT() {
  }
};

struct JoinSuccessReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JoinSuccessReplyT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  JoinSuccessReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JoinSuccessReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<JoinSuccessReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const JoinSuccessReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JoinSuccessReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  JoinSuccessReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinSuccessReplyBuilder &operator=(const JoinSuccessReplyBuilder &);
  flatbuffers::Offset<JoinSuccessReply> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<JoinSuccessReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<JoinSuccessReply> CreateJoinSuccessReply(
    flatbuffers::FlatBufferBuilder &_fbb) {
  JoinSuccessReplyBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<JoinSuccessReply> CreateJoinSuccessReply(flatbuffers::FlatBufferBuilder &_fbb, const JoinSuccessReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoginRequestT : public flatbuffers::NativeTable {
  typedef LoginRequest TableType;
  std::string acc_name;
  std::string password;
  LoginRequestT() {
  }
};

struct LoginRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoginRequestT NativeTableType;
  enum {
    VT_ACC_NAME = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *acc_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ACC_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ACC_NAME) &&
           verifier.Verify(acc_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
  LoginRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoginRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoginRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoginRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc_name(flatbuffers::Offset<flatbuffers::String> acc_name) {
    fbb_.AddOffset(LoginRequest::VT_ACC_NAME, acc_name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(LoginRequest::VT_PASSWORD, password);
  }
  LoginRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoginRequestBuilder &operator=(const LoginRequestBuilder &);
  flatbuffers::Offset<LoginRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<LoginRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoginRequest> CreateLoginRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> acc_name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  LoginRequestBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_acc_name(acc_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoginRequest> CreateLoginRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *acc_name = nullptr,
    const char *password = nullptr) {
  return CreateLoginRequest(
      _fbb,
      acc_name ? _fbb.CreateString(acc_name) : 0,
      password ? _fbb.CreateString(password) : 0);
}

flatbuffers::Offset<LoginRequest> CreateLoginRequest(flatbuffers::FlatBufferBuilder &_fbb, const LoginRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoginFailedReplyT : public flatbuffers::NativeTable {
  typedef LoginFailedReply TableType;
  ErrorCode error_code;
  LoginFailedReplyT()
      : error_code(ErrorCode_OK) {
  }
};

struct LoginFailedReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoginFailedReplyT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  LoginFailedReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoginFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoginFailedReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoginFailedReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(LoginFailedReply::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  LoginFailedReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoginFailedReplyBuilder &operator=(const LoginFailedReplyBuilder &);
  flatbuffers::Offset<LoginFailedReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<LoginFailedReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoginFailedReply> CreateLoginFailedReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_OK) {
  LoginFailedReplyBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<LoginFailedReply> CreateLoginFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const LoginFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoginSuccessReplyT : public flatbuffers::NativeTable {
  typedef LoginSuccessReply TableType;
  std::string session_id;
  LoginSuccessReplyT() {
  }
};

struct LoginSuccessReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoginSuccessReplyT NativeTableType;
  enum {
    VT_SESSION_ID = 4
  };
  const flatbuffers::String *session_id() const {
    return GetPointer<const flatbuffers::String *>(VT_SESSION_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SESSION_ID) &&
           verifier.Verify(session_id()) &&
           verifier.EndTable();
  }
  LoginSuccessReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoginSuccessReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoginSuccessReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginSuccessReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoginSuccessReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session_id(flatbuffers::Offset<flatbuffers::String> session_id) {
    fbb_.AddOffset(LoginSuccessReply::VT_SESSION_ID, session_id);
  }
  LoginSuccessReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoginSuccessReplyBuilder &operator=(const LoginSuccessReplyBuilder &);
  flatbuffers::Offset<LoginSuccessReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<LoginSuccessReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoginSuccessReply> CreateLoginSuccessReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> session_id = 0) {
  LoginSuccessReplyBuilder builder_(_fbb);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoginSuccessReply> CreateLoginSuccessReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *session_id = nullptr) {
  return CreateLoginSuccessReply(
      _fbb,
      session_id ? _fbb.CreateString(session_id) : 0);
}

flatbuffers::Offset<LoginSuccessReply> CreateLoginSuccessReply(flatbuffers::FlatBufferBuilder &_fbb, const LoginSuccessReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HeroListRequestT : public flatbuffers::NativeTable {
  typedef HeroListRequest TableType;
  HeroListRequestT() {
  }
};

struct HeroListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeroListRequestT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  HeroListRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeroListRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HeroListRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroListRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeroListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  HeroListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroListRequestBuilder &operator=(const HeroListRequestBuilder &);
  flatbuffers::Offset<HeroListRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<HeroListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeroListRequest> CreateHeroListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HeroListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<HeroListRequest> CreateHeroListRequest(flatbuffers::FlatBufferBuilder &_fbb, const HeroListRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HeroListFailedReplyT : public flatbuffers::NativeTable {
  typedef HeroListFailedReply TableType;
  ErrorCode error_code;
  HeroListFailedReplyT()
      : error_code(ErrorCode_OK) {
  }
};

struct HeroListFailedReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeroListFailedReplyT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  HeroListFailedReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeroListFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HeroListFailedReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroListFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeroListFailedReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(HeroListFailedReply::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  HeroListFailedReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroListFailedReplyBuilder &operator=(const HeroListFailedReplyBuilder &);
  flatbuffers::Offset<HeroListFailedReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<HeroListFailedReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeroListFailedReply> CreateHeroListFailedReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_OK) {
  HeroListFailedReplyBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<HeroListFailedReply> CreateHeroListFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const HeroListFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HeroListReplyT : public flatbuffers::NativeTable {
  typedef HeroListReply TableType;
  std::vector<std::unique_ptr<HeroSimpleT>> hero_list;
  HeroListReplyT() {
  }
};

struct HeroListReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeroListReplyT NativeTableType;
  enum {
    VT_HERO_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<HeroSimple>> *hero_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HeroSimple>> *>(VT_HERO_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HERO_LIST) &&
           verifier.Verify(hero_list()) &&
           verifier.VerifyVectorOfTables(hero_list()) &&
           verifier.EndTable();
  }
  HeroListReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeroListReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HeroListReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroListReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeroListReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeroSimple>>> hero_list) {
    fbb_.AddOffset(HeroListReply::VT_HERO_LIST, hero_list);
  }
  HeroListReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroListReplyBuilder &operator=(const HeroListReplyBuilder &);
  flatbuffers::Offset<HeroListReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<HeroListReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeroListReply> CreateHeroListReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeroSimple>>> hero_list = 0) {
  HeroListReplyBuilder builder_(_fbb);
  builder_.add_hero_list(hero_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<HeroListReply> CreateHeroListReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<HeroSimple>> *hero_list = nullptr) {
  return CreateHeroListReply(
      _fbb,
      hero_list ? _fbb.CreateVector<flatbuffers::Offset<HeroSimple>>(*hero_list) : 0);
}

flatbuffers::Offset<HeroListReply> CreateHeroListReply(flatbuffers::FlatBufferBuilder &_fbb, const HeroListReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectHeroRequestT : public flatbuffers::NativeTable {
  typedef SelectHeroRequest TableType;
  int32_t hero_id;
  SelectHeroRequestT()
      : hero_id(0) {
  }
};

struct SelectHeroRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectHeroRequestT NativeTableType;
  enum {
    VT_HERO_ID = 4
  };
  int32_t hero_id() const {
    return GetField<int32_t>(VT_HERO_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HERO_ID) &&
           verifier.EndTable();
  }
  SelectHeroRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectHeroRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelectHeroRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectHeroRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectHeroRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero_id(int32_t hero_id) {
    fbb_.AddElement<int32_t>(SelectHeroRequest::VT_HERO_ID, hero_id, 0);
  }
  SelectHeroRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectHeroRequestBuilder &operator=(const SelectHeroRequestBuilder &);
  flatbuffers::Offset<SelectHeroRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SelectHeroRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectHeroRequest> CreateSelectHeroRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hero_id = 0) {
  SelectHeroRequestBuilder builder_(_fbb);
  builder_.add_hero_id(hero_id);
  return builder_.Finish();
}

flatbuffers::Offset<SelectHeroRequest> CreateSelectHeroRequest(flatbuffers::FlatBufferBuilder &_fbb, const SelectHeroRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectHeroFailedReplyT : public flatbuffers::NativeTable {
  typedef SelectHeroFailedReply TableType;
  ErrorCode error_code;
  SelectHeroFailedReplyT()
      : error_code(ErrorCode_OK) {
  }
};

struct SelectHeroFailedReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectHeroFailedReplyT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  SelectHeroFailedReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectHeroFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelectHeroFailedReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectHeroFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectHeroFailedReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(SelectHeroFailedReply::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  SelectHeroFailedReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectHeroFailedReplyBuilder &operator=(const SelectHeroFailedReplyBuilder &);
  flatbuffers::Offset<SelectHeroFailedReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SelectHeroFailedReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectHeroFailedReply> CreateSelectHeroFailedReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_OK) {
  SelectHeroFailedReplyBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<SelectHeroFailedReply> CreateSelectHeroFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const SelectHeroFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SelectHeroSuccessReplyT : public flatbuffers::NativeTable {
  typedef SelectHeroSuccessReply TableType;
  SelectHeroSuccessReplyT() {
  }
};

struct SelectHeroSuccessReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectHeroSuccessReplyT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  SelectHeroSuccessReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SelectHeroSuccessReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SelectHeroSuccessReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectHeroSuccessReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SelectHeroSuccessReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  SelectHeroSuccessReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectHeroSuccessReplyBuilder &operator=(const SelectHeroSuccessReplyBuilder &);
  flatbuffers::Offset<SelectHeroSuccessReply> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<SelectHeroSuccessReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectHeroSuccessReply> CreateSelectHeroSuccessReply(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectHeroSuccessReplyBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<SelectHeroSuccessReply> CreateSelectHeroSuccessReply(flatbuffers::FlatBufferBuilder &_fbb, const SelectHeroSuccessReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreateHeroRequestT : public flatbuffers::NativeTable {
  typedef CreateHeroRequest TableType;
  std::string name;
  int32_t class_type;
  CreateHeroRequestT()
      : class_type(0) {
  }
};

struct CreateHeroRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateHeroRequestT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_CLASS_TYPE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t class_type() const {
    return GetField<int32_t>(VT_CLASS_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           verifier.EndTable();
  }
  CreateHeroRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreateHeroRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreateHeroRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateHeroRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreateHeroRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CreateHeroRequest::VT_NAME, name);
  }
  void add_class_type(int32_t class_type) {
    fbb_.AddElement<int32_t>(CreateHeroRequest::VT_CLASS_TYPE, class_type, 0);
  }
  CreateHeroRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreateHeroRequestBuilder &operator=(const CreateHeroRequestBuilder &);
  flatbuffers::Offset<CreateHeroRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<CreateHeroRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateHeroRequest> CreateCreateHeroRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t class_type = 0) {
  CreateHeroRequestBuilder builder_(_fbb);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreateHeroRequest> CreateCreateHeroRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t class_type = 0) {
  return CreateCreateHeroRequest(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      class_type);
}

flatbuffers::Offset<CreateHeroRequest> CreateCreateHeroRequest(flatbuffers::FlatBufferBuilder &_fbb, const CreateHeroRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreateHeroFailedReplyT : public flatbuffers::NativeTable {
  typedef CreateHeroFailedReply TableType;
  ErrorCode error_code;
  CreateHeroFailedReplyT()
      : error_code(ErrorCode_OK) {
  }
};

struct CreateHeroFailedReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateHeroFailedReplyT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  CreateHeroFailedReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreateHeroFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreateHeroFailedReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateHeroFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreateHeroFailedReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(CreateHeroFailedReply::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  CreateHeroFailedReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreateHeroFailedReplyBuilder &operator=(const CreateHeroFailedReplyBuilder &);
  flatbuffers::Offset<CreateHeroFailedReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CreateHeroFailedReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateHeroFailedReply> CreateCreateHeroFailedReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_OK) {
  CreateHeroFailedReplyBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<CreateHeroFailedReply> CreateCreateHeroFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const CreateHeroFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreateHeroSuccessReplyT : public flatbuffers::NativeTable {
  typedef CreateHeroSuccessReply TableType;
  std::unique_ptr<HeroSimpleT> hero;
  CreateHeroSuccessReplyT() {
  }
};

struct CreateHeroSuccessReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateHeroSuccessReplyT NativeTableType;
  enum {
    VT_HERO = 4
  };
  const HeroSimple *hero() const {
    return GetPointer<const HeroSimple *>(VT_HERO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HERO) &&
           verifier.VerifyTable(hero()) &&
           verifier.EndTable();
  }
  CreateHeroSuccessReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreateHeroSuccessReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreateHeroSuccessReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateHeroSuccessReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreateHeroSuccessReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero(flatbuffers::Offset<HeroSimple> hero) {
    fbb_.AddOffset(CreateHeroSuccessReply::VT_HERO, hero);
  }
  CreateHeroSuccessReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreateHeroSuccessReplyBuilder &operator=(const CreateHeroSuccessReplyBuilder &);
  flatbuffers::Offset<CreateHeroSuccessReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CreateHeroSuccessReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateHeroSuccessReply> CreateCreateHeroSuccessReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<HeroSimple> hero = 0) {
  CreateHeroSuccessReplyBuilder builder_(_fbb);
  builder_.add_hero(hero);
  return builder_.Finish();
}

flatbuffers::Offset<CreateHeroSuccessReply> CreateCreateHeroSuccessReply(flatbuffers::FlatBufferBuilder &_fbb, const CreateHeroSuccessReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeleteHeroRequestT : public flatbuffers::NativeTable {
  typedef DeleteHeroRequest TableType;
  int32_t hero_id;
  DeleteHeroRequestT()
      : hero_id(0) {
  }
};

struct DeleteHeroRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeleteHeroRequestT NativeTableType;
  enum {
    VT_HERO_ID = 4
  };
  int32_t hero_id() const {
    return GetField<int32_t>(VT_HERO_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HERO_ID) &&
           verifier.EndTable();
  }
  DeleteHeroRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeleteHeroRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DeleteHeroRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeleteHeroRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeleteHeroRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero_id(int32_t hero_id) {
    fbb_.AddElement<int32_t>(DeleteHeroRequest::VT_HERO_ID, hero_id, 0);
  }
  DeleteHeroRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeleteHeroRequestBuilder &operator=(const DeleteHeroRequestBuilder &);
  flatbuffers::Offset<DeleteHeroRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DeleteHeroRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeleteHeroRequest> CreateDeleteHeroRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hero_id = 0) {
  DeleteHeroRequestBuilder builder_(_fbb);
  builder_.add_hero_id(hero_id);
  return builder_.Finish();
}

flatbuffers::Offset<DeleteHeroRequest> CreateDeleteHeroRequest(flatbuffers::FlatBufferBuilder &_fbb, const DeleteHeroRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeleteHeroFailedReplyT : public flatbuffers::NativeTable {
  typedef DeleteHeroFailedReply TableType;
  ErrorCode error_code;
  DeleteHeroFailedReplyT()
      : error_code(ErrorCode_OK) {
  }
};

struct DeleteHeroFailedReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeleteHeroFailedReplyT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  DeleteHeroFailedReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeleteHeroFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DeleteHeroFailedReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeleteHeroFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeleteHeroFailedReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(DeleteHeroFailedReply::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  DeleteHeroFailedReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeleteHeroFailedReplyBuilder &operator=(const DeleteHeroFailedReplyBuilder &);
  flatbuffers::Offset<DeleteHeroFailedReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DeleteHeroFailedReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeleteHeroFailedReply> CreateDeleteHeroFailedReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_OK) {
  DeleteHeroFailedReplyBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<DeleteHeroFailedReply> CreateDeleteHeroFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const DeleteHeroFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeleteHeroSuccessReplyT : public flatbuffers::NativeTable {
  typedef DeleteHeroSuccessReply TableType;
  int32_t hero_id;
  DeleteHeroSuccessReplyT()
      : hero_id(0) {
  }
};

struct DeleteHeroSuccessReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeleteHeroSuccessReplyT NativeTableType;
  enum {
    VT_HERO_ID = 4
  };
  int32_t hero_id() const {
    return GetField<int32_t>(VT_HERO_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HERO_ID) &&
           verifier.EndTable();
  }
  DeleteHeroSuccessReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeleteHeroSuccessReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DeleteHeroSuccessReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeleteHeroSuccessReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeleteHeroSuccessReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero_id(int32_t hero_id) {
    fbb_.AddElement<int32_t>(DeleteHeroSuccessReply::VT_HERO_ID, hero_id, 0);
  }
  DeleteHeroSuccessReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeleteHeroSuccessReplyBuilder &operator=(const DeleteHeroSuccessReplyBuilder &);
  flatbuffers::Offset<DeleteHeroSuccessReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DeleteHeroSuccessReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeleteHeroSuccessReply> CreateDeleteHeroSuccessReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hero_id = 0) {
  DeleteHeroSuccessReplyBuilder builder_(_fbb);
  builder_.add_hero_id(hero_id);
  return builder_.Finish();
}

flatbuffers::Offset<DeleteHeroSuccessReply> CreateDeleteHeroSuccessReply(flatbuffers::FlatBufferBuilder &_fbb, const DeleteHeroSuccessReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnterGameRequestT : public flatbuffers::NativeTable {
  typedef EnterGameRequest TableType;
  int32_t hero_id;
  EnterGameRequestT()
      : hero_id(0) {
  }
};

struct EnterGameRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnterGameRequestT NativeTableType;
  enum {
    VT_HERO_ID = 4
  };
  int32_t hero_id() const {
    return GetField<int32_t>(VT_HERO_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HERO_ID) &&
           verifier.EndTable();
  }
  EnterGameRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnterGameRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EnterGameRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnterGameRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero_id(int32_t hero_id) {
    fbb_.AddElement<int32_t>(EnterGameRequest::VT_HERO_ID, hero_id, 0);
  }
  EnterGameRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterGameRequestBuilder &operator=(const EnterGameRequestBuilder &);
  flatbuffers::Offset<EnterGameRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<EnterGameRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnterGameRequest> CreateEnterGameRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t hero_id = 0) {
  EnterGameRequestBuilder builder_(_fbb);
  builder_.add_hero_id(hero_id);
  return builder_.Finish();
}

flatbuffers::Offset<EnterGameRequest> CreateEnterGameRequest(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BeginEnterGameReplyT : public flatbuffers::NativeTable {
  typedef BeginEnterGameReply TableType;
  BeginEnterGameReplyT() {
  }
};

struct BeginEnterGameReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BeginEnterGameReplyT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  BeginEnterGameReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BeginEnterGameReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BeginEnterGameReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BeginEnterGameReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BeginEnterGameReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  BeginEnterGameReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BeginEnterGameReplyBuilder &operator=(const BeginEnterGameReplyBuilder &);
  flatbuffers::Offset<BeginEnterGameReply> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<BeginEnterGameReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<BeginEnterGameReply> CreateBeginEnterGameReply(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BeginEnterGameReplyBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<BeginEnterGameReply> CreateBeginEnterGameReply(flatbuffers::FlatBufferBuilder &_fbb, const BeginEnterGameReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnterGameFailedReplyT : public flatbuffers::NativeTable {
  typedef EnterGameFailedReply TableType;
  ErrorCode error_code;
  EnterGameFailedReplyT()
      : error_code(ErrorCode_OK) {
  }
};

struct EnterGameFailedReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnterGameFailedReplyT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  EnterGameFailedReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnterGameFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EnterGameFailedReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnterGameFailedReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(EnterGameFailedReply::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  EnterGameFailedReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterGameFailedReplyBuilder &operator=(const EnterGameFailedReplyBuilder &);
  flatbuffers::Offset<EnterGameFailedReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<EnterGameFailedReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnterGameFailedReply> CreateEnterGameFailedReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_OK) {
  EnterGameFailedReplyBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<EnterGameFailedReply> CreateEnterGameFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoadGameReplyT : public flatbuffers::NativeTable {
  typedef LoadGameReply TableType;
  LoadGameReplyT() {
  }
};

struct LoadGameReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoadGameReplyT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  LoadGameReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoadGameReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoadGameReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoadGameReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoadGameReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  LoadGameReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoadGameReplyBuilder &operator=(const LoadGameReplyBuilder &);
  flatbuffers::Offset<LoadGameReply> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<LoadGameReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoadGameReply> CreateLoadGameReply(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LoadGameReplyBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<LoadGameReply> CreateLoadGameReply(flatbuffers::FlatBufferBuilder &_fbb, const LoadGameReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EndLoadGameRequestT : public flatbuffers::NativeTable {
  typedef EndLoadGameRequest TableType;
  EndLoadGameRequestT() {
  }
};

struct EndLoadGameRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EndLoadGameRequestT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  EndLoadGameRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EndLoadGameRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EndLoadGameRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndLoadGameRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EndLoadGameRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  EndLoadGameRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndLoadGameRequestBuilder &operator=(const EndLoadGameRequestBuilder &);
  flatbuffers::Offset<EndLoadGameRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<EndLoadGameRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<EndLoadGameRequest> CreateEndLoadGameRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EndLoadGameRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<EndLoadGameRequest> CreateEndLoadGameRequest(flatbuffers::FlatBufferBuilder &_fbb, const EndLoadGameRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GameStartReplyT : public flatbuffers::NativeTable {
  typedef GameStartReply TableType;
  GameStartReplyT() {
  }
};

struct GameStartReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GameStartReplyT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GameStartReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GameStartReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GameStartReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GameStartReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GameStartReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  GameStartReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameStartReplyBuilder &operator=(const GameStartReplyBuilder &);
  flatbuffers::Offset<GameStartReply> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<GameStartReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameStartReply> CreateGameStartReply(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GameStartReplyBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<GameStartReply> CreateGameStartReply(flatbuffers::FlatBufferBuilder &_fbb, const GameStartReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NetMessageT : public flatbuffers::NativeTable {
  typedef NetMessage TableType;
  MessageTUnion message;
  NetMessageT() {
  }
};

struct NetMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NetMessageT NativeTableType;
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  MessageT message_type() const {
    return static_cast<MessageT>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           VerifyMessageT(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
  NetMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NetMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NetMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NetMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(MessageT message_type) {
    fbb_.AddElement<uint8_t>(NetMessage::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(NetMessage::VT_MESSAGE, message);
  }
  NetMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NetMessageBuilder &operator=(const NetMessageBuilder &);
  flatbuffers::Offset<NetMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<NetMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetMessage> CreateNetMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    MessageT message_type = MessageT_NONE,
    flatbuffers::Offset<void> message = 0) {
  NetMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

flatbuffers::Offset<NetMessage> CreateNetMessage(flatbuffers::FlatBufferBuilder &_fbb, const NetMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline HeroSimpleT *HeroSimple::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HeroSimpleT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HeroSimple::UnPackTo(HeroSimpleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = level(); _o->level = _e; };
}

inline flatbuffers::Offset<HeroSimple> HeroSimple::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroSimpleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHeroSimple(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HeroSimple> CreateHeroSimple(flatbuffers::FlatBufferBuilder &_fbb, const HeroSimpleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _id = _o->id;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _level = _o->level;
  return CreateHeroSimple(
      _fbb,
      _id,
      _name,
      _class_type,
      _level);
}

inline HeroT *Hero::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HeroT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Hero::UnPackTo(HeroT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = exp(); _o->exp = _e; };
  { auto _e = level(); _o->level = _e; };
  { auto _e = hp(); _o->hp = _e; };
  { auto _e = mp(); _o->mp = _e; };
  { auto _e = att(); _o->att = _e; };
  { auto _e = def(); _o->def = _e; };
  { auto _e = zone_id(); _o->zone_id = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<Vec2>(new Vec2(*_e)); };
}

inline flatbuffers::Offset<Hero> Hero::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHero(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Hero> CreateHero(flatbuffers::FlatBufferBuilder &_fbb, const HeroT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _id = _o->id;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _exp = _o->exp;
  auto _level = _o->level;
  auto _hp = _o->hp;
  auto _mp = _o->mp;
  auto _att = _o->att;
  auto _def = _o->def;
  auto _zone_id = _o->zone_id;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _direction = _o->direction ? _o->direction.get() : 0;
  return CreateHero(
      _fbb,
      _id,
      _name,
      _class_type,
      _exp,
      _level,
      _hp,
      _mp,
      _att,
      _def,
      _zone_id,
      _pos,
      _direction);
}

inline JoinRequestT *JoinRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new JoinRequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void JoinRequest::UnPackTo(JoinRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = acc_name(); if (_e) _o->acc_name = _e->str(); };
  { auto _e = password(); if (_e) _o->password = _e->str(); };
}

inline flatbuffers::Offset<JoinRequest> JoinRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const JoinRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJoinRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<JoinRequest> CreateJoinRequest(flatbuffers::FlatBufferBuilder &_fbb, const JoinRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _acc_name = _o->acc_name.size() ? _fbb.CreateString(_o->acc_name) : 0;
  auto _password = _o->password.size() ? _fbb.CreateString(_o->password) : 0;
  return CreateJoinRequest(
      _fbb,
      _acc_name,
      _password);
}

inline JoinFailedReplyT *JoinFailedReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new JoinFailedReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void JoinFailedReply::UnPackTo(JoinFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<JoinFailedReply> JoinFailedReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const JoinFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJoinFailedReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<JoinFailedReply> CreateJoinFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const JoinFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateJoinFailedReply(
      _fbb,
      _error_code);
}

inline JoinSuccessReplyT *JoinSuccessReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new JoinSuccessReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void JoinSuccessReply::UnPackTo(JoinSuccessReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<JoinSuccessReply> JoinSuccessReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const JoinSuccessReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJoinSuccessReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<JoinSuccessReply> CreateJoinSuccessReply(flatbuffers::FlatBufferBuilder &_fbb, const JoinSuccessReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return CreateJoinSuccessReply(
      _fbb);
}

inline LoginRequestT *LoginRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LoginRequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LoginRequest::UnPackTo(LoginRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = acc_name(); if (_e) _o->acc_name = _e->str(); };
  { auto _e = password(); if (_e) _o->password = _e->str(); };
}

inline flatbuffers::Offset<LoginRequest> LoginRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoginRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoginRequest> CreateLoginRequest(flatbuffers::FlatBufferBuilder &_fbb, const LoginRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _acc_name = _o->acc_name.size() ? _fbb.CreateString(_o->acc_name) : 0;
  auto _password = _o->password.size() ? _fbb.CreateString(_o->password) : 0;
  return CreateLoginRequest(
      _fbb,
      _acc_name,
      _password);
}

inline LoginFailedReplyT *LoginFailedReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LoginFailedReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LoginFailedReply::UnPackTo(LoginFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<LoginFailedReply> LoginFailedReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoginFailedReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoginFailedReply> CreateLoginFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const LoginFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateLoginFailedReply(
      _fbb,
      _error_code);
}

inline LoginSuccessReplyT *LoginSuccessReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LoginSuccessReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LoginSuccessReply::UnPackTo(LoginSuccessReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session_id(); if (_e) _o->session_id = _e->str(); };
}

inline flatbuffers::Offset<LoginSuccessReply> LoginSuccessReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginSuccessReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoginSuccessReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoginSuccessReply> CreateLoginSuccessReply(flatbuffers::FlatBufferBuilder &_fbb, const LoginSuccessReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _session_id = _o->session_id.size() ? _fbb.CreateString(_o->session_id) : 0;
  return CreateLoginSuccessReply(
      _fbb,
      _session_id);
}

inline HeroListRequestT *HeroListRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HeroListRequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HeroListRequest::UnPackTo(HeroListRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<HeroListRequest> HeroListRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroListRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHeroListRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HeroListRequest> CreateHeroListRequest(flatbuffers::FlatBufferBuilder &_fbb, const HeroListRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return CreateHeroListRequest(
      _fbb);
}

inline HeroListFailedReplyT *HeroListFailedReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HeroListFailedReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HeroListFailedReply::UnPackTo(HeroListFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<HeroListFailedReply> HeroListFailedReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroListFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHeroListFailedReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HeroListFailedReply> CreateHeroListFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const HeroListFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateHeroListFailedReply(
      _fbb,
      _error_code);
}

inline HeroListReplyT *HeroListReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HeroListReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HeroListReply::UnPackTo(HeroListReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hero_list(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->hero_list.push_back(std::unique_ptr<HeroSimpleT>(_e->Get(_i)->UnPack(_resolver))); } };
}

inline flatbuffers::Offset<HeroListReply> HeroListReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeroListReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHeroListReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HeroListReply> CreateHeroListReply(flatbuffers::FlatBufferBuilder &_fbb, const HeroListReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _hero_list = _o->hero_list.size() ? _fbb.CreateVector<flatbuffers::Offset<HeroSimple>>(_o->hero_list.size(), [&](size_t i) { return CreateHeroSimple(_fbb, _o->hero_list[i].get(), _rehasher); }) : 0;
  return CreateHeroListReply(
      _fbb,
      _hero_list);
}

inline SelectHeroRequestT *SelectHeroRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SelectHeroRequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SelectHeroRequest::UnPackTo(SelectHeroRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hero_id(); _o->hero_id = _e; };
}

inline flatbuffers::Offset<SelectHeroRequest> SelectHeroRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectHeroRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelectHeroRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectHeroRequest> CreateSelectHeroRequest(flatbuffers::FlatBufferBuilder &_fbb, const SelectHeroRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _hero_id = _o->hero_id;
  return CreateSelectHeroRequest(
      _fbb,
      _hero_id);
}

inline SelectHeroFailedReplyT *SelectHeroFailedReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SelectHeroFailedReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SelectHeroFailedReply::UnPackTo(SelectHeroFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<SelectHeroFailedReply> SelectHeroFailedReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectHeroFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelectHeroFailedReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectHeroFailedReply> CreateSelectHeroFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const SelectHeroFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateSelectHeroFailedReply(
      _fbb,
      _error_code);
}

inline SelectHeroSuccessReplyT *SelectHeroSuccessReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SelectHeroSuccessReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SelectHeroSuccessReply::UnPackTo(SelectHeroSuccessReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<SelectHeroSuccessReply> SelectHeroSuccessReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SelectHeroSuccessReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSelectHeroSuccessReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SelectHeroSuccessReply> CreateSelectHeroSuccessReply(flatbuffers::FlatBufferBuilder &_fbb, const SelectHeroSuccessReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return CreateSelectHeroSuccessReply(
      _fbb);
}

inline CreateHeroRequestT *CreateHeroRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CreateHeroRequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CreateHeroRequest::UnPackTo(CreateHeroRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
}

inline flatbuffers::Offset<CreateHeroRequest> CreateHeroRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateHeroRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreateHeroRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreateHeroRequest> CreateCreateHeroRequest(flatbuffers::FlatBufferBuilder &_fbb, const CreateHeroRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  return CreateCreateHeroRequest(
      _fbb,
      _name,
      _class_type);
}

inline CreateHeroFailedReplyT *CreateHeroFailedReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CreateHeroFailedReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CreateHeroFailedReply::UnPackTo(CreateHeroFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<CreateHeroFailedReply> CreateHeroFailedReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateHeroFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreateHeroFailedReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreateHeroFailedReply> CreateCreateHeroFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const CreateHeroFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateCreateHeroFailedReply(
      _fbb,
      _error_code);
}

inline CreateHeroSuccessReplyT *CreateHeroSuccessReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CreateHeroSuccessReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CreateHeroSuccessReply::UnPackTo(CreateHeroSuccessReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hero(); if (_e) _o->hero = std::unique_ptr<HeroSimpleT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CreateHeroSuccessReply> CreateHeroSuccessReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateHeroSuccessReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreateHeroSuccessReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreateHeroSuccessReply> CreateCreateHeroSuccessReply(flatbuffers::FlatBufferBuilder &_fbb, const CreateHeroSuccessReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _hero = _o->hero ? CreateHeroSimple(_fbb, _o->hero.get(), _rehasher) : 0;
  return CreateCreateHeroSuccessReply(
      _fbb,
      _hero);
}

inline DeleteHeroRequestT *DeleteHeroRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DeleteHeroRequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DeleteHeroRequest::UnPackTo(DeleteHeroRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hero_id(); _o->hero_id = _e; };
}

inline flatbuffers::Offset<DeleteHeroRequest> DeleteHeroRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeleteHeroRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeleteHeroRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DeleteHeroRequest> CreateDeleteHeroRequest(flatbuffers::FlatBufferBuilder &_fbb, const DeleteHeroRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _hero_id = _o->hero_id;
  return CreateDeleteHeroRequest(
      _fbb,
      _hero_id);
}

inline DeleteHeroFailedReplyT *DeleteHeroFailedReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DeleteHeroFailedReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DeleteHeroFailedReply::UnPackTo(DeleteHeroFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<DeleteHeroFailedReply> DeleteHeroFailedReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeleteHeroFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeleteHeroFailedReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DeleteHeroFailedReply> CreateDeleteHeroFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const DeleteHeroFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateDeleteHeroFailedReply(
      _fbb,
      _error_code);
}

inline DeleteHeroSuccessReplyT *DeleteHeroSuccessReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DeleteHeroSuccessReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DeleteHeroSuccessReply::UnPackTo(DeleteHeroSuccessReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hero_id(); _o->hero_id = _e; };
}

inline flatbuffers::Offset<DeleteHeroSuccessReply> DeleteHeroSuccessReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeleteHeroSuccessReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeleteHeroSuccessReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DeleteHeroSuccessReply> CreateDeleteHeroSuccessReply(flatbuffers::FlatBufferBuilder &_fbb, const DeleteHeroSuccessReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _hero_id = _o->hero_id;
  return CreateDeleteHeroSuccessReply(
      _fbb,
      _hero_id);
}

inline EnterGameRequestT *EnterGameRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EnterGameRequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EnterGameRequest::UnPackTo(EnterGameRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = hero_id(); _o->hero_id = _e; };
}

inline flatbuffers::Offset<EnterGameRequest> EnterGameRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnterGameRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EnterGameRequest> CreateEnterGameRequest(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _hero_id = _o->hero_id;
  return CreateEnterGameRequest(
      _fbb,
      _hero_id);
}

inline BeginEnterGameReplyT *BeginEnterGameReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BeginEnterGameReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BeginEnterGameReply::UnPackTo(BeginEnterGameReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<BeginEnterGameReply> BeginEnterGameReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BeginEnterGameReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBeginEnterGameReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BeginEnterGameReply> CreateBeginEnterGameReply(flatbuffers::FlatBufferBuilder &_fbb, const BeginEnterGameReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return CreateBeginEnterGameReply(
      _fbb);
}

inline EnterGameFailedReplyT *EnterGameFailedReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EnterGameFailedReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EnterGameFailedReply::UnPackTo(EnterGameFailedReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<EnterGameFailedReply> EnterGameFailedReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameFailedReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnterGameFailedReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EnterGameFailedReply> CreateEnterGameFailedReply(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameFailedReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateEnterGameFailedReply(
      _fbb,
      _error_code);
}

inline LoadGameReplyT *LoadGameReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LoadGameReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LoadGameReply::UnPackTo(LoadGameReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<LoadGameReply> LoadGameReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoadGameReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoadGameReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoadGameReply> CreateLoadGameReply(flatbuffers::FlatBufferBuilder &_fbb, const LoadGameReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return CreateLoadGameReply(
      _fbb);
}

inline EndLoadGameRequestT *EndLoadGameRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EndLoadGameRequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EndLoadGameRequest::UnPackTo(EndLoadGameRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<EndLoadGameRequest> EndLoadGameRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndLoadGameRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEndLoadGameRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EndLoadGameRequest> CreateEndLoadGameRequest(flatbuffers::FlatBufferBuilder &_fbb, const EndLoadGameRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return CreateEndLoadGameRequest(
      _fbb);
}

inline GameStartReplyT *GameStartReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GameStartReplyT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GameStartReply::UnPackTo(GameStartReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<GameStartReply> GameStartReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GameStartReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGameStartReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GameStartReply> CreateGameStartReply(flatbuffers::FlatBufferBuilder &_fbb, const GameStartReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return CreateGameStartReply(
      _fbb);
}

inline NetMessageT *NetMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NetMessageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NetMessage::UnPackTo(NetMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_type(); _o->message.type = _e; };
  { auto _e = message(); if (_e) _o->message.table = MessageTUnion::UnPack(_e, message_type(),_resolver); };
}

inline flatbuffers::Offset<NetMessage> NetMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNetMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NetMessage> CreateNetMessage(flatbuffers::FlatBufferBuilder &_fbb, const NetMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  return CreateNetMessage(
      _fbb,
      _message_type,
      _message);
}

inline bool VerifyMessageT(flatbuffers::Verifier &verifier, const void *obj, MessageT type) {
  switch (type) {
    case MessageT_NONE: {
      return true;
    }
    case MessageT_LoginRequest: {
      auto ptr = reinterpret_cast<const LoginRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_LoginFailedReply: {
      auto ptr = reinterpret_cast<const LoginFailedReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_LoginSuccessReply: {
      auto ptr = reinterpret_cast<const LoginSuccessReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_JoinRequest: {
      auto ptr = reinterpret_cast<const JoinRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_JoinFailedReply: {
      auto ptr = reinterpret_cast<const JoinFailedReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_JoinSuccessReply: {
      auto ptr = reinterpret_cast<const JoinSuccessReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_HeroListRequest: {
      auto ptr = reinterpret_cast<const HeroListRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_HeroListFailedReply: {
      auto ptr = reinterpret_cast<const HeroListFailedReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_HeroListReply: {
      auto ptr = reinterpret_cast<const HeroListReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_CreateHeroRequest: {
      auto ptr = reinterpret_cast<const CreateHeroRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_CreateHeroFailedReply: {
      auto ptr = reinterpret_cast<const CreateHeroFailedReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_CreateHeroSuccessReply: {
      auto ptr = reinterpret_cast<const CreateHeroSuccessReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_DeleteHeroRequest: {
      auto ptr = reinterpret_cast<const DeleteHeroRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_DeleteHeroFailedReply: {
      auto ptr = reinterpret_cast<const DeleteHeroFailedReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_DeleteHeroSuccessReply: {
      auto ptr = reinterpret_cast<const DeleteHeroSuccessReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_EnterGameRequest: {
      auto ptr = reinterpret_cast<const EnterGameRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_EnterGameFailedReply: {
      auto ptr = reinterpret_cast<const EnterGameFailedReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_BeginEnterGameReply: {
      auto ptr = reinterpret_cast<const BeginEnterGameReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_LoadGameReply: {
      auto ptr = reinterpret_cast<const LoadGameReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_EndLoadGameRequest: {
      auto ptr = reinterpret_cast<const EndLoadGameRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_GameStartReply: {
      auto ptr = reinterpret_cast<const GameStartReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline flatbuffers::NativeTable *MessageTUnion::UnPack(const void *obj, MessageT type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case MessageT_LoginRequest: {
      auto ptr = reinterpret_cast<const LoginRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_LoginFailedReply: {
      auto ptr = reinterpret_cast<const LoginFailedReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_LoginSuccessReply: {
      auto ptr = reinterpret_cast<const LoginSuccessReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_JoinRequest: {
      auto ptr = reinterpret_cast<const JoinRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_JoinFailedReply: {
      auto ptr = reinterpret_cast<const JoinFailedReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_JoinSuccessReply: {
      auto ptr = reinterpret_cast<const JoinSuccessReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_HeroListRequest: {
      auto ptr = reinterpret_cast<const HeroListRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_HeroListFailedReply: {
      auto ptr = reinterpret_cast<const HeroListFailedReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_HeroListReply: {
      auto ptr = reinterpret_cast<const HeroListReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_CreateHeroRequest: {
      auto ptr = reinterpret_cast<const CreateHeroRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_CreateHeroFailedReply: {
      auto ptr = reinterpret_cast<const CreateHeroFailedReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_CreateHeroSuccessReply: {
      auto ptr = reinterpret_cast<const CreateHeroSuccessReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_DeleteHeroRequest: {
      auto ptr = reinterpret_cast<const DeleteHeroRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_DeleteHeroFailedReply: {
      auto ptr = reinterpret_cast<const DeleteHeroFailedReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_DeleteHeroSuccessReply: {
      auto ptr = reinterpret_cast<const DeleteHeroSuccessReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_EnterGameRequest: {
      auto ptr = reinterpret_cast<const EnterGameRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_EnterGameFailedReply: {
      auto ptr = reinterpret_cast<const EnterGameFailedReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_BeginEnterGameReply: {
      auto ptr = reinterpret_cast<const BeginEnterGameReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_LoadGameReply: {
      auto ptr = reinterpret_cast<const LoadGameReply *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_EndLoadGameRequest: {
      auto ptr = reinterpret_cast<const EndLoadGameRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_GameStartReply: {
      auto ptr = reinterpret_cast<const GameStartReply *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageTUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case MessageT_LoginRequest: {
      auto ptr = reinterpret_cast<const LoginRequestT *>(table);
      return CreateLoginRequest(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_LoginFailedReply: {
      auto ptr = reinterpret_cast<const LoginFailedReplyT *>(table);
      return CreateLoginFailedReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_LoginSuccessReply: {
      auto ptr = reinterpret_cast<const LoginSuccessReplyT *>(table);
      return CreateLoginSuccessReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_JoinRequest: {
      auto ptr = reinterpret_cast<const JoinRequestT *>(table);
      return CreateJoinRequest(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_JoinFailedReply: {
      auto ptr = reinterpret_cast<const JoinFailedReplyT *>(table);
      return CreateJoinFailedReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_JoinSuccessReply: {
      auto ptr = reinterpret_cast<const JoinSuccessReplyT *>(table);
      return CreateJoinSuccessReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_HeroListRequest: {
      auto ptr = reinterpret_cast<const HeroListRequestT *>(table);
      return CreateHeroListRequest(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_HeroListFailedReply: {
      auto ptr = reinterpret_cast<const HeroListFailedReplyT *>(table);
      return CreateHeroListFailedReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_HeroListReply: {
      auto ptr = reinterpret_cast<const HeroListReplyT *>(table);
      return CreateHeroListReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_CreateHeroRequest: {
      auto ptr = reinterpret_cast<const CreateHeroRequestT *>(table);
      return CreateCreateHeroRequest(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_CreateHeroFailedReply: {
      auto ptr = reinterpret_cast<const CreateHeroFailedReplyT *>(table);
      return CreateCreateHeroFailedReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_CreateHeroSuccessReply: {
      auto ptr = reinterpret_cast<const CreateHeroSuccessReplyT *>(table);
      return CreateCreateHeroSuccessReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_DeleteHeroRequest: {
      auto ptr = reinterpret_cast<const DeleteHeroRequestT *>(table);
      return CreateDeleteHeroRequest(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_DeleteHeroFailedReply: {
      auto ptr = reinterpret_cast<const DeleteHeroFailedReplyT *>(table);
      return CreateDeleteHeroFailedReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_DeleteHeroSuccessReply: {
      auto ptr = reinterpret_cast<const DeleteHeroSuccessReplyT *>(table);
      return CreateDeleteHeroSuccessReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_EnterGameRequest: {
      auto ptr = reinterpret_cast<const EnterGameRequestT *>(table);
      return CreateEnterGameRequest(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_EnterGameFailedReply: {
      auto ptr = reinterpret_cast<const EnterGameFailedReplyT *>(table);
      return CreateEnterGameFailedReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_BeginEnterGameReply: {
      auto ptr = reinterpret_cast<const BeginEnterGameReplyT *>(table);
      return CreateBeginEnterGameReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_LoadGameReply: {
      auto ptr = reinterpret_cast<const LoadGameReplyT *>(table);
      return CreateLoadGameReply(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_EndLoadGameRequest: {
      auto ptr = reinterpret_cast<const EndLoadGameRequestT *>(table);
      return CreateEndLoadGameRequest(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_GameStartReply: {
      auto ptr = reinterpret_cast<const GameStartReplyT *>(table);
      return CreateGameStartReply(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline void MessageTUnion::Reset() {
  switch (type) {
    case MessageT_LoginRequest: {
      auto ptr = reinterpret_cast<LoginRequestT *>(table);
      delete ptr;
      break;
    }
    case MessageT_LoginFailedReply: {
      auto ptr = reinterpret_cast<LoginFailedReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_LoginSuccessReply: {
      auto ptr = reinterpret_cast<LoginSuccessReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_JoinRequest: {
      auto ptr = reinterpret_cast<JoinRequestT *>(table);
      delete ptr;
      break;
    }
    case MessageT_JoinFailedReply: {
      auto ptr = reinterpret_cast<JoinFailedReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_JoinSuccessReply: {
      auto ptr = reinterpret_cast<JoinSuccessReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_HeroListRequest: {
      auto ptr = reinterpret_cast<HeroListRequestT *>(table);
      delete ptr;
      break;
    }
    case MessageT_HeroListFailedReply: {
      auto ptr = reinterpret_cast<HeroListFailedReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_HeroListReply: {
      auto ptr = reinterpret_cast<HeroListReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_CreateHeroRequest: {
      auto ptr = reinterpret_cast<CreateHeroRequestT *>(table);
      delete ptr;
      break;
    }
    case MessageT_CreateHeroFailedReply: {
      auto ptr = reinterpret_cast<CreateHeroFailedReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_CreateHeroSuccessReply: {
      auto ptr = reinterpret_cast<CreateHeroSuccessReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_DeleteHeroRequest: {
      auto ptr = reinterpret_cast<DeleteHeroRequestT *>(table);
      delete ptr;
      break;
    }
    case MessageT_DeleteHeroFailedReply: {
      auto ptr = reinterpret_cast<DeleteHeroFailedReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_DeleteHeroSuccessReply: {
      auto ptr = reinterpret_cast<DeleteHeroSuccessReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_EnterGameRequest: {
      auto ptr = reinterpret_cast<EnterGameRequestT *>(table);
      delete ptr;
      break;
    }
    case MessageT_EnterGameFailedReply: {
      auto ptr = reinterpret_cast<EnterGameFailedReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_BeginEnterGameReply: {
      auto ptr = reinterpret_cast<BeginEnterGameReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_LoadGameReply: {
      auto ptr = reinterpret_cast<LoadGameReplyT *>(table);
      delete ptr;
      break;
    }
    case MessageT_EndLoadGameRequest: {
      auto ptr = reinterpret_cast<EndLoadGameRequestT *>(table);
      delete ptr;
      break;
    }
    case MessageT_GameStartReply: {
      auto ptr = reinterpret_cast<GameStartReplyT *>(table);
      delete ptr;
      break;
    }
    default: break;
  }
  table = nullptr;
  type = MessageT_NONE;
}

inline const mmog::protocol::NetMessage *GetNetMessage(const void *buf) {
  return flatbuffers::GetRoot<mmog::protocol::NetMessage>(buf);
}

inline bool VerifyNetMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mmog::protocol::NetMessage>(nullptr);
}

inline void FinishNetMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mmog::protocol::NetMessage> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<NetMessageT> UnPackNetMessage(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NetMessageT>(GetNetMessage(buf)->UnPack(res));
}

}  // namespace protocol
}  // namespace mmog

#endif  // FLATBUFFERS_GENERATED_GAMEMESSAGE_MMOG_PROTOCOL_H_
