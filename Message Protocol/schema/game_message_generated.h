// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAMEMESSAGE_MMOG_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_GAMEMESSAGE_MMOG_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace mmog {
namespace protocol {

struct Vec2;

struct Vec3;

struct CharacterSimple;
struct CharacterSimpleT;

struct Character;
struct CharacterT;

struct RemoteCharacter;
struct RemoteCharacterT;

struct RequestLogin;
struct RequestLoginT;

struct LoginFailed;
struct LoginFailedT;

struct LoginSuccess;
struct LoginSuccessT;

struct RequestJoin;
struct RequestJoinT;

struct JoinFailed;
struct JoinFailedT;

struct JoinSuccess;
struct JoinSuccessT;

struct RequestCharacterList;
struct RequestCharacterListT;

struct CharacterListFailed;
struct CharacterListFailedT;

struct CharacterListSuccess;
struct CharacterListSuccessT;

struct RequestCreateCharacter;
struct RequestCreateCharacterT;

struct CreateCharacterFailed;
struct CreateCharacterFailedT;

struct CreateCharacterSuccess;
struct CreateCharacterSuccessT;

struct RequestDeleteCharacter;
struct RequestDeleteCharacterT;

struct DeleteCharacterFailed;
struct DeleteCharacterFailedT;

struct DeleteCharacterSuccess;
struct DeleteCharacterSuccessT;

struct RequestEnterGame;
struct RequestEnterGameT;

struct EnterGameFailed;
struct EnterGameFailedT;

struct EnterGameSuccess;
struct EnterGameSuccessT;

struct SpawnRemoteCharacter;
struct SpawnRemoteCharacterT;

struct MoveCharacter;
struct MoveCharacterT;

struct NetMessage;
struct NetMessageT;

enum ErrorCode {
  ErrorCode_SUCCESS = 0,
  ErrorCode_INVALID_SESSION = 10,
  ErrorCode_INVALID_STRING = 20,
  ErrorCode_LOGIN_INCORRECT_ACC_NAME = 100,
  ErrorCode_LOGIN_INCORRECT_ACC_PASSWORD = 101,
  ErrorCode_LOGIN_ALREADY = 102,
  ErrorCode_JOIN_ACC_NAME_ALREADY = 200,
  ErrorCode_JOIN_CANNOT_ACC_CREATE = 201,
  ErrorCode_CREATE_CHARACTER_NAME_ALREADY = 301,
  ErrorCode_CREATE_CHARACTER_CANNOT_CREATE = 302,
  ErrorCode_CREATE_CHARACTER_ATTRIBUTE_NOT_EXIST = 303,
  ErrorCode_DELETE_CHARACTER_NOT_EXIST = 401,
  ErrorCode_DELETE_CHARACTER_CANNOT_DELETE = 402,
  ErrorCode_ENTER_GAME_INVALID_CHARACTER = 501,
  ErrorCode_ENTER_GAME_INVALID_STATE = 502,
  ErrorCode_MIN = ErrorCode_SUCCESS,
  ErrorCode_MAX = ErrorCode_ENTER_GAME_INVALID_STATE
};

enum MessageT {
  MessageT_NONE = 0,
  MessageT_RequestLogin = 1,
  MessageT_LoginFailed = 2,
  MessageT_LoginSuccess = 3,
  MessageT_RequestJoin = 4,
  MessageT_JoinFailed = 5,
  MessageT_JoinSuccess = 6,
  MessageT_RequestCharacterList = 7,
  MessageT_CharacterListFailed = 8,
  MessageT_CharacterListSuccess = 9,
  MessageT_RequestCreateCharacter = 10,
  MessageT_CreateCharacterFailed = 11,
  MessageT_CreateCharacterSuccess = 12,
  MessageT_RequestDeleteCharacter = 13,
  MessageT_DeleteCharacterFailed = 14,
  MessageT_DeleteCharacterSuccess = 15,
  MessageT_RequestEnterGame = 16,
  MessageT_EnterGameFailed = 17,
  MessageT_EnterGameSuccess = 18,
  MessageT_SpawnRemoteCharacter = 19,
  MessageT_MoveCharacter = 20,
  MessageT_MIN = MessageT_NONE,
  MessageT_MAX = MessageT_MoveCharacter
};

inline const char **EnumNamesMessageT() {
  static const char *names[] = {
    "NONE",
    "RequestLogin",
    "LoginFailed",
    "LoginSuccess",
    "RequestJoin",
    "JoinFailed",
    "JoinSuccess",
    "RequestCharacterList",
    "CharacterListFailed",
    "CharacterListSuccess",
    "RequestCreateCharacter",
    "CreateCharacterFailed",
    "CreateCharacterSuccess",
    "RequestDeleteCharacter",
    "DeleteCharacterFailed",
    "DeleteCharacterSuccess",
    "RequestEnterGame",
    "EnterGameFailed",
    "EnterGameSuccess",
    "SpawnRemoteCharacter",
    "MoveCharacter",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageT(MessageT e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageT()[index];
}

template<typename T> struct MessageTTraits {
  static const MessageT enum_value = MessageT_NONE;
};

template<> struct MessageTTraits<RequestLogin> {
  static const MessageT enum_value = MessageT_RequestLogin;
};

template<> struct MessageTTraits<LoginFailed> {
  static const MessageT enum_value = MessageT_LoginFailed;
};

template<> struct MessageTTraits<LoginSuccess> {
  static const MessageT enum_value = MessageT_LoginSuccess;
};

template<> struct MessageTTraits<RequestJoin> {
  static const MessageT enum_value = MessageT_RequestJoin;
};

template<> struct MessageTTraits<JoinFailed> {
  static const MessageT enum_value = MessageT_JoinFailed;
};

template<> struct MessageTTraits<JoinSuccess> {
  static const MessageT enum_value = MessageT_JoinSuccess;
};

template<> struct MessageTTraits<RequestCharacterList> {
  static const MessageT enum_value = MessageT_RequestCharacterList;
};

template<> struct MessageTTraits<CharacterListFailed> {
  static const MessageT enum_value = MessageT_CharacterListFailed;
};

template<> struct MessageTTraits<CharacterListSuccess> {
  static const MessageT enum_value = MessageT_CharacterListSuccess;
};

template<> struct MessageTTraits<RequestCreateCharacter> {
  static const MessageT enum_value = MessageT_RequestCreateCharacter;
};

template<> struct MessageTTraits<CreateCharacterFailed> {
  static const MessageT enum_value = MessageT_CreateCharacterFailed;
};

template<> struct MessageTTraits<CreateCharacterSuccess> {
  static const MessageT enum_value = MessageT_CreateCharacterSuccess;
};

template<> struct MessageTTraits<RequestDeleteCharacter> {
  static const MessageT enum_value = MessageT_RequestDeleteCharacter;
};

template<> struct MessageTTraits<DeleteCharacterFailed> {
  static const MessageT enum_value = MessageT_DeleteCharacterFailed;
};

template<> struct MessageTTraits<DeleteCharacterSuccess> {
  static const MessageT enum_value = MessageT_DeleteCharacterSuccess;
};

template<> struct MessageTTraits<RequestEnterGame> {
  static const MessageT enum_value = MessageT_RequestEnterGame;
};

template<> struct MessageTTraits<EnterGameFailed> {
  static const MessageT enum_value = MessageT_EnterGameFailed;
};

template<> struct MessageTTraits<EnterGameSuccess> {
  static const MessageT enum_value = MessageT_EnterGameSuccess;
};

template<> struct MessageTTraits<SpawnRemoteCharacter> {
  static const MessageT enum_value = MessageT_SpawnRemoteCharacter;
};

template<> struct MessageTTraits<MoveCharacter> {
  static const MessageT enum_value = MessageT_MoveCharacter;
};

struct MessageTUnion {
  MessageT type;
  flatbuffers::NativeTable *table;

  MessageTUnion() : type(MessageT_NONE), table(nullptr) {}
  MessageTUnion(const MessageTUnion &);
  MessageTUnion &operator=(const MessageTUnion &);
  ~MessageTUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& value) {
    Reset();
    type = MessageTTraits<typename T::TableType>::enum_value;
    if (type != MessageT_NONE) {
      table = new T(std::forward<T>(value));
    }
  }

  static flatbuffers::NativeTable *UnPack(const void *obj, MessageT type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  RequestLoginT *AsRequestLogin() {
    return type == MessageT_RequestLogin ?
      reinterpret_cast<RequestLoginT *>(table) : nullptr;
  }
  LoginFailedT *AsLoginFailed() {
    return type == MessageT_LoginFailed ?
      reinterpret_cast<LoginFailedT *>(table) : nullptr;
  }
  LoginSuccessT *AsLoginSuccess() {
    return type == MessageT_LoginSuccess ?
      reinterpret_cast<LoginSuccessT *>(table) : nullptr;
  }
  RequestJoinT *AsRequestJoin() {
    return type == MessageT_RequestJoin ?
      reinterpret_cast<RequestJoinT *>(table) : nullptr;
  }
  JoinFailedT *AsJoinFailed() {
    return type == MessageT_JoinFailed ?
      reinterpret_cast<JoinFailedT *>(table) : nullptr;
  }
  JoinSuccessT *AsJoinSuccess() {
    return type == MessageT_JoinSuccess ?
      reinterpret_cast<JoinSuccessT *>(table) : nullptr;
  }
  RequestCharacterListT *AsRequestCharacterList() {
    return type == MessageT_RequestCharacterList ?
      reinterpret_cast<RequestCharacterListT *>(table) : nullptr;
  }
  CharacterListFailedT *AsCharacterListFailed() {
    return type == MessageT_CharacterListFailed ?
      reinterpret_cast<CharacterListFailedT *>(table) : nullptr;
  }
  CharacterListSuccessT *AsCharacterListSuccess() {
    return type == MessageT_CharacterListSuccess ?
      reinterpret_cast<CharacterListSuccessT *>(table) : nullptr;
  }
  RequestCreateCharacterT *AsRequestCreateCharacter() {
    return type == MessageT_RequestCreateCharacter ?
      reinterpret_cast<RequestCreateCharacterT *>(table) : nullptr;
  }
  CreateCharacterFailedT *AsCreateCharacterFailed() {
    return type == MessageT_CreateCharacterFailed ?
      reinterpret_cast<CreateCharacterFailedT *>(table) : nullptr;
  }
  CreateCharacterSuccessT *AsCreateCharacterSuccess() {
    return type == MessageT_CreateCharacterSuccess ?
      reinterpret_cast<CreateCharacterSuccessT *>(table) : nullptr;
  }
  RequestDeleteCharacterT *AsRequestDeleteCharacter() {
    return type == MessageT_RequestDeleteCharacter ?
      reinterpret_cast<RequestDeleteCharacterT *>(table) : nullptr;
  }
  DeleteCharacterFailedT *AsDeleteCharacterFailed() {
    return type == MessageT_DeleteCharacterFailed ?
      reinterpret_cast<DeleteCharacterFailedT *>(table) : nullptr;
  }
  DeleteCharacterSuccessT *AsDeleteCharacterSuccess() {
    return type == MessageT_DeleteCharacterSuccess ?
      reinterpret_cast<DeleteCharacterSuccessT *>(table) : nullptr;
  }
  RequestEnterGameT *AsRequestEnterGame() {
    return type == MessageT_RequestEnterGame ?
      reinterpret_cast<RequestEnterGameT *>(table) : nullptr;
  }
  EnterGameFailedT *AsEnterGameFailed() {
    return type == MessageT_EnterGameFailed ?
      reinterpret_cast<EnterGameFailedT *>(table) : nullptr;
  }
  EnterGameSuccessT *AsEnterGameSuccess() {
    return type == MessageT_EnterGameSuccess ?
      reinterpret_cast<EnterGameSuccessT *>(table) : nullptr;
  }
  SpawnRemoteCharacterT *AsSpawnRemoteCharacter() {
    return type == MessageT_SpawnRemoteCharacter ?
      reinterpret_cast<SpawnRemoteCharacterT *>(table) : nullptr;
  }
  MoveCharacterT *AsMoveCharacter() {
    return type == MessageT_MoveCharacter ?
      reinterpret_cast<MoveCharacterT *>(table) : nullptr;
  }
};

bool VerifyMessageT(flatbuffers::Verifier &verifier, const void *obj, MessageT type);

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() {
    memset(this, 0, sizeof(Vec2));
  }
  Vec2(const Vec2 &_o) {
    memcpy(this, &_o, sizeof(Vec2));
  }
  Vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(this, 0, sizeof(Vec3));
  }
  Vec3(const Vec3 &_o) {
    memcpy(this, &_o, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vec3, 12);

struct CharacterSimpleT : public flatbuffers::NativeTable {
  typedef CharacterSimple TableType;
  int32_t id;
  std::string name;
  int32_t class_type;
  int32_t level;
  CharacterSimpleT()
      : id(0),
        class_type(0),
        level(0) {
  }
};

struct CharacterSimple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CharacterSimpleT NativeTableType;
  enum {
    VT_ID = 4,
    VT_NAME = 6,
    VT_CLASS_TYPE = 8,
    VT_LEVEL = 10
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t class_type() const {
    return GetField<int32_t>(VT_CLASS_TYPE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
  CharacterSimpleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CharacterSimpleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CharacterSimple> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CharacterSimpleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CharacterSimpleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(CharacterSimple::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CharacterSimple::VT_NAME, name);
  }
  void add_class_type(int32_t class_type) {
    fbb_.AddElement<int32_t>(CharacterSimple::VT_CLASS_TYPE, class_type, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(CharacterSimple::VT_LEVEL, level, 0);
  }
  CharacterSimpleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CharacterSimpleBuilder &operator=(const CharacterSimpleBuilder &);
  flatbuffers::Offset<CharacterSimple> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<CharacterSimple>(end);
    return o;
  }
};

inline flatbuffers::Offset<CharacterSimple> CreateCharacterSimple(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t class_type = 0,
    int32_t level = 0) {
  CharacterSimpleBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<CharacterSimple> CreateCharacterSimpleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    int32_t class_type = 0,
    int32_t level = 0) {
  return CreateCharacterSimple(
      _fbb,
      id,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      level);
}

flatbuffers::Offset<CharacterSimple> CreateCharacterSimple(flatbuffers::FlatBufferBuilder &_fbb, const CharacterSimpleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CharacterT : public flatbuffers::NativeTable {
  typedef Character TableType;
  int32_t uid;
  std::string name;
  int32_t class_type;
  int32_t exp;
  int32_t level;
  int32_t hp;
  int32_t mp;
  int32_t att;
  int32_t def;
  int32_t zone_id;
  std::unique_ptr<Vec3> pos;
  float rotation_y;
  std::unique_ptr<Vec3> direction;
  float speed;
  CharacterT()
      : uid(0),
        class_type(0),
        exp(0),
        level(0),
        hp(0),
        mp(0),
        att(0),
        def(0),
        zone_id(0),
        rotation_y(0.0f),
        speed(0.0f) {
  }
};

struct Character FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CharacterT NativeTableType;
  enum {
    VT_UID = 4,
    VT_NAME = 6,
    VT_CLASS_TYPE = 8,
    VT_EXP = 10,
    VT_LEVEL = 12,
    VT_HP = 14,
    VT_MP = 16,
    VT_ATT = 18,
    VT_DEF = 20,
    VT_ZONE_ID = 22,
    VT_POS = 24,
    VT_ROTATION_Y = 26,
    VT_DIRECTION = 28,
    VT_SPEED = 30
  };
  int32_t uid() const {
    return GetField<int32_t>(VT_UID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t class_type() const {
    return GetField<int32_t>(VT_CLASS_TYPE, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  int32_t att() const {
    return GetField<int32_t>(VT_ATT, 0);
  }
  int32_t def() const {
    return GetField<int32_t>(VT_DEF, 0);
  }
  int32_t zone_id() const {
    return GetField<int32_t>(VT_ZONE_ID, 0);
  }
  const Vec3 *pos() const {
    return GetStruct<const Vec3 *>(VT_POS);
  }
  float rotation_y() const {
    return GetField<float>(VT_ROTATION_Y, 0.0f);
  }
  const Vec3 *direction() const {
    return GetStruct<const Vec3 *>(VT_DIRECTION);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<int32_t>(verifier, VT_ATT) &&
           VerifyField<int32_t>(verifier, VT_DEF) &&
           VerifyField<int32_t>(verifier, VT_ZONE_ID) &&
           VerifyField<Vec3>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_ROTATION_Y) &&
           VerifyField<Vec3>(verifier, VT_DIRECTION) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           verifier.EndTable();
  }
  CharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Character> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(int32_t uid) {
    fbb_.AddElement<int32_t>(Character::VT_UID, uid, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Character::VT_NAME, name);
  }
  void add_class_type(int32_t class_type) {
    fbb_.AddElement<int32_t>(Character::VT_CLASS_TYPE, class_type, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(Character::VT_EXP, exp, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(Character::VT_LEVEL, level, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(Character::VT_HP, hp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(Character::VT_MP, mp, 0);
  }
  void add_att(int32_t att) {
    fbb_.AddElement<int32_t>(Character::VT_ATT, att, 0);
  }
  void add_def(int32_t def) {
    fbb_.AddElement<int32_t>(Character::VT_DEF, def, 0);
  }
  void add_zone_id(int32_t zone_id) {
    fbb_.AddElement<int32_t>(Character::VT_ZONE_ID, zone_id, 0);
  }
  void add_pos(const Vec3 *pos) {
    fbb_.AddStruct(Character::VT_POS, pos);
  }
  void add_rotation_y(float rotation_y) {
    fbb_.AddElement<float>(Character::VT_ROTATION_Y, rotation_y, 0.0f);
  }
  void add_direction(const Vec3 *direction) {
    fbb_.AddStruct(Character::VT_DIRECTION, direction);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Character::VT_SPEED, speed, 0.0f);
  }
  CharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CharacterBuilder &operator=(const CharacterBuilder &);
  flatbuffers::Offset<Character> Finish() {
    const auto end = fbb_.EndTable(start_, 14);
    auto o = flatbuffers::Offset<Character>(end);
    return o;
  }
};

inline flatbuffers::Offset<Character> CreateCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t uid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t class_type = 0,
    int32_t exp = 0,
    int32_t level = 0,
    int32_t hp = 0,
    int32_t mp = 0,
    int32_t att = 0,
    int32_t def = 0,
    int32_t zone_id = 0,
    const Vec3 *pos = 0,
    float rotation_y = 0.0f,
    const Vec3 *direction = 0,
    float speed = 0.0f) {
  CharacterBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_direction(direction);
  builder_.add_rotation_y(rotation_y);
  builder_.add_pos(pos);
  builder_.add_zone_id(zone_id);
  builder_.add_def(def);
  builder_.add_att(att);
  builder_.add_mp(mp);
  builder_.add_hp(hp);
  builder_.add_level(level);
  builder_.add_exp(exp);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_uid(uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Character> CreateCharacterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t uid = 0,
    const char *name = nullptr,
    int32_t class_type = 0,
    int32_t exp = 0,
    int32_t level = 0,
    int32_t hp = 0,
    int32_t mp = 0,
    int32_t att = 0,
    int32_t def = 0,
    int32_t zone_id = 0,
    const Vec3 *pos = 0,
    float rotation_y = 0.0f,
    const Vec3 *direction = 0,
    float speed = 0.0f) {
  return CreateCharacter(
      _fbb,
      uid,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      exp,
      level,
      hp,
      mp,
      att,
      def,
      zone_id,
      pos,
      rotation_y,
      direction,
      speed);
}

flatbuffers::Offset<Character> CreateCharacter(flatbuffers::FlatBufferBuilder &_fbb, const CharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RemoteCharacterT : public flatbuffers::NativeTable {
  typedef RemoteCharacter TableType;
  int32_t uid;
  std::string name;
  int32_t class_type;
  int32_t level;
  int32_t hp;
  int32_t mp;
  std::unique_ptr<Vec3> pos;
  float rotation_y;
  std::unique_ptr<Vec3> direction;
  float speed;
  RemoteCharacterT()
      : uid(0),
        class_type(0),
        level(0),
        hp(0),
        mp(0),
        rotation_y(0.0f),
        speed(0.0f) {
  }
};

struct RemoteCharacter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RemoteCharacterT NativeTableType;
  enum {
    VT_UID = 4,
    VT_NAME = 6,
    VT_CLASS_TYPE = 8,
    VT_LEVEL = 10,
    VT_HP = 12,
    VT_MP = 14,
    VT_POS = 16,
    VT_ROTATION_Y = 18,
    VT_DIRECTION = 20,
    VT_SPEED = 22
  };
  int32_t uid() const {
    return GetField<int32_t>(VT_UID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t class_type() const {
    return GetField<int32_t>(VT_CLASS_TYPE, 0);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  const Vec3 *pos() const {
    return GetStruct<const Vec3 *>(VT_POS);
  }
  float rotation_y() const {
    return GetField<float>(VT_ROTATION_Y, 0.0f);
  }
  const Vec3 *direction() const {
    return GetStruct<const Vec3 *>(VT_DIRECTION);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UID) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<Vec3>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_ROTATION_Y) &&
           VerifyField<Vec3>(verifier, VT_DIRECTION) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           verifier.EndTable();
  }
  RemoteCharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RemoteCharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RemoteCharacter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemoteCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RemoteCharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(int32_t uid) {
    fbb_.AddElement<int32_t>(RemoteCharacter::VT_UID, uid, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RemoteCharacter::VT_NAME, name);
  }
  void add_class_type(int32_t class_type) {
    fbb_.AddElement<int32_t>(RemoteCharacter::VT_CLASS_TYPE, class_type, 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(RemoteCharacter::VT_LEVEL, level, 0);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(RemoteCharacter::VT_HP, hp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(RemoteCharacter::VT_MP, mp, 0);
  }
  void add_pos(const Vec3 *pos) {
    fbb_.AddStruct(RemoteCharacter::VT_POS, pos);
  }
  void add_rotation_y(float rotation_y) {
    fbb_.AddElement<float>(RemoteCharacter::VT_ROTATION_Y, rotation_y, 0.0f);
  }
  void add_direction(const Vec3 *direction) {
    fbb_.AddStruct(RemoteCharacter::VT_DIRECTION, direction);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(RemoteCharacter::VT_SPEED, speed, 0.0f);
  }
  RemoteCharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoteCharacterBuilder &operator=(const RemoteCharacterBuilder &);
  flatbuffers::Offset<RemoteCharacter> Finish() {
    const auto end = fbb_.EndTable(start_, 10);
    auto o = flatbuffers::Offset<RemoteCharacter>(end);
    return o;
  }
};

inline flatbuffers::Offset<RemoteCharacter> CreateRemoteCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t uid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t class_type = 0,
    int32_t level = 0,
    int32_t hp = 0,
    int32_t mp = 0,
    const Vec3 *pos = 0,
    float rotation_y = 0.0f,
    const Vec3 *direction = 0,
    float speed = 0.0f) {
  RemoteCharacterBuilder builder_(_fbb);
  builder_.add_speed(speed);
  builder_.add_direction(direction);
  builder_.add_rotation_y(rotation_y);
  builder_.add_pos(pos);
  builder_.add_mp(mp);
  builder_.add_hp(hp);
  builder_.add_level(level);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  builder_.add_uid(uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<RemoteCharacter> CreateRemoteCharacterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t uid = 0,
    const char *name = nullptr,
    int32_t class_type = 0,
    int32_t level = 0,
    int32_t hp = 0,
    int32_t mp = 0,
    const Vec3 *pos = 0,
    float rotation_y = 0.0f,
    const Vec3 *direction = 0,
    float speed = 0.0f) {
  return CreateRemoteCharacter(
      _fbb,
      uid,
      name ? _fbb.CreateString(name) : 0,
      class_type,
      level,
      hp,
      mp,
      pos,
      rotation_y,
      direction,
      speed);
}

flatbuffers::Offset<RemoteCharacter> CreateRemoteCharacter(flatbuffers::FlatBufferBuilder &_fbb, const RemoteCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RequestLoginT : public flatbuffers::NativeTable {
  typedef RequestLogin TableType;
  std::string acc_name;
  std::string password;
  RequestLoginT() {
  }
};

struct RequestLogin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestLoginT NativeTableType;
  enum {
    VT_ACC_NAME = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *acc_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ACC_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ACC_NAME) &&
           verifier.Verify(acc_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
  RequestLoginT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RequestLoginT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RequestLogin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestLoginT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RequestLoginBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc_name(flatbuffers::Offset<flatbuffers::String> acc_name) {
    fbb_.AddOffset(RequestLogin::VT_ACC_NAME, acc_name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(RequestLogin::VT_PASSWORD, password);
  }
  RequestLoginBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestLoginBuilder &operator=(const RequestLoginBuilder &);
  flatbuffers::Offset<RequestLogin> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<RequestLogin>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestLogin> CreateRequestLogin(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> acc_name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  RequestLoginBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_acc_name(acc_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<RequestLogin> CreateRequestLoginDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *acc_name = nullptr,
    const char *password = nullptr) {
  return CreateRequestLogin(
      _fbb,
      acc_name ? _fbb.CreateString(acc_name) : 0,
      password ? _fbb.CreateString(password) : 0);
}

flatbuffers::Offset<RequestLogin> CreateRequestLogin(flatbuffers::FlatBufferBuilder &_fbb, const RequestLoginT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoginFailedT : public flatbuffers::NativeTable {
  typedef LoginFailed TableType;
  ErrorCode error_code;
  LoginFailedT()
      : error_code(ErrorCode_SUCCESS) {
  }
};

struct LoginFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoginFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  LoginFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoginFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoginFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoginFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(LoginFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  LoginFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoginFailedBuilder &operator=(const LoginFailedBuilder &);
  flatbuffers::Offset<LoginFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<LoginFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoginFailed> CreateLoginFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_SUCCESS) {
  LoginFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<LoginFailed> CreateLoginFailed(flatbuffers::FlatBufferBuilder &_fbb, const LoginFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LoginSuccessT : public flatbuffers::NativeTable {
  typedef LoginSuccess TableType;
  std::string session_id;
  LoginSuccessT() {
  }
};

struct LoginSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LoginSuccessT NativeTableType;
  enum {
    VT_SESSION_ID = 4
  };
  const flatbuffers::String *session_id() const {
    return GetPointer<const flatbuffers::String *>(VT_SESSION_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SESSION_ID) &&
           verifier.Verify(session_id()) &&
           verifier.EndTable();
  }
  LoginSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LoginSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LoginSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LoginSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session_id(flatbuffers::Offset<flatbuffers::String> session_id) {
    fbb_.AddOffset(LoginSuccess::VT_SESSION_ID, session_id);
  }
  LoginSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoginSuccessBuilder &operator=(const LoginSuccessBuilder &);
  flatbuffers::Offset<LoginSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<LoginSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoginSuccess> CreateLoginSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> session_id = 0) {
  LoginSuccessBuilder builder_(_fbb);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoginSuccess> CreateLoginSuccessDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *session_id = nullptr) {
  return CreateLoginSuccess(
      _fbb,
      session_id ? _fbb.CreateString(session_id) : 0);
}

flatbuffers::Offset<LoginSuccess> CreateLoginSuccess(flatbuffers::FlatBufferBuilder &_fbb, const LoginSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RequestJoinT : public flatbuffers::NativeTable {
  typedef RequestJoin TableType;
  std::string acc_name;
  std::string password;
  RequestJoinT() {
  }
};

struct RequestJoin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestJoinT NativeTableType;
  enum {
    VT_ACC_NAME = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *acc_name() const {
    return GetPointer<const flatbuffers::String *>(VT_ACC_NAME);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ACC_NAME) &&
           verifier.Verify(acc_name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PASSWORD) &&
           verifier.Verify(password()) &&
           verifier.EndTable();
  }
  RequestJoinT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RequestJoinT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RequestJoin> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestJoinT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RequestJoinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_acc_name(flatbuffers::Offset<flatbuffers::String> acc_name) {
    fbb_.AddOffset(RequestJoin::VT_ACC_NAME, acc_name);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(RequestJoin::VT_PASSWORD, password);
  }
  RequestJoinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestJoinBuilder &operator=(const RequestJoinBuilder &);
  flatbuffers::Offset<RequestJoin> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<RequestJoin>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestJoin> CreateRequestJoin(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> acc_name = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  RequestJoinBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_acc_name(acc_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<RequestJoin> CreateRequestJoinDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *acc_name = nullptr,
    const char *password = nullptr) {
  return CreateRequestJoin(
      _fbb,
      acc_name ? _fbb.CreateString(acc_name) : 0,
      password ? _fbb.CreateString(password) : 0);
}

flatbuffers::Offset<RequestJoin> CreateRequestJoin(flatbuffers::FlatBufferBuilder &_fbb, const RequestJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JoinFailedT : public flatbuffers::NativeTable {
  typedef JoinFailed TableType;
  ErrorCode error_code;
  JoinFailedT()
      : error_code(ErrorCode_SUCCESS) {
  }
};

struct JoinFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JoinFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  JoinFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JoinFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<JoinFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const JoinFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JoinFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(JoinFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  JoinFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinFailedBuilder &operator=(const JoinFailedBuilder &);
  flatbuffers::Offset<JoinFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<JoinFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<JoinFailed> CreateJoinFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_SUCCESS) {
  JoinFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<JoinFailed> CreateJoinFailed(flatbuffers::FlatBufferBuilder &_fbb, const JoinFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JoinSuccessT : public flatbuffers::NativeTable {
  typedef JoinSuccess TableType;
  JoinSuccessT() {
  }
};

struct JoinSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef JoinSuccessT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  JoinSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JoinSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<JoinSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const JoinSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JoinSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  JoinSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JoinSuccessBuilder &operator=(const JoinSuccessBuilder &);
  flatbuffers::Offset<JoinSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<JoinSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<JoinSuccess> CreateJoinSuccess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  JoinSuccessBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<JoinSuccess> CreateJoinSuccess(flatbuffers::FlatBufferBuilder &_fbb, const JoinSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RequestCharacterListT : public flatbuffers::NativeTable {
  typedef RequestCharacterList TableType;
  RequestCharacterListT() {
  }
};

struct RequestCharacterList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestCharacterListT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  RequestCharacterListT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RequestCharacterListT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RequestCharacterList> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestCharacterListT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RequestCharacterListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  RequestCharacterListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestCharacterListBuilder &operator=(const RequestCharacterListBuilder &);
  flatbuffers::Offset<RequestCharacterList> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<RequestCharacterList>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestCharacterList> CreateRequestCharacterList(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RequestCharacterListBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<RequestCharacterList> CreateRequestCharacterList(flatbuffers::FlatBufferBuilder &_fbb, const RequestCharacterListT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CharacterListFailedT : public flatbuffers::NativeTable {
  typedef CharacterListFailed TableType;
  ErrorCode error_code;
  CharacterListFailedT()
      : error_code(ErrorCode_SUCCESS) {
  }
};

struct CharacterListFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CharacterListFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  CharacterListFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CharacterListFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CharacterListFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CharacterListFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CharacterListFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(CharacterListFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  CharacterListFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CharacterListFailedBuilder &operator=(const CharacterListFailedBuilder &);
  flatbuffers::Offset<CharacterListFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CharacterListFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<CharacterListFailed> CreateCharacterListFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_SUCCESS) {
  CharacterListFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<CharacterListFailed> CreateCharacterListFailed(flatbuffers::FlatBufferBuilder &_fbb, const CharacterListFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CharacterListSuccessT : public flatbuffers::NativeTable {
  typedef CharacterListSuccess TableType;
  std::vector<std::unique_ptr<CharacterSimpleT>> list;
  CharacterListSuccessT() {
  }
};

struct CharacterListSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CharacterListSuccessT NativeTableType;
  enum {
    VT_LIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<CharacterSimple>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CharacterSimple>> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LIST) &&
           verifier.Verify(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           verifier.EndTable();
  }
  CharacterListSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CharacterListSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CharacterListSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CharacterListSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CharacterListSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CharacterSimple>>> list) {
    fbb_.AddOffset(CharacterListSuccess::VT_LIST, list);
  }
  CharacterListSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CharacterListSuccessBuilder &operator=(const CharacterListSuccessBuilder &);
  flatbuffers::Offset<CharacterListSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CharacterListSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<CharacterListSuccess> CreateCharacterListSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CharacterSimple>>> list = 0) {
  CharacterListSuccessBuilder builder_(_fbb);
  builder_.add_list(list);
  return builder_.Finish();
}

inline flatbuffers::Offset<CharacterListSuccess> CreateCharacterListSuccessDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<CharacterSimple>> *list = nullptr) {
  return CreateCharacterListSuccess(
      _fbb,
      list ? _fbb.CreateVector<flatbuffers::Offset<CharacterSimple>>(*list) : 0);
}

flatbuffers::Offset<CharacterListSuccess> CreateCharacterListSuccess(flatbuffers::FlatBufferBuilder &_fbb, const CharacterListSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RequestCreateCharacterT : public flatbuffers::NativeTable {
  typedef RequestCreateCharacter TableType;
  std::string name;
  int32_t class_type;
  RequestCreateCharacterT()
      : class_type(0) {
  }
};

struct RequestCreateCharacter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestCreateCharacterT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_CLASS_TYPE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t class_type() const {
    return GetField<int32_t>(VT_CLASS_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_CLASS_TYPE) &&
           verifier.EndTable();
  }
  RequestCreateCharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RequestCreateCharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RequestCreateCharacter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestCreateCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RequestCreateCharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RequestCreateCharacter::VT_NAME, name);
  }
  void add_class_type(int32_t class_type) {
    fbb_.AddElement<int32_t>(RequestCreateCharacter::VT_CLASS_TYPE, class_type, 0);
  }
  RequestCreateCharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestCreateCharacterBuilder &operator=(const RequestCreateCharacterBuilder &);
  flatbuffers::Offset<RequestCreateCharacter> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<RequestCreateCharacter>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestCreateCharacter> CreateRequestCreateCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t class_type = 0) {
  RequestCreateCharacterBuilder builder_(_fbb);
  builder_.add_class_type(class_type);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<RequestCreateCharacter> CreateRequestCreateCharacterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t class_type = 0) {
  return CreateRequestCreateCharacter(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      class_type);
}

flatbuffers::Offset<RequestCreateCharacter> CreateRequestCreateCharacter(flatbuffers::FlatBufferBuilder &_fbb, const RequestCreateCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreateCharacterFailedT : public flatbuffers::NativeTable {
  typedef CreateCharacterFailed TableType;
  ErrorCode error_code;
  CreateCharacterFailedT()
      : error_code(ErrorCode_SUCCESS) {
  }
};

struct CreateCharacterFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateCharacterFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  CreateCharacterFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreateCharacterFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreateCharacterFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateCharacterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreateCharacterFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(CreateCharacterFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  CreateCharacterFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreateCharacterFailedBuilder &operator=(const CreateCharacterFailedBuilder &);
  flatbuffers::Offset<CreateCharacterFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CreateCharacterFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateCharacterFailed> CreateCreateCharacterFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_SUCCESS) {
  CreateCharacterFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<CreateCharacterFailed> CreateCreateCharacterFailed(flatbuffers::FlatBufferBuilder &_fbb, const CreateCharacterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreateCharacterSuccessT : public flatbuffers::NativeTable {
  typedef CreateCharacterSuccess TableType;
  std::unique_ptr<CharacterSimpleT> character;
  CreateCharacterSuccessT() {
  }
};

struct CreateCharacterSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreateCharacterSuccessT NativeTableType;
  enum {
    VT_CHARACTER = 4
  };
  const CharacterSimple *character() const {
    return GetPointer<const CharacterSimple *>(VT_CHARACTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHARACTER) &&
           verifier.VerifyTable(character()) &&
           verifier.EndTable();
  }
  CreateCharacterSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreateCharacterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreateCharacterSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateCharacterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreateCharacterSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character(flatbuffers::Offset<CharacterSimple> character) {
    fbb_.AddOffset(CreateCharacterSuccess::VT_CHARACTER, character);
  }
  CreateCharacterSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CreateCharacterSuccessBuilder &operator=(const CreateCharacterSuccessBuilder &);
  flatbuffers::Offset<CreateCharacterSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<CreateCharacterSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreateCharacterSuccess> CreateCreateCharacterSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<CharacterSimple> character = 0) {
  CreateCharacterSuccessBuilder builder_(_fbb);
  builder_.add_character(character);
  return builder_.Finish();
}

flatbuffers::Offset<CreateCharacterSuccess> CreateCreateCharacterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const CreateCharacterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RequestDeleteCharacterT : public flatbuffers::NativeTable {
  typedef RequestDeleteCharacter TableType;
  int32_t character_id;
  RequestDeleteCharacterT()
      : character_id(0) {
  }
};

struct RequestDeleteCharacter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestDeleteCharacterT NativeTableType;
  enum {
    VT_CHARACTER_ID = 4
  };
  int32_t character_id() const {
    return GetField<int32_t>(VT_CHARACTER_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARACTER_ID) &&
           verifier.EndTable();
  }
  RequestDeleteCharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RequestDeleteCharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RequestDeleteCharacter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestDeleteCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RequestDeleteCharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character_id(int32_t character_id) {
    fbb_.AddElement<int32_t>(RequestDeleteCharacter::VT_CHARACTER_ID, character_id, 0);
  }
  RequestDeleteCharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestDeleteCharacterBuilder &operator=(const RequestDeleteCharacterBuilder &);
  flatbuffers::Offset<RequestDeleteCharacter> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<RequestDeleteCharacter>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestDeleteCharacter> CreateRequestDeleteCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_id = 0) {
  RequestDeleteCharacterBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

flatbuffers::Offset<RequestDeleteCharacter> CreateRequestDeleteCharacter(flatbuffers::FlatBufferBuilder &_fbb, const RequestDeleteCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeleteCharacterFailedT : public flatbuffers::NativeTable {
  typedef DeleteCharacterFailed TableType;
  ErrorCode error_code;
  DeleteCharacterFailedT()
      : error_code(ErrorCode_SUCCESS) {
  }
};

struct DeleteCharacterFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeleteCharacterFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  DeleteCharacterFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeleteCharacterFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DeleteCharacterFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeleteCharacterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeleteCharacterFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(DeleteCharacterFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  DeleteCharacterFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeleteCharacterFailedBuilder &operator=(const DeleteCharacterFailedBuilder &);
  flatbuffers::Offset<DeleteCharacterFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DeleteCharacterFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeleteCharacterFailed> CreateDeleteCharacterFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_SUCCESS) {
  DeleteCharacterFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<DeleteCharacterFailed> CreateDeleteCharacterFailed(flatbuffers::FlatBufferBuilder &_fbb, const DeleteCharacterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DeleteCharacterSuccessT : public flatbuffers::NativeTable {
  typedef DeleteCharacterSuccess TableType;
  int32_t character_id;
  DeleteCharacterSuccessT()
      : character_id(0) {
  }
};

struct DeleteCharacterSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeleteCharacterSuccessT NativeTableType;
  enum {
    VT_CHARACTER_ID = 4
  };
  int32_t character_id() const {
    return GetField<int32_t>(VT_CHARACTER_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARACTER_ID) &&
           verifier.EndTable();
  }
  DeleteCharacterSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DeleteCharacterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DeleteCharacterSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeleteCharacterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DeleteCharacterSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character_id(int32_t character_id) {
    fbb_.AddElement<int32_t>(DeleteCharacterSuccess::VT_CHARACTER_ID, character_id, 0);
  }
  DeleteCharacterSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeleteCharacterSuccessBuilder &operator=(const DeleteCharacterSuccessBuilder &);
  flatbuffers::Offset<DeleteCharacterSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<DeleteCharacterSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeleteCharacterSuccess> CreateDeleteCharacterSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_id = 0) {
  DeleteCharacterSuccessBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

flatbuffers::Offset<DeleteCharacterSuccess> CreateDeleteCharacterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const DeleteCharacterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RequestEnterGameT : public flatbuffers::NativeTable {
  typedef RequestEnterGame TableType;
  int32_t character_id;
  RequestEnterGameT()
      : character_id(0) {
  }
};

struct RequestEnterGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestEnterGameT NativeTableType;
  enum {
    VT_CHARACTER_ID = 4
  };
  int32_t character_id() const {
    return GetField<int32_t>(VT_CHARACTER_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARACTER_ID) &&
           verifier.EndTable();
  }
  RequestEnterGameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RequestEnterGameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RequestEnterGame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestEnterGameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RequestEnterGameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character_id(int32_t character_id) {
    fbb_.AddElement<int32_t>(RequestEnterGame::VT_CHARACTER_ID, character_id, 0);
  }
  RequestEnterGameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestEnterGameBuilder &operator=(const RequestEnterGameBuilder &);
  flatbuffers::Offset<RequestEnterGame> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<RequestEnterGame>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestEnterGame> CreateRequestEnterGame(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_id = 0) {
  RequestEnterGameBuilder builder_(_fbb);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

flatbuffers::Offset<RequestEnterGame> CreateRequestEnterGame(flatbuffers::FlatBufferBuilder &_fbb, const RequestEnterGameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnterGameFailedT : public flatbuffers::NativeTable {
  typedef EnterGameFailed TableType;
  ErrorCode error_code;
  EnterGameFailedT()
      : error_code(ErrorCode_SUCCESS) {
  }
};

struct EnterGameFailed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnterGameFailedT NativeTableType;
  enum {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<int32_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  EnterGameFailedT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnterGameFailedT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EnterGameFailed> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnterGameFailedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<int32_t>(EnterGameFailed::VT_ERROR_CODE, static_cast<int32_t>(error_code), 0);
  }
  EnterGameFailedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterGameFailedBuilder &operator=(const EnterGameFailedBuilder &);
  flatbuffers::Offset<EnterGameFailed> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<EnterGameFailed>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnterGameFailed> CreateEnterGameFailed(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode_SUCCESS) {
  EnterGameFailedBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<EnterGameFailed> CreateEnterGameFailed(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnterGameSuccessT : public flatbuffers::NativeTable {
  typedef EnterGameSuccess TableType;
  std::unique_ptr<CharacterT> character;
  EnterGameSuccessT() {
  }
};

struct EnterGameSuccess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnterGameSuccessT NativeTableType;
  enum {
    VT_CHARACTER = 4
  };
  const Character *character() const {
    return GetPointer<const Character *>(VT_CHARACTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHARACTER) &&
           verifier.VerifyTable(character()) &&
           verifier.EndTable();
  }
  EnterGameSuccessT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnterGameSuccessT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EnterGameSuccess> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnterGameSuccessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character(flatbuffers::Offset<Character> character) {
    fbb_.AddOffset(EnterGameSuccess::VT_CHARACTER, character);
  }
  EnterGameSuccessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterGameSuccessBuilder &operator=(const EnterGameSuccessBuilder &);
  flatbuffers::Offset<EnterGameSuccess> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<EnterGameSuccess>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnterGameSuccess> CreateEnterGameSuccess(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Character> character = 0) {
  EnterGameSuccessBuilder builder_(_fbb);
  builder_.add_character(character);
  return builder_.Finish();
}

flatbuffers::Offset<EnterGameSuccess> CreateEnterGameSuccess(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpawnRemoteCharacterT : public flatbuffers::NativeTable {
  typedef SpawnRemoteCharacter TableType;
  std::unique_ptr<RemoteCharacterT> character;
  SpawnRemoteCharacterT() {
  }
};

struct SpawnRemoteCharacter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpawnRemoteCharacterT NativeTableType;
  enum {
    VT_CHARACTER = 4
  };
  const RemoteCharacter *character() const {
    return GetPointer<const RemoteCharacter *>(VT_CHARACTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHARACTER) &&
           verifier.VerifyTable(character()) &&
           verifier.EndTable();
  }
  SpawnRemoteCharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpawnRemoteCharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SpawnRemoteCharacter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpawnRemoteCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpawnRemoteCharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_character(flatbuffers::Offset<RemoteCharacter> character) {
    fbb_.AddOffset(SpawnRemoteCharacter::VT_CHARACTER, character);
  }
  SpawnRemoteCharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpawnRemoteCharacterBuilder &operator=(const SpawnRemoteCharacterBuilder &);
  flatbuffers::Offset<SpawnRemoteCharacter> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<SpawnRemoteCharacter>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpawnRemoteCharacter> CreateSpawnRemoteCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<RemoteCharacter> character = 0) {
  SpawnRemoteCharacterBuilder builder_(_fbb);
  builder_.add_character(character);
  return builder_.Finish();
}

flatbuffers::Offset<SpawnRemoteCharacter> CreateSpawnRemoteCharacter(flatbuffers::FlatBufferBuilder &_fbb, const SpawnRemoteCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveCharacterT : public flatbuffers::NativeTable {
  typedef MoveCharacter TableType;
  int32_t uid;
  std::unique_ptr<Vec3> pos;
  float rotation_y;
  std::unique_ptr<Vec3> velocity;
  MoveCharacterT()
      : uid(0),
        rotation_y(0.0f) {
  }
};

struct MoveCharacter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoveCharacterT NativeTableType;
  enum {
    VT_UID = 4,
    VT_POS = 6,
    VT_ROTATION_Y = 8,
    VT_VELOCITY = 10
  };
  int32_t uid() const {
    return GetField<int32_t>(VT_UID, 0);
  }
  const Vec3 *pos() const {
    return GetStruct<const Vec3 *>(VT_POS);
  }
  float rotation_y() const {
    return GetField<float>(VT_ROTATION_Y, 0.0f);
  }
  const Vec3 *velocity() const {
    return GetStruct<const Vec3 *>(VT_VELOCITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_UID) &&
           VerifyField<Vec3>(verifier, VT_POS) &&
           VerifyField<float>(verifier, VT_ROTATION_Y) &&
           VerifyField<Vec3>(verifier, VT_VELOCITY) &&
           verifier.EndTable();
  }
  MoveCharacterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveCharacterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MoveCharacter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveCharacterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(int32_t uid) {
    fbb_.AddElement<int32_t>(MoveCharacter::VT_UID, uid, 0);
  }
  void add_pos(const Vec3 *pos) {
    fbb_.AddStruct(MoveCharacter::VT_POS, pos);
  }
  void add_rotation_y(float rotation_y) {
    fbb_.AddElement<float>(MoveCharacter::VT_ROTATION_Y, rotation_y, 0.0f);
  }
  void add_velocity(const Vec3 *velocity) {
    fbb_.AddStruct(MoveCharacter::VT_VELOCITY, velocity);
  }
  MoveCharacterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveCharacterBuilder &operator=(const MoveCharacterBuilder &);
  flatbuffers::Offset<MoveCharacter> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<MoveCharacter>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveCharacter> CreateMoveCharacter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t uid = 0,
    const Vec3 *pos = 0,
    float rotation_y = 0.0f,
    const Vec3 *velocity = 0) {
  MoveCharacterBuilder builder_(_fbb);
  builder_.add_velocity(velocity);
  builder_.add_rotation_y(rotation_y);
  builder_.add_pos(pos);
  builder_.add_uid(uid);
  return builder_.Finish();
}

flatbuffers::Offset<MoveCharacter> CreateMoveCharacter(flatbuffers::FlatBufferBuilder &_fbb, const MoveCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NetMessageT : public flatbuffers::NativeTable {
  typedef NetMessage TableType;
  MessageTUnion message;
  NetMessageT() {
  }
};

struct NetMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NetMessageT NativeTableType;
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  MessageT message_type() const {
    return static_cast<MessageT>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           VerifyMessageT(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
  NetMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NetMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NetMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NetMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(MessageT message_type) {
    fbb_.AddElement<uint8_t>(NetMessage::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(NetMessage::VT_MESSAGE, message);
  }
  NetMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NetMessageBuilder &operator=(const NetMessageBuilder &);
  flatbuffers::Offset<NetMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<NetMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetMessage> CreateNetMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    MessageT message_type = MessageT_NONE,
    flatbuffers::Offset<void> message = 0) {
  NetMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

flatbuffers::Offset<NetMessage> CreateNetMessage(flatbuffers::FlatBufferBuilder &_fbb, const NetMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CharacterSimpleT *CharacterSimple::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CharacterSimpleT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CharacterSimple::UnPackTo(CharacterSimpleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = level(); _o->level = _e; };
}

inline flatbuffers::Offset<CharacterSimple> CharacterSimple::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CharacterSimpleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCharacterSimple(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CharacterSimple> CreateCharacterSimple(flatbuffers::FlatBufferBuilder &_fbb, const CharacterSimpleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _id = _o->id;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _level = _o->level;
  return CreateCharacterSimple(
      _fbb,
      _id,
      _name,
      _class_type,
      _level);
}

inline CharacterT *Character::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Character::UnPackTo(CharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uid(); _o->uid = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = exp(); _o->exp = _e; };
  { auto _e = level(); _o->level = _e; };
  { auto _e = hp(); _o->hp = _e; };
  { auto _e = mp(); _o->mp = _e; };
  { auto _e = att(); _o->att = _e; };
  { auto _e = def(); _o->def = _e; };
  { auto _e = zone_id(); _o->zone_id = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = rotation_y(); _o->rotation_y = _e; };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = speed(); _o->speed = _e; };
}

inline flatbuffers::Offset<Character> Character::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Character> CreateCharacter(flatbuffers::FlatBufferBuilder &_fbb, const CharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uid = _o->uid;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _exp = _o->exp;
  auto _level = _o->level;
  auto _hp = _o->hp;
  auto _mp = _o->mp;
  auto _att = _o->att;
  auto _def = _o->def;
  auto _zone_id = _o->zone_id;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _rotation_y = _o->rotation_y;
  auto _direction = _o->direction ? _o->direction.get() : 0;
  auto _speed = _o->speed;
  return CreateCharacter(
      _fbb,
      _uid,
      _name,
      _class_type,
      _exp,
      _level,
      _hp,
      _mp,
      _att,
      _def,
      _zone_id,
      _pos,
      _rotation_y,
      _direction,
      _speed);
}

inline RemoteCharacterT *RemoteCharacter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RemoteCharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RemoteCharacter::UnPackTo(RemoteCharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uid(); _o->uid = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
  { auto _e = level(); _o->level = _e; };
  { auto _e = hp(); _o->hp = _e; };
  { auto _e = mp(); _o->mp = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = rotation_y(); _o->rotation_y = _e; };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = speed(); _o->speed = _e; };
}

inline flatbuffers::Offset<RemoteCharacter> RemoteCharacter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RemoteCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRemoteCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RemoteCharacter> CreateRemoteCharacter(flatbuffers::FlatBufferBuilder &_fbb, const RemoteCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uid = _o->uid;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  auto _level = _o->level;
  auto _hp = _o->hp;
  auto _mp = _o->mp;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _rotation_y = _o->rotation_y;
  auto _direction = _o->direction ? _o->direction.get() : 0;
  auto _speed = _o->speed;
  return CreateRemoteCharacter(
      _fbb,
      _uid,
      _name,
      _class_type,
      _level,
      _hp,
      _mp,
      _pos,
      _rotation_y,
      _direction,
      _speed);
}

inline RequestLoginT *RequestLogin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RequestLoginT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RequestLogin::UnPackTo(RequestLoginT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = acc_name(); if (_e) _o->acc_name = _e->str(); };
  { auto _e = password(); if (_e) _o->password = _e->str(); };
}

inline flatbuffers::Offset<RequestLogin> RequestLogin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestLoginT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequestLogin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RequestLogin> CreateRequestLogin(flatbuffers::FlatBufferBuilder &_fbb, const RequestLoginT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _acc_name = _o->acc_name.size() ? _fbb.CreateString(_o->acc_name) : 0;
  auto _password = _o->password.size() ? _fbb.CreateString(_o->password) : 0;
  return CreateRequestLogin(
      _fbb,
      _acc_name,
      _password);
}

inline LoginFailedT *LoginFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LoginFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LoginFailed::UnPackTo(LoginFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<LoginFailed> LoginFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoginFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoginFailed> CreateLoginFailed(flatbuffers::FlatBufferBuilder &_fbb, const LoginFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateLoginFailed(
      _fbb,
      _error_code);
}

inline LoginSuccessT *LoginSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LoginSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LoginSuccess::UnPackTo(LoginSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session_id(); if (_e) _o->session_id = _e->str(); };
}

inline flatbuffers::Offset<LoginSuccess> LoginSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LoginSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLoginSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LoginSuccess> CreateLoginSuccess(flatbuffers::FlatBufferBuilder &_fbb, const LoginSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _session_id = _o->session_id.size() ? _fbb.CreateString(_o->session_id) : 0;
  return CreateLoginSuccess(
      _fbb,
      _session_id);
}

inline RequestJoinT *RequestJoin::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RequestJoinT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RequestJoin::UnPackTo(RequestJoinT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = acc_name(); if (_e) _o->acc_name = _e->str(); };
  { auto _e = password(); if (_e) _o->password = _e->str(); };
}

inline flatbuffers::Offset<RequestJoin> RequestJoin::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestJoinT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequestJoin(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RequestJoin> CreateRequestJoin(flatbuffers::FlatBufferBuilder &_fbb, const RequestJoinT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _acc_name = _o->acc_name.size() ? _fbb.CreateString(_o->acc_name) : 0;
  auto _password = _o->password.size() ? _fbb.CreateString(_o->password) : 0;
  return CreateRequestJoin(
      _fbb,
      _acc_name,
      _password);
}

inline JoinFailedT *JoinFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new JoinFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void JoinFailed::UnPackTo(JoinFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<JoinFailed> JoinFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const JoinFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJoinFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<JoinFailed> CreateJoinFailed(flatbuffers::FlatBufferBuilder &_fbb, const JoinFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateJoinFailed(
      _fbb,
      _error_code);
}

inline JoinSuccessT *JoinSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new JoinSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void JoinSuccess::UnPackTo(JoinSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<JoinSuccess> JoinSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const JoinSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJoinSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<JoinSuccess> CreateJoinSuccess(flatbuffers::FlatBufferBuilder &_fbb, const JoinSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return CreateJoinSuccess(
      _fbb);
}

inline RequestCharacterListT *RequestCharacterList::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RequestCharacterListT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RequestCharacterList::UnPackTo(RequestCharacterListT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<RequestCharacterList> RequestCharacterList::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestCharacterListT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequestCharacterList(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RequestCharacterList> CreateRequestCharacterList(flatbuffers::FlatBufferBuilder &_fbb, const RequestCharacterListT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  return CreateRequestCharacterList(
      _fbb);
}

inline CharacterListFailedT *CharacterListFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CharacterListFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CharacterListFailed::UnPackTo(CharacterListFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<CharacterListFailed> CharacterListFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CharacterListFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCharacterListFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CharacterListFailed> CreateCharacterListFailed(flatbuffers::FlatBufferBuilder &_fbb, const CharacterListFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateCharacterListFailed(
      _fbb,
      _error_code);
}

inline CharacterListSuccessT *CharacterListSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CharacterListSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CharacterListSuccess::UnPackTo(CharacterListSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = list(); if (_e) for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->list.push_back(std::unique_ptr<CharacterSimpleT>(_e->Get(_i)->UnPack(_resolver))); } };
}

inline flatbuffers::Offset<CharacterListSuccess> CharacterListSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CharacterListSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCharacterListSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CharacterListSuccess> CreateCharacterListSuccess(flatbuffers::FlatBufferBuilder &_fbb, const CharacterListSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _list = _o->list.size() ? _fbb.CreateVector<flatbuffers::Offset<CharacterSimple>>(_o->list.size(), [&](size_t i) { return CreateCharacterSimple(_fbb, _o->list[i].get(), _rehasher); }) : 0;
  return CreateCharacterListSuccess(
      _fbb,
      _list);
}

inline RequestCreateCharacterT *RequestCreateCharacter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RequestCreateCharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RequestCreateCharacter::UnPackTo(RequestCreateCharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = class_type(); _o->class_type = _e; };
}

inline flatbuffers::Offset<RequestCreateCharacter> RequestCreateCharacter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestCreateCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequestCreateCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RequestCreateCharacter> CreateRequestCreateCharacter(flatbuffers::FlatBufferBuilder &_fbb, const RequestCreateCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _name = _o->name.size() ? _fbb.CreateString(_o->name) : 0;
  auto _class_type = _o->class_type;
  return CreateRequestCreateCharacter(
      _fbb,
      _name,
      _class_type);
}

inline CreateCharacterFailedT *CreateCharacterFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CreateCharacterFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CreateCharacterFailed::UnPackTo(CreateCharacterFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<CreateCharacterFailed> CreateCharacterFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateCharacterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreateCharacterFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreateCharacterFailed> CreateCreateCharacterFailed(flatbuffers::FlatBufferBuilder &_fbb, const CreateCharacterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateCreateCharacterFailed(
      _fbb,
      _error_code);
}

inline CreateCharacterSuccessT *CreateCharacterSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CreateCharacterSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CreateCharacterSuccess::UnPackTo(CreateCharacterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character(); if (_e) _o->character = std::unique_ptr<CharacterSimpleT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CreateCharacterSuccess> CreateCharacterSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreateCharacterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreateCharacterSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreateCharacterSuccess> CreateCreateCharacterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const CreateCharacterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character = _o->character ? CreateCharacterSimple(_fbb, _o->character.get(), _rehasher) : 0;
  return CreateCreateCharacterSuccess(
      _fbb,
      _character);
}

inline RequestDeleteCharacterT *RequestDeleteCharacter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RequestDeleteCharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RequestDeleteCharacter::UnPackTo(RequestDeleteCharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character_id(); _o->character_id = _e; };
}

inline flatbuffers::Offset<RequestDeleteCharacter> RequestDeleteCharacter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestDeleteCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequestDeleteCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RequestDeleteCharacter> CreateRequestDeleteCharacter(flatbuffers::FlatBufferBuilder &_fbb, const RequestDeleteCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character_id = _o->character_id;
  return CreateRequestDeleteCharacter(
      _fbb,
      _character_id);
}

inline DeleteCharacterFailedT *DeleteCharacterFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DeleteCharacterFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DeleteCharacterFailed::UnPackTo(DeleteCharacterFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<DeleteCharacterFailed> DeleteCharacterFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeleteCharacterFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeleteCharacterFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DeleteCharacterFailed> CreateDeleteCharacterFailed(flatbuffers::FlatBufferBuilder &_fbb, const DeleteCharacterFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateDeleteCharacterFailed(
      _fbb,
      _error_code);
}

inline DeleteCharacterSuccessT *DeleteCharacterSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DeleteCharacterSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DeleteCharacterSuccess::UnPackTo(DeleteCharacterSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character_id(); _o->character_id = _e; };
}

inline flatbuffers::Offset<DeleteCharacterSuccess> DeleteCharacterSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DeleteCharacterSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDeleteCharacterSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DeleteCharacterSuccess> CreateDeleteCharacterSuccess(flatbuffers::FlatBufferBuilder &_fbb, const DeleteCharacterSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character_id = _o->character_id;
  return CreateDeleteCharacterSuccess(
      _fbb,
      _character_id);
}

inline RequestEnterGameT *RequestEnterGame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RequestEnterGameT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RequestEnterGame::UnPackTo(RequestEnterGameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character_id(); _o->character_id = _e; };
}

inline flatbuffers::Offset<RequestEnterGame> RequestEnterGame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestEnterGameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequestEnterGame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RequestEnterGame> CreateRequestEnterGame(flatbuffers::FlatBufferBuilder &_fbb, const RequestEnterGameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character_id = _o->character_id;
  return CreateRequestEnterGame(
      _fbb,
      _character_id);
}

inline EnterGameFailedT *EnterGameFailed::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EnterGameFailedT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EnterGameFailed::UnPackTo(EnterGameFailedT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; };
}

inline flatbuffers::Offset<EnterGameFailed> EnterGameFailed::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameFailedT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnterGameFailed(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EnterGameFailed> CreateEnterGameFailed(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameFailedT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _error_code = _o->error_code;
  return CreateEnterGameFailed(
      _fbb,
      _error_code);
}

inline EnterGameSuccessT *EnterGameSuccess::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EnterGameSuccessT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EnterGameSuccess::UnPackTo(EnterGameSuccessT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character(); if (_e) _o->character = std::unique_ptr<CharacterT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<EnterGameSuccess> EnterGameSuccess::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameSuccessT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnterGameSuccess(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EnterGameSuccess> CreateEnterGameSuccess(flatbuffers::FlatBufferBuilder &_fbb, const EnterGameSuccessT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character = _o->character ? CreateCharacter(_fbb, _o->character.get(), _rehasher) : 0;
  return CreateEnterGameSuccess(
      _fbb,
      _character);
}

inline SpawnRemoteCharacterT *SpawnRemoteCharacter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SpawnRemoteCharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SpawnRemoteCharacter::UnPackTo(SpawnRemoteCharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character(); if (_e) _o->character = std::unique_ptr<RemoteCharacterT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<SpawnRemoteCharacter> SpawnRemoteCharacter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpawnRemoteCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpawnRemoteCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SpawnRemoteCharacter> CreateSpawnRemoteCharacter(flatbuffers::FlatBufferBuilder &_fbb, const SpawnRemoteCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _character = _o->character ? CreateRemoteCharacter(_fbb, _o->character.get(), _rehasher) : 0;
  return CreateSpawnRemoteCharacter(
      _fbb,
      _character);
}

inline MoveCharacterT *MoveCharacter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MoveCharacterT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MoveCharacter::UnPackTo(MoveCharacterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uid(); _o->uid = _e; };
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<Vec3>(new Vec3(*_e)); };
  { auto _e = rotation_y(); _o->rotation_y = _e; };
  { auto _e = velocity(); if (_e) _o->velocity = std::unique_ptr<Vec3>(new Vec3(*_e)); };
}

inline flatbuffers::Offset<MoveCharacter> MoveCharacter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveCharacterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveCharacter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MoveCharacter> CreateMoveCharacter(flatbuffers::FlatBufferBuilder &_fbb, const MoveCharacterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _uid = _o->uid;
  auto _pos = _o->pos ? _o->pos.get() : 0;
  auto _rotation_y = _o->rotation_y;
  auto _velocity = _o->velocity ? _o->velocity.get() : 0;
  return CreateMoveCharacter(
      _fbb,
      _uid,
      _pos,
      _rotation_y,
      _velocity);
}

inline NetMessageT *NetMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NetMessageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NetMessage::UnPackTo(NetMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message_type(); _o->message.type = _e; };
  { auto _e = message(); if (_e) _o->message.table = MessageTUnion::UnPack(_e, message_type(),_resolver); };
}

inline flatbuffers::Offset<NetMessage> NetMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NetMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNetMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NetMessage> CreateNetMessage(flatbuffers::FlatBufferBuilder &_fbb, const NetMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _message_type = _o->message.type;
  auto _message = _o->message.Pack(_fbb);
  return CreateNetMessage(
      _fbb,
      _message_type,
      _message);
}

inline bool VerifyMessageT(flatbuffers::Verifier &verifier, const void *obj, MessageT type) {
  switch (type) {
    case MessageT_NONE: {
      return true;
    }
    case MessageT_RequestLogin: {
      auto ptr = reinterpret_cast<const RequestLogin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_LoginFailed: {
      auto ptr = reinterpret_cast<const LoginFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_LoginSuccess: {
      auto ptr = reinterpret_cast<const LoginSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_RequestJoin: {
      auto ptr = reinterpret_cast<const RequestJoin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_JoinFailed: {
      auto ptr = reinterpret_cast<const JoinFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_JoinSuccess: {
      auto ptr = reinterpret_cast<const JoinSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_RequestCharacterList: {
      auto ptr = reinterpret_cast<const RequestCharacterList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_CharacterListFailed: {
      auto ptr = reinterpret_cast<const CharacterListFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_CharacterListSuccess: {
      auto ptr = reinterpret_cast<const CharacterListSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_RequestCreateCharacter: {
      auto ptr = reinterpret_cast<const RequestCreateCharacter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_CreateCharacterFailed: {
      auto ptr = reinterpret_cast<const CreateCharacterFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_CreateCharacterSuccess: {
      auto ptr = reinterpret_cast<const CreateCharacterSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_RequestDeleteCharacter: {
      auto ptr = reinterpret_cast<const RequestDeleteCharacter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_DeleteCharacterFailed: {
      auto ptr = reinterpret_cast<const DeleteCharacterFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_DeleteCharacterSuccess: {
      auto ptr = reinterpret_cast<const DeleteCharacterSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_RequestEnterGame: {
      auto ptr = reinterpret_cast<const RequestEnterGame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_EnterGameFailed: {
      auto ptr = reinterpret_cast<const EnterGameFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_EnterGameSuccess: {
      auto ptr = reinterpret_cast<const EnterGameSuccess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_SpawnRemoteCharacter: {
      auto ptr = reinterpret_cast<const SpawnRemoteCharacter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageT_MoveCharacter: {
      auto ptr = reinterpret_cast<const MoveCharacter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline flatbuffers::NativeTable *MessageTUnion::UnPack(const void *obj, MessageT type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case MessageT_RequestLogin: {
      auto ptr = reinterpret_cast<const RequestLogin *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_LoginFailed: {
      auto ptr = reinterpret_cast<const LoginFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_LoginSuccess: {
      auto ptr = reinterpret_cast<const LoginSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_RequestJoin: {
      auto ptr = reinterpret_cast<const RequestJoin *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_JoinFailed: {
      auto ptr = reinterpret_cast<const JoinFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_JoinSuccess: {
      auto ptr = reinterpret_cast<const JoinSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_RequestCharacterList: {
      auto ptr = reinterpret_cast<const RequestCharacterList *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_CharacterListFailed: {
      auto ptr = reinterpret_cast<const CharacterListFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_CharacterListSuccess: {
      auto ptr = reinterpret_cast<const CharacterListSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_RequestCreateCharacter: {
      auto ptr = reinterpret_cast<const RequestCreateCharacter *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_CreateCharacterFailed: {
      auto ptr = reinterpret_cast<const CreateCharacterFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_CreateCharacterSuccess: {
      auto ptr = reinterpret_cast<const CreateCharacterSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_RequestDeleteCharacter: {
      auto ptr = reinterpret_cast<const RequestDeleteCharacter *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_DeleteCharacterFailed: {
      auto ptr = reinterpret_cast<const DeleteCharacterFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_DeleteCharacterSuccess: {
      auto ptr = reinterpret_cast<const DeleteCharacterSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_RequestEnterGame: {
      auto ptr = reinterpret_cast<const RequestEnterGame *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_EnterGameFailed: {
      auto ptr = reinterpret_cast<const EnterGameFailed *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_EnterGameSuccess: {
      auto ptr = reinterpret_cast<const EnterGameSuccess *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_SpawnRemoteCharacter: {
      auto ptr = reinterpret_cast<const SpawnRemoteCharacter *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageT_MoveCharacter: {
      auto ptr = reinterpret_cast<const MoveCharacter *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageTUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case MessageT_RequestLogin: {
      auto ptr = reinterpret_cast<const RequestLoginT *>(table);
      return CreateRequestLogin(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_LoginFailed: {
      auto ptr = reinterpret_cast<const LoginFailedT *>(table);
      return CreateLoginFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_LoginSuccess: {
      auto ptr = reinterpret_cast<const LoginSuccessT *>(table);
      return CreateLoginSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_RequestJoin: {
      auto ptr = reinterpret_cast<const RequestJoinT *>(table);
      return CreateRequestJoin(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_JoinFailed: {
      auto ptr = reinterpret_cast<const JoinFailedT *>(table);
      return CreateJoinFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_JoinSuccess: {
      auto ptr = reinterpret_cast<const JoinSuccessT *>(table);
      return CreateJoinSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_RequestCharacterList: {
      auto ptr = reinterpret_cast<const RequestCharacterListT *>(table);
      return CreateRequestCharacterList(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_CharacterListFailed: {
      auto ptr = reinterpret_cast<const CharacterListFailedT *>(table);
      return CreateCharacterListFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_CharacterListSuccess: {
      auto ptr = reinterpret_cast<const CharacterListSuccessT *>(table);
      return CreateCharacterListSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_RequestCreateCharacter: {
      auto ptr = reinterpret_cast<const RequestCreateCharacterT *>(table);
      return CreateRequestCreateCharacter(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_CreateCharacterFailed: {
      auto ptr = reinterpret_cast<const CreateCharacterFailedT *>(table);
      return CreateCreateCharacterFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_CreateCharacterSuccess: {
      auto ptr = reinterpret_cast<const CreateCharacterSuccessT *>(table);
      return CreateCreateCharacterSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_RequestDeleteCharacter: {
      auto ptr = reinterpret_cast<const RequestDeleteCharacterT *>(table);
      return CreateRequestDeleteCharacter(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_DeleteCharacterFailed: {
      auto ptr = reinterpret_cast<const DeleteCharacterFailedT *>(table);
      return CreateDeleteCharacterFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_DeleteCharacterSuccess: {
      auto ptr = reinterpret_cast<const DeleteCharacterSuccessT *>(table);
      return CreateDeleteCharacterSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_RequestEnterGame: {
      auto ptr = reinterpret_cast<const RequestEnterGameT *>(table);
      return CreateRequestEnterGame(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_EnterGameFailed: {
      auto ptr = reinterpret_cast<const EnterGameFailedT *>(table);
      return CreateEnterGameFailed(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_EnterGameSuccess: {
      auto ptr = reinterpret_cast<const EnterGameSuccessT *>(table);
      return CreateEnterGameSuccess(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_SpawnRemoteCharacter: {
      auto ptr = reinterpret_cast<const SpawnRemoteCharacterT *>(table);
      return CreateSpawnRemoteCharacter(_fbb, ptr, _rehasher).Union();
    }
    case MessageT_MoveCharacter: {
      auto ptr = reinterpret_cast<const MoveCharacterT *>(table);
      return CreateMoveCharacter(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline void MessageTUnion::Reset() {
  switch (type) {
    case MessageT_RequestLogin: {
      auto ptr = reinterpret_cast<RequestLoginT *>(table);
      delete ptr;
      break;
    }
    case MessageT_LoginFailed: {
      auto ptr = reinterpret_cast<LoginFailedT *>(table);
      delete ptr;
      break;
    }
    case MessageT_LoginSuccess: {
      auto ptr = reinterpret_cast<LoginSuccessT *>(table);
      delete ptr;
      break;
    }
    case MessageT_RequestJoin: {
      auto ptr = reinterpret_cast<RequestJoinT *>(table);
      delete ptr;
      break;
    }
    case MessageT_JoinFailed: {
      auto ptr = reinterpret_cast<JoinFailedT *>(table);
      delete ptr;
      break;
    }
    case MessageT_JoinSuccess: {
      auto ptr = reinterpret_cast<JoinSuccessT *>(table);
      delete ptr;
      break;
    }
    case MessageT_RequestCharacterList: {
      auto ptr = reinterpret_cast<RequestCharacterListT *>(table);
      delete ptr;
      break;
    }
    case MessageT_CharacterListFailed: {
      auto ptr = reinterpret_cast<CharacterListFailedT *>(table);
      delete ptr;
      break;
    }
    case MessageT_CharacterListSuccess: {
      auto ptr = reinterpret_cast<CharacterListSuccessT *>(table);
      delete ptr;
      break;
    }
    case MessageT_RequestCreateCharacter: {
      auto ptr = reinterpret_cast<RequestCreateCharacterT *>(table);
      delete ptr;
      break;
    }
    case MessageT_CreateCharacterFailed: {
      auto ptr = reinterpret_cast<CreateCharacterFailedT *>(table);
      delete ptr;
      break;
    }
    case MessageT_CreateCharacterSuccess: {
      auto ptr = reinterpret_cast<CreateCharacterSuccessT *>(table);
      delete ptr;
      break;
    }
    case MessageT_RequestDeleteCharacter: {
      auto ptr = reinterpret_cast<RequestDeleteCharacterT *>(table);
      delete ptr;
      break;
    }
    case MessageT_DeleteCharacterFailed: {
      auto ptr = reinterpret_cast<DeleteCharacterFailedT *>(table);
      delete ptr;
      break;
    }
    case MessageT_DeleteCharacterSuccess: {
      auto ptr = reinterpret_cast<DeleteCharacterSuccessT *>(table);
      delete ptr;
      break;
    }
    case MessageT_RequestEnterGame: {
      auto ptr = reinterpret_cast<RequestEnterGameT *>(table);
      delete ptr;
      break;
    }
    case MessageT_EnterGameFailed: {
      auto ptr = reinterpret_cast<EnterGameFailedT *>(table);
      delete ptr;
      break;
    }
    case MessageT_EnterGameSuccess: {
      auto ptr = reinterpret_cast<EnterGameSuccessT *>(table);
      delete ptr;
      break;
    }
    case MessageT_SpawnRemoteCharacter: {
      auto ptr = reinterpret_cast<SpawnRemoteCharacterT *>(table);
      delete ptr;
      break;
    }
    case MessageT_MoveCharacter: {
      auto ptr = reinterpret_cast<MoveCharacterT *>(table);
      delete ptr;
      break;
    }
    default: break;
  }
  table = nullptr;
  type = MessageT_NONE;
}

inline const mmog::protocol::NetMessage *GetNetMessage(const void *buf) {
  return flatbuffers::GetRoot<mmog::protocol::NetMessage>(buf);
}

inline bool VerifyNetMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mmog::protocol::NetMessage>(nullptr);
}

inline void FinishNetMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mmog::protocol::NetMessage> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<NetMessageT> UnPackNetMessage(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<NetMessageT>(GetNetMessage(buf)->UnPack(res));
}

}  // namespace protocol
}  // namespace mmog

#endif  // FLATBUFFERS_GENERATED_GAMEMESSAGE_MMOG_PROTOCOL_H_
